<h1><code>Clojure</code></h1>
<p>A Lisp dialect with a stronger emphasis on functional programming than Common Lisp.</p>
<h2>Comments</h2>
<pre><code class="language-clj"><span class="hljs-comment">; ---------- COMMENT -----------</span>
    <span class="hljs-comment">; single-line comments begin with a semicolon</span>
    <span class="hljs-comment">; there is no built-in implementation for multi-line comments</span>
</code></pre>
<h2>Printing</h2>
<pre><code class="language-clj"><span class="hljs-comment">; ---------- PRINT ----------</span>
    <span class="hljs-comment">; println =&gt; prints strings to stdout and appends a newline to the output</span>
    <span class="hljs-comment">; prn =&gt; prints a more readable representation of data structures to the stdout and appends a newline to the output</span>

(<span class="hljs-name">println</span> <span class="hljs-string">&quot;Hello world!&quot;</span>) <span class="hljs-comment">; prints &quot;Hello world!&quot; to the console with a newline</span>
(<span class="hljs-name"><span class="hljs-built_in">prn</span></span> {<span class="hljs-symbol">:cereal-chicken</span> <span class="hljs-number">2.50</span> <span class="hljs-symbol">:thai-fish</span> <span class="hljs-number">3.00</span> <span class="hljs-symbol">:egg</span> <span class="hljs-number">1.25</span>}) <span class="hljs-comment">; prints the array map in a human-readable format to the console with a newline</span>
</code></pre>
<h2>Quickstart</h2>
<pre><code class="language-clj"><span class="hljs-comment">; ----------- QUICKSTART -----------</span>
    <span class="hljs-comment">; clojure is comprised of forms (list of whitespace delimited things surrounded by () parantheses, similar to expressions)</span>
    <span class="hljs-comment">; clojure assumes the first thing is a function or macro call, and the remaining things are arguments</span>
    <span class="hljs-comment">; clojure types are immutable, so remember to reassign returned values (functional programming!)</span>
    <span class="hljs-comment">; ns =&gt; first call in a clojure file to set the namespace</span>

(<span class="hljs-name"><span class="hljs-built_in">ns</span></span> parklane-cai-fan) <span class="hljs-comment">; sets everything in the file to be within the parklane-cai-fan namespace</span>
</code></pre>
<h2>Variables</h2>
<pre><code class="language-clj"><span class="hljs-comment">; --------- VARIABLE ----------</span>
    <span class="hljs-comment">; def =&gt; creates a global variable and assigns a corresponding value</span>
    <span class="hljs-comment">; let =&gt; creates a local variable lexically scoped to the current scope of () brackets and assigns a corresponding value, and has an implicit return of the last expression</span>

(<span class="hljs-keyword">def</span> <span class="hljs-title">an-int</span> <span class="hljs-number">1</span>) <span class="hljs-comment">; global-binding of a variable (global variable)</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">a-float</span> <span class="hljs-number">2.2</span>) <span class="hljs-comment">; global-binding of a variable (global variable)</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">a-string</span> <span class="hljs-string">&quot;cereal chicken&quot;</span>) <span class="hljs-comment">; global-binding of a variable (global variable)</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">a-bool</span> <span class="hljs-literal">true</span>) <span class="hljs-comment">; global-binding of a variable (global variable)</span>

(<span class="hljs-name"><span class="hljs-built_in">let</span></span> [a <span class="hljs-number">1</span> b <span class="hljs-number">2</span>]
  (<span class="hljs-name"><span class="hljs-built_in">&gt;</span></span> a b)) <span class="hljs-comment">; this creates local bindings, then evaluates to false from the last expression</span>
</code></pre>
<h2>Types</h2>
<pre><code class="language-clj"><span class="hljs-comment">; ---------- TYPE -----------</span>
    <span class="hljs-comment">; integer </span>
    <span class="hljs-comment">; float =&gt; floating point numbers</span>
    <span class="hljs-comment">; string =&gt; double quotation marks</span>
    <span class="hljs-comment">; boolean =&gt; true, false</span>
    <span class="hljs-comment">; nil =&gt; special value to represent the absence of data</span>
    <span class="hljs-comment">; keyword =&gt; strings with efficiency bonuses, declared with : colon in front of keyword</span>

<span class="hljs-number">1</span> <span class="hljs-comment">; integer</span>
<span class="hljs-number">1.23</span> <span class="hljs-comment">; float</span>
<span class="hljs-string">&quot;watermelon&quot;</span> <span class="hljs-comment">; string</span>
<span class="hljs-literal">false</span> <span class="hljs-comment">; boolean</span>
<span class="hljs-literal">nil</span> <span class="hljs-comment">; special value nil</span>
<span class="hljs-symbol">:a</span> <span class="hljs-comment">; keyword</span>

<span class="hljs-comment">; USEFUL TYPE FUNCTIONS</span>
    <span class="hljs-comment">; quote =&gt; prevents literal data from being evaluated, has a shorthand &#x27;</span>
    <span class="hljs-comment">; &#x27; =&gt; prevents literal data from being evaluated, the shorthand for quote</span>
    <span class="hljs-comment">; eval =&gt; evaluates a literal list</span>

(<span class="hljs-name"><span class="hljs-built_in">quote</span></span> (<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>)) <span class="hljs-comment">; this literal list of data won&#x27;t be evaluated and will evaluate to value of (+ 1 2)</span>
&#x27;(<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>) <span class="hljs-comment">; this literal list of data won&#x27;t be evaluated, evaluates to value of (+ 1 2)</span>
(<span class="hljs-name"><span class="hljs-built_in">eval</span></span> &#x27;(<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>)) <span class="hljs-comment">; this forces an evaluation on a quoted list, thus evaluating this to the value of 7</span>
</code></pre>
<h2>Operators</h2>
<pre><code class="language-clj"><span class="hljs-comment">; ---------- OPERATOR ----------</span>

<span class="hljs-comment">; ARITHMETIC OPERATORS</span>
    <span class="hljs-comment">; + =&gt; addition</span>
    <span class="hljs-comment">; - =&gt; subtraction</span>
    <span class="hljs-comment">; * =&gt; multiplication</span>
    <span class="hljs-comment">; / =&gt; division</span>
    <span class="hljs-comment">; mod =&gt; modulo</span>

<span class="hljs-comment">; LOGICAL OPERATORS</span>
    <span class="hljs-comment">; and</span>
    <span class="hljs-comment">; or</span>
    <span class="hljs-comment">; not</span>

<span class="hljs-comment">; COMPARISON OPERATORS</span>
    <span class="hljs-comment">; = =&gt; partial equality check for value</span>
    <span class="hljs-comment">; not= =&gt; partial inequality check for value</span>
    <span class="hljs-comment">; == =&gt; complete equality check for type and value</span>
    <span class="hljs-comment">; not== =&gt; complete inequality check for type and value</span>
    <span class="hljs-comment">; &lt; &gt; &lt;= &gt;= for other comparison checks</span>

(<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>) <span class="hljs-comment">; evaluates to 2</span>
(<span class="hljs-name"><span class="hljs-built_in">-</span></span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>) <span class="hljs-comment">; evaluates to 1</span>
(<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>) <span class="hljs-comment">; evaluates to 2</span>
(/ <span class="hljs-number">2</span> <span class="hljs-number">1</span>) <span class="hljs-comment">; evaluates to 2</span>
(<span class="hljs-name"><span class="hljs-built_in">mod</span></span> <span class="hljs-number">5</span> <span class="hljs-number">2</span>) <span class="hljs-comment">; evaluates to 1</span>

(<span class="hljs-name"><span class="hljs-built_in">not</span></span> <span class="hljs-literal">true</span>) <span class="hljs-comment">; evaluates to false</span>
(<span class="hljs-name">false</span> and <span class="hljs-literal">true</span>) <span class="hljs-comment">; evaluates to false</span>
(<span class="hljs-name">false</span> or <span class="hljs-literal">true</span>) <span class="hljs-comment">; evaluates to true</span>

(<span class="hljs-name"><span class="hljs-built_in">=</span></span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>) <span class="hljs-comment">; evaluates to true</span>
(<span class="hljs-name"><span class="hljs-built_in">=</span></span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>) <span class="hljs-comment">; evaluates to false</span>
(<span class="hljs-name"><span class="hljs-built_in">=</span></span> <span class="hljs-number">1</span> <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-comment">; evaluates to true</span>
(<span class="hljs-name"><span class="hljs-built_in">==</span></span> <span class="hljs-number">1</span> <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-comment">; evaluates to false</span>
</code></pre>
<h2>Control structures</h2>
<pre><code class="language-clj"><span class="hljs-comment">; ---------- CONTROL STRUCTURE ----------</span>

<span class="hljs-comment">; CONDITIONAL CHECKS</span>
    <span class="hljs-comment">; if =&gt; operates as you&#x27;d expect, called as a function like everything else in clojure</span>
        <span class="hljs-comment">; general syntax is (if {CONDITIONAL CHECK} {THEN EXPRESSION} {ELSE EXPRESSION})</span>
    <span class="hljs-comment">; cond =&gt; evaluates each specified predicate in order and evaluates to the value of the first true condition, equivalent to an if elseif else chain in other languages</span>
        <span class="hljs-comment">; :else =&gt; added as the final else case in a cond chain</span>
    <span class="hljs-comment">; case =&gt; equivalent to match-case chain in other languages</span>
        <span class="hljs-comment">; :else =&gt; added as the final default case in a case chain</span>

(<span class="hljs-keyword">def</span> <span class="hljs-title">x</span> <span class="hljs-number">10</span>)
(<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">&gt;</span></span> x <span class="hljs-number">5</span>)
  <span class="hljs-string">&quot;Greater than 5&quot;</span>
  <span class="hljs-string">&quot;Less than or equal to 5&quot;</span>) <span class="hljs-comment">; this evaluates to &quot;Greater than 5&quot;</span>

(<span class="hljs-keyword">def</span> <span class="hljs-title">y</span> <span class="hljs-number">10</span>)
(<span class="hljs-name"><span class="hljs-built_in">cond</span></span>
  (<span class="hljs-name"><span class="hljs-built_in">&gt;</span></span> y <span class="hljs-number">15</span>) <span class="hljs-string">&quot;Greater than 15&quot;</span>
  (<span class="hljs-name"><span class="hljs-built_in">&gt;</span></span> y <span class="hljs-number">10</span>) <span class="hljs-string">&quot;Greater than 10&quot;</span>
  <span class="hljs-symbol">:else</span> <span class="hljs-string">&quot;10 or less&quot;</span>) <span class="hljs-comment">; this evaluates to &quot;10 or less&quot;</span>

(<span class="hljs-keyword">def</span> <span class="hljs-title">day-of-week</span> <span class="hljs-number">3</span>)
(<span class="hljs-name"><span class="hljs-built_in">case</span></span> day-of-week
  <span class="hljs-number">1</span> <span class="hljs-string">&quot;Sunday&quot;</span>
  <span class="hljs-number">2</span> <span class="hljs-string">&quot;Monday&quot;</span>
  <span class="hljs-number">3</span> <span class="hljs-string">&quot;Tuesday&quot;</span>
  <span class="hljs-symbol">:else</span> <span class="hljs-string">&quot;Unknown day&quot;</span>) <span class="hljs-comment">; this evaluates to &quot;Tuesday&quot;</span>

<span class="hljs-comment">; LOOPS</span>
    <span class="hljs-comment">; for most iterative solutions, clojure&#x27;s functional programming constructs are encouraged instead of loops (map, reduce, filter)</span>
    <span class="hljs-comment">; loop =&gt; creates and defines the lexical scope of a loop, used alongside recur</span>
    <span class="hljs-comment">; recur =&gt; indicates to initiate another iteration of the current loop with recursion</span>
    <span class="hljs-comment">; doseq =&gt; creates a loop that iterates over a specified structure, achieved without explicit recursion</span>

(<span class="hljs-keyword">defn</span> <span class="hljs-title">countdown-recur</span> [n]
  (<span class="hljs-name"><span class="hljs-built_in">loop</span></span> [i n]
    (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">&lt;=</span></span> i <span class="hljs-number">0</span>)
      <span class="hljs-string">&quot;Blast off!&quot;</span>
      (<span class="hljs-name"><span class="hljs-built_in">do</span></span>
        (<span class="hljs-name">println</span> i)
        (<span class="hljs-name"><span class="hljs-built_in">recur</span></span> (<span class="hljs-name"><span class="hljs-built_in">dec</span></span> i)))))) <span class="hljs-comment">; function definition for a function that contains a recursive loop which counts down from n to 0, then prints blast off, here recur is used to decrement i by 1 and initiate another iteration of the loop</span>

(<span class="hljs-keyword">defn</span> <span class="hljs-title">countdown-iter</span> [n]
  (<span class="hljs-name"><span class="hljs-built_in">doseq</span></span> [i (<span class="hljs-name"><span class="hljs-built_in">range</span></span> n <span class="hljs-number">0</span> <span class="hljs-number">-1</span>)]
    (<span class="hljs-name">println</span> i))
  (<span class="hljs-name">println</span> <span class="hljs-string">&quot;Blast off!&quot;</span>)) <span class="hljs-comment">; function defintion for a function that achieves the same thing as the above function, but does it using doseq to create a loop that does not rely on explicit recursion but instead iterates over a vector created using the range function</span>
</code></pre>
<h2>Data structures</h2>
<pre><code class="language-clj"><span class="hljs-comment">; ---------- DATA STRUCTURE -----------</span>
    <span class="hljs-comment">; collection =&gt; groups of data (lists, vectors)</span>
    <span class="hljs-comment">; sequence =&gt; abstract descriptions of lists of data (lists)</span>

<span class="hljs-comment">; LIST</span>
    <span class="hljs-comment">; linked-list data structure</span>
    <span class="hljs-comment">; declared with () brackets, must be quoted as a literal with &#x27; to prevent clojure from thinking its a function</span>
    <span class="hljs-comment">; list =&gt; creates a list literal, an alternative to declaring a list literal with &#x27;</span>
    <span class="hljs-comment">; range =&gt; creates a list of range 0 to a specified length, no specification results in an infinite series</span>
    <span class="hljs-comment">; take =&gt; retrieve a slice of a list based on length from the front</span>
    <span class="hljs-comment">; cons =&gt; insert an item to the start of a list</span>
    <span class="hljs-comment">; conj =&gt; inserts an item to the start of a list (the most efficient method of insertion for a list)</span>
    <span class="hljs-comment">; concat =&gt; concatenates collections (both lists and vectors) together and returns them as a list</span>
    <span class="hljs-comment">; map =&gt; apply a specified function on every item within the list</span>
    <span class="hljs-comment">; filter =&gt; apply a specified function on every item within the list and keep those that meet the specified function predicate</span>
    <span class="hljs-comment">; reduce =&gt; aggregate multiple items within a list to a single result by applying the specified function to each item and accumulating the result, can take an initial argument value also</span>

(<span class="hljs-name"><span class="hljs-built_in">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) <span class="hljs-comment">; creates a list literal of value (1 2 3), the equivalent of &#x27;(1 2 3)</span>
(<span class="hljs-name"><span class="hljs-built_in">range</span></span>) <span class="hljs-comment">; creates an infinite series of value (0 1 2 3 4 ...)</span>
(<span class="hljs-name"><span class="hljs-built_in">range</span></span> <span class="hljs-number">4</span>) <span class="hljs-comment">; creates a list of value (0 1 2 3) with length 4</span>
(<span class="hljs-name"><span class="hljs-built_in">take</span></span> <span class="hljs-number">4</span> (<span class="hljs-name"><span class="hljs-built_in">range</span></span>)) <span class="hljs-comment">; retrieves a slice of length 4 from an infinite list, evaluating to (0 1 2 3)</span>
(<span class="hljs-name"><span class="hljs-built_in">cons</span></span> <span class="hljs-number">4</span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)) <span class="hljs-comment">; this evaluates to (4 1 2 3)</span>
(<span class="hljs-name"><span class="hljs-built_in">conj</span></span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) <span class="hljs-number">4</span>) <span class="hljs-comment">; this evaluates to (4 1 2 3) also by inserting the element at the start of the list</span>
(<span class="hljs-name"><span class="hljs-built_in">concat</span></span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span>) &#x27;(<span class="hljs-number">3</span> <span class="hljs-number">4</span>)) <span class="hljs-comment">; this evaluates to (1 2 3 4)</span>
(<span class="hljs-name"><span class="hljs-built_in">concat</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span>] &#x27;(<span class="hljs-number">3</span> <span class="hljs-number">4</span>)) <span class="hljs-comment">; this also evaluates to (1 2 3 4)</span>
(<span class="hljs-name"><span class="hljs-built_in">map</span></span> inc &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)) <span class="hljs-comment">; this evaluates to (2 3 4)</span>
(<span class="hljs-name"><span class="hljs-built_in">filter</span></span> even? &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)) <span class="hljs-comment">; this evaluates to (2)</span>
(<span class="hljs-name"><span class="hljs-built_in">reduce</span></span> + &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>)) <span class="hljs-comment">; this evaluates to 10</span>
(<span class="hljs-name"><span class="hljs-built_in">reduce</span></span> conj [] &#x27;(<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>)) <span class="hljs-comment">; this evaluates to [3 2 1]</span>

<span class="hljs-comment">; VECTOR</span>
    <span class="hljs-comment">; array-backed vector</span>
    <span class="hljs-comment">; declared with [] square brackets</span>
    <span class="hljs-comment">; cons =&gt; insert an item to the start of a vector</span>
    <span class="hljs-comment">; conj =&gt; appends an item to the end of a vector (the most efficient method of insertion for a vector)</span>
    <span class="hljs-comment">; concat =&gt; concatenates collections (both lists and vectors) together and returns them as a list</span>
    <span class="hljs-comment">; map =&gt; apply a specified function on every item within the vector</span>
    <span class="hljs-comment">; filter =&gt; apply a specified function on every item within the vector and keep those that meet the specified function predicate</span>
    <span class="hljs-comment">; reduce =&gt; aggregate multiple items within a vector to a single result by applying the specified function to each item and accumulating the result, can take an initial argument value also</span>

[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] <span class="hljs-comment">; creates a vector literal of value [1 2 3]</span>
(<span class="hljs-name"><span class="hljs-built_in">cons</span></span> <span class="hljs-number">4</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]) <span class="hljs-comment">; this evaluates to (4 1 2 3)</span>
(<span class="hljs-name"><span class="hljs-built_in">conj</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>] <span class="hljs-number">4</span>) <span class="hljs-comment">; this evaluates to [1 2 3 4] by appending the element to the end of the vector</span>
(<span class="hljs-name"><span class="hljs-built_in">concat</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span>] [<span class="hljs-number">3</span> <span class="hljs-number">4</span>]) <span class="hljs-comment">; this evaluates to (1 2 3 4)</span>
(<span class="hljs-name"><span class="hljs-built_in">concat</span></span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span>] &#x27;(<span class="hljs-number">3</span> <span class="hljs-number">4</span>)) <span class="hljs-comment">; this also evaluates to (1 2 3 4)</span>
(<span class="hljs-name"><span class="hljs-built_in">map</span></span> inc [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]) <span class="hljs-comment">; this evaluates to (2 3 4)</span>
(<span class="hljs-name"><span class="hljs-built_in">filter</span></span> even? [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]) <span class="hljs-comment">; this evaluates to (2)</span>
(<span class="hljs-name"><span class="hljs-built_in">reduce</span></span> + [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]) <span class="hljs-comment">; this evaluates to 10</span>
(<span class="hljs-name"><span class="hljs-built_in">reduce</span></span> conj [] [<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>]) <span class="hljs-comment">; this evaluates to [3 2 1]</span>

<span class="hljs-comment">; ARRAY MAP</span>
    <span class="hljs-comment">; declared with {} curly braces</span>
    <span class="hljs-comment">; assoc =&gt; adds new key-value pairs to an array map and returns the new array map</span>
    <span class="hljs-comment">; dissoc =&gt; removes key-value pairs from an array map and returns the new array map</span>
    <span class="hljs-comment">; retains key-value pair order, slower lookups than hash maps</span>
    <span class="hljs-comment">; keys can be any hashable type, but keywords are used as keys by convention</span>
    <span class="hljs-comment">; array maps are automatically converted to hash maps when their size gets big enough</span>
    <span class="hljs-comment">; retrieve a value from its key by calling the array map as a function, retrieving an absent key returns nil</span>

{<span class="hljs-symbol">:a</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:b</span> <span class="hljs-number">2</span> <span class="hljs-symbol">:c</span> <span class="hljs-number">3</span>} <span class="hljs-comment">; an array map literal</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">watermelon-array-map</span> {<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-number">4</span> <span class="hljs-string">&quot;cd&quot;</span> <span class="hljs-number">10</span> <span class="hljs-string">&quot;ef&quot;</span> <span class="hljs-number">100</span>}) <span class="hljs-comment">; creates an array map and assigns it to a variable</span>
(<span class="hljs-name">watermelon-array-map</span> <span class="hljs-string">&quot;cd&quot;</span>) <span class="hljs-comment">; evaluates to the integer value 10</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">new-watermelon-array-map</span> (<span class="hljs-name"><span class="hljs-built_in">assoc</span></span> watermelon-array-map <span class="hljs-string">&quot;watermelon-pie&quot;</span> <span class="hljs-number">2000</span>)) <span class="hljs-comment">; adds a new key-value pair to watermelon-array-map, then assigns the new array map value to the variable new-watermelon-array-map since clojure types are immutable</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">edited-watermelon-array-map</span> (<span class="hljs-name"><span class="hljs-built_in">dissoc</span></span> new-watermelon-array-map <span class="hljs-string">&quot;a&quot;</span> <span class="hljs-string">&quot;cd&quot;</span>)) <span class="hljs-comment">; removes the key-value pairs of key &quot;a&quot; and &quot;cd&quot; from the new-watermelon-array-map and returns the new array map, then assigns that value to the variable edited-watermelon-array-map since clojure types are immutable</span>

<span class="hljs-comment">; HASH MAP</span>
    <span class="hljs-comment">; hash-map =&gt; creates a hash map literal</span>
    <span class="hljs-comment">; assoc =&gt; adds new key-value pairs to a hash map and returns the new hash map</span>
    <span class="hljs-comment">; dissoc =&gt; removes key-value pairs from a hash map and returns the new hash map</span>
    <span class="hljs-comment">; does not retain key-value pair order, faster lookups than array maps</span>
    <span class="hljs-comment">; keys can be any hashable type, but keywords are used as keys by convention</span>
    <span class="hljs-comment">; retrieve a value from its key by calling the hash map as a function, retrieving an absent key returns nil</span>

(<span class="hljs-name"><span class="hljs-built_in">hash-map</span></span> <span class="hljs-symbol">:a</span> <span class="hljs-number">1</span> <span class="hljs-symbol">:b</span> <span class="hljs-number">2</span> <span class="hljs-symbol">:c</span> <span class="hljs-number">4</span>) <span class="hljs-comment">; a hash map literal</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">apple-hash-map</span> (<span class="hljs-name"><span class="hljs-built_in">hash-map</span></span> <span class="hljs-symbol">:z</span> <span class="hljs-number">100.00</span> <span class="hljs-symbol">:in</span> <span class="hljs-number">6</span> <span class="hljs-symbol">:kl</span> <span class="hljs-number">2</span>)) <span class="hljs-comment">; creates a hash map and assigns it to a variable</span>
(<span class="hljs-name">apple-hash-map</span> <span class="hljs-symbol">:z</span>) <span class="hljs-comment">; evaluates to the float value of 100.00</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">new-apple-hash-map</span> (<span class="hljs-name"><span class="hljs-built_in">assoc</span></span> apple-hash-map <span class="hljs-symbol">:apple-pie</span> <span class="hljs-number">10</span>)) <span class="hljs-comment">; adds a new key-value pair to apple-hash-map, then assigns the new hash map value to the variable new-apple-hash-map since clojure types are immutable</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">edited-apple-hash-map</span> (<span class="hljs-name"><span class="hljs-built_in">dissoc</span></span> new-apple-hash-map <span class="hljs-symbol">:z</span> <span class="hljs-symbol">:kl</span>)) <span class="hljs-comment">; removes the key-value pairs of key :z and :kl from new-apple-hash-map and returns the new hash map, then assigns that value to the variable edited-apple-hash-map since clojure types are immutable</span>

<span class="hljs-comment">; SET</span>
    <span class="hljs-comment">; declared with #{} </span>
    <span class="hljs-comment">; set =&gt; creates a set, alongside [] square brackets</span>
    <span class="hljs-comment">; conj =&gt; appends a specified member to the set</span>
    <span class="hljs-comment">; disj =&gt; removes a member from a set by value</span>
    <span class="hljs-comment">; test for set members by calling the set as a function</span>
    <span class="hljs-comment">; similar to sets in other languages, with a range of functions for operation (see clojure.sets namespace)</span>

#{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-comment">; creates a set literal</span>
(<span class="hljs-name">set</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]) <span class="hljs-comment">; also creates a set literal which evaluates to the value #{1 2 3 4}</span>
(<span class="hljs-name"><span class="hljs-built_in">conj</span></span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">4</span>) <span class="hljs-comment">; this evaluates to #{1 2 3 4}</span>
(<span class="hljs-name"><span class="hljs-built_in">disj</span></span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">1</span>) <span class="hljs-comment">; this evaluates to #{2 3}</span>
(#{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">1</span>) <span class="hljs-comment">; this evaluates to 1, which evaluates to boolean true</span>
(#{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} <span class="hljs-number">4</span>) <span class="hljs-comment">; this evaluates to nil, which evaluates to boolean false</span>
</code></pre>
<h2>Functions</h2>
<pre><code class="language-clj"><span class="hljs-comment">; ---------- FUNCTION -----------</span>
    <span class="hljs-comment">; functions have implicit return on their last statement</span>
    <span class="hljs-comment">; functions can take multiple kinds of arguments and evaluate differently, just specify them with separate [] square brackets and () brackets</span>
    <span class="hljs-comment">; fn =&gt; creates a new anonymous function, where [] square brackets list function arguments</span>
        <span class="hljs-comment">; anonymous functions are called with (()) double brackets</span>
    <span class="hljs-comment">; def =&gt; assigns an anonymous function to a variable to create a named function</span>
    <span class="hljs-comment">; defn =&gt; creates a named function, where [] square brackets list function arguments</span>
    <span class="hljs-comment">; &amp; =&gt; recieves extra arguments and packs them in a list, can be mixed with normal arguments</span>

<span class="hljs-comment">; ANONYMOUS FUNCTIONS</span>

(<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [] <span class="hljs-string">&quot;Hello World&quot;</span>) <span class="hljs-comment">; evaluates to fn </span>
((<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [] <span class="hljs-string">&quot;Shit ass&quot;</span>)) <span class="hljs-comment">; calls the anonymous function, evaluating to the string &quot;Shit ass&quot;</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">hello-world-ass</span> (<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [] <span class="hljs-string">&quot;Hello World Ass&quot;</span>)) <span class="hljs-comment">; creates the anonymous function which returns the string &quot;Hello World Ass&quot; then assigns it to the variable hello-world-ass to make it a named function</span>
(<span class="hljs-name">hello-world-ass</span>) <span class="hljs-comment">; this calls the named function, evaluating to the string &quot;Hello World Ass&quot;</span>

<span class="hljs-comment">; NAMED FUNCTIONS</span>

(<span class="hljs-keyword">defn</span> <span class="hljs-title">watermelon</span> [] <span class="hljs-string">&quot;watermelon&quot;</span>) <span class="hljs-comment">; creates a named function watermelon which evaluates to the string value &quot;watermelon&quot;</span>
(<span class="hljs-name">watermelon</span>) <span class="hljs-comment">; calls the specified function, evaluating to the string value &quot;watermelon&quot;</span>

(<span class="hljs-keyword">defn</span> <span class="hljs-title">hello</span> [name]
  (<span class="hljs-name"><span class="hljs-built_in">str</span></span> <span class="hljs-string">&quot;Hello &quot;</span> name)) <span class="hljs-comment">; another function definition</span>
(<span class="hljs-name">hello</span> <span class="hljs-string">&quot;Steve&quot;</span>) <span class="hljs-comment">; calls the specified function, evaluating to string value &quot;Hello Steve&quot;</span>

<span class="hljs-comment">; MULTI-VARIADIC FUNCTIONS</span>

(<span class="hljs-keyword">defn</span> <span class="hljs-title">hello-flexible</span>
  ([] <span class="hljs-string">&quot;Hello World&quot;</span>)
  ([name] (<span class="hljs-name"><span class="hljs-built_in">str</span></span> <span class="hljs-string">&quot;Hello &quot;</span> name))) <span class="hljs-comment">; a multi-variadic function definition that can take different arguments and evaluates differently based on arguments provided</span>
(<span class="hljs-name">hello-flexible</span> <span class="hljs-string">&quot;Jake&quot;</span>) <span class="hljs-comment">; this will evaluate to &quot;Hello Jake&quot;</span>
(<span class="hljs-name">hello-flexible</span>) <span class="hljs-comment">; this will evaluate &quot;Hello World&quot;</span>

<span class="hljs-comment">; VARIABLE NUMBER OF FUNCTION ARGUMENTS</span>

(<span class="hljs-keyword">defn</span> <span class="hljs-title">count-args</span> [&amp; achoo]
  (<span class="hljs-name"><span class="hljs-built_in">str</span></span> <span class="hljs-string">&quot;You passed &quot;</span> (<span class="hljs-name"><span class="hljs-built_in">count</span></span> achoo) <span class="hljs-string">&quot; arguments: &quot;</span> achoo)) <span class="hljs-comment">; function definition for a function that accepts multiple arguments under the argument name achoo</span>
(<span class="hljs-name">count-args</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) <span class="hljs-comment">; this evaluates to the string value of &quot;You passed 3 args: (1 2 3)&quot;</span>

(<span class="hljs-keyword">defn</span> <span class="hljs-title">hello-count</span> [name &amp; orange]
  (<span class="hljs-name"><span class="hljs-built_in">str</span></span> <span class="hljs-string">&quot;Hello &quot;</span> name <span class="hljs-string">&quot;, you passed &quot;</span> (<span class="hljs-name"><span class="hljs-built_in">count</span></span> orange) <span class="hljs-string">&quot; extra arguments&quot;</span>)) <span class="hljs-comment">; function definition for a function that mixes a variable number of arguments with other named arguments</span>
(<span class="hljs-name">hello-count</span> <span class="hljs-string">&quot;Finn&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) <span class="hljs-comment">; this evaluates to the string value of &quot;Hello Finn, you passed 3 extra args&quot;</span>
</code></pre>
<h2>Modules</h2>
<pre><code class="language-clj"><span class="hljs-comment">; ----------- MODULE -----------</span>
    <span class="hljs-comment">; use =&gt; brings all functions from the specified module into the current global scope, does not requires namespace qualification</span>
    <span class="hljs-comment">; require =&gt; imports a module and its functions but requires namespace qualification when calling module functions</span>
    <span class="hljs-comment">; ns =&gt; namespaces can be used to require a module as well, doing so means we don&#x27;t need to quote the module </span>

(<span class="hljs-name"><span class="hljs-built_in">use</span></span> &#x27;clojure.set) <span class="hljs-comment">; brings all set functions within the global scope</span>
(<span class="hljs-name"><span class="hljs-built_in">intersection</span></span> #{<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>} #{<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>}) <span class="hljs-comment">; we can now call set functions, this evaluates to #{2 3}</span>

(<span class="hljs-name">require</span> &#x27;clojure.string) <span class="hljs-comment">; imports the clojure string module within the global scope but namespace qualfiication required when calling string functions</span>
(<span class="hljs-name">clojure.string/blank?</span> <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">; we can now call string functions but must reference the clojure.string namespace, this evaluates to true</span>

(<span class="hljs-name"><span class="hljs-built_in">ns</span></span> test
  (<span class="hljs-symbol">:require</span>
    [clojure.string <span class="hljs-symbol">:as</span> str]
    [clojure.set <span class="hljs-symbol">:as</span> set])) <span class="hljs-comment">; this has the same effect as above and gives the modules shorter names, note there is no need to quote &#x27; the module here</span>
</code></pre>
<h2>More on</h2>
<ul>
<li>-&gt;</li>
<li>-&gt;&gt;</li>
<li>as-&gt;</li>
<li><a href="https://clojure.org/reference/refs">clojure STM</a></li>
<li><a href="https://clojure.org/reference/libs">clojure java standard library</a></li>
<li><a href="https://learnxinyminutes.com/docs/clojure-macros/">learn clojure macros in y minutes</a></li>
<li><a href="https://4clojure.oxal.org/">clojure exercises</a></li>
<li><a href="https://clojuredocs.org/quickref">clojure quick reference</a></li>
<li><a href="https://learnxinyminutes.com/docs/clojure/">learn clojure in y minutes</a></li>
<li><a href="https://clojure-doc.org/">clojure documentation</a></li>
</ul>
