<h1><code>Gleam</code></h1>
<p>Functional language that transpiles to BEAM (Erlang's Virtual Machine) bytecode to build scalable, maintainable systems.</p>
<h2>Comments</h2>
<pre><code class="language-gleam">// ----- COMMENT -----

// this is a single-line comment

/*
this is a 
multi-line comment
in Gleam
*/
</code></pre>
<h2>Printing</h2>
<pre><code class="language-gleam">// ----- PRINTING -----
    // io.print() =&gt; receives a string argument that it then prints to the stdout without a newline being included 
    // io.println() =&gt; receives a string argument that it then prints to the stdout, automatically including a newline

io.print(&quot;this does not include a newline and one must be explicitly specified if desired\n&quot;)
io.println(&quot;this automatically includes a newline&quot;)
</code></pre>
<h2>Quickstart</h2>
<pre><code class="language-gleam">// ----- QUICKSTART -----
    // strong statically-typed language
    // emphasizes safety, performance and Erlang's concurrency model
    // all execution code within your Gleam file runs from the main function fn main(), similar to all other C-style languages
    // notably differing from C-style traditions, Gleam is not a semicolon-delimited language
    // import =&gt; brings the required libraries into the local scope of the present Gleam file, note that Gleam has full access to all existing Erlang libraries and frameworks
    // : =&gt; declares the datatype of a given constant and variable, allowing for type declaration
    // let =&gt; declares a variable with a mutable value that can be reassigned after declaration and initialisation
    // const =&gt; declares a constant with an immutable value that cannot be reassigned after declaration and initialisation

import gleam/io

pub fn main() { // main function
    let name = &quot;gooked&quot; // string variable
    const AGE: Int = 30 // integer constant
    io.println(&quot;hello &quot; ++ name ++ &quot; and welcome to the world from a &quot; ++ to_string(AGE) ++ &quot; years old Gleam program&quot;)
}
</code></pre>
<h2>Types</h2>
<pre><code class="language-gleam">// ----- TYPE -----
    // Int =&gt; stores signed and unsigned integer number values
    // Float =&gt; stores signed and unsigned floating point number values
    // Bool =&gt; true, false
    // Atom =&gt; stores a constant value identified by its name where atoms are declared with a : colon prefacing the atom value, the equivalent of atoms in Elixir, symbols in Ruby and keywords in Common Lisp and Clojure
    // String =&gt; stores a string value declared within &quot;&quot; double quotation marks, note that characters are handled as strings in Gleam
    // BitString =&gt; stores a sequence of bits or bytes mostly used to store binary data, declared within &lt;&lt;&gt;&gt; double angle brackets
</code></pre>
<h2>Operators</h2>
<pre><code class="language-gleam">// ----- OPERATOR -----

// --- ARITHMETIC OPERATOR ---

+ // addition
- // subtraction
* // multiplication
/ // division
% // modulo
^ // exponentiation

// --- COMPARISON OPERATOR ---

== // complete equality check for both value and type
!= // complete inequality check for both value and type
&gt; // comparison operator
&lt; // comparison operator
&gt;= // comparison operator
&lt;= // comparison operator

// --- LOGICAL OPERATOR ---

&amp;&amp; // logical and 
|| // logical or
! // logical not
</code></pre>
<h2>Control structures</h2>
<pre><code class="language-gleam">// ----- CONTROL STRUCTURE -----

// --- CONDITIONALS ---

// IF ELSE IF ELSE

let x = 10
if x &lt; 0 {
    io.println(&quot;x is negative&quot;)
} else if x == 0 {
    io.println(&quot;x is zero&quot;)
} else {
    io.println(&quot;x is positive&quot;)
}

// CASE -&gt; _
    // provides a degree of pattern-matching in Gleam similar to languages like Rust, the equivalent of switch case and match case constructs in other languages
    // heavily used in Gleam for completeness and literate, safe programming
    // -&gt; =&gt; specifies the relationship between a given predicate case condition and the logic that should execute if that condition is met
    // _ =&gt; specifies the logic for a default fall-through case where all other predicate case conditions are left unmet

let x = 3
case x {
    1 -&gt; io.println(&quot;One&quot;)
    2 -&gt; io.println(&quot;Two&quot;)
    3 -&gt; io.println(&quot;Three&quot;)
    _ -&gt; io.println(&quot;Other&quot;)
}

// --- LOOPS ---
    // since Gleam is a functional language, it carries over many hallmarks of the functional paradigm, including the absence of conventional loop constructs
    // instead, user-defined higher-order functions (and occasionally recursion) are used for traversal and iteration over iterable data structures

// HIGHER ORDER FUNCTIONS
    // the below are one way to implement some standard higher-order functions, note the express use of case -&gt; _ constructs
        // map =&gt; applies a specified function to each element of the iterable structure and returns the transformed structure
        // foreach =&gt; applies a specified function to each element of the iterable structure in place in memory and does not return anything
        // filter =&gt; filters each element of an iterable structure based off a specified predicate function 
        // reduce =&gt; reduces an iterable structure to a single value using a specified accumulator function by folding to the left
        // foldr =&gt; reduces an iterable structure to a single value using a specified accumulator function by folding to the right

pub fn map_list(lst: List(Int), f: fn(Int) -&gt; Int) -&gt; List(Int) {
    case lst {
        [] -&gt; []
        [head | tail] -&gt; [f(head) | map_list(tail, f)]
    }
}

pub fn for_each(lst: List(Int), f: fn(Int) -&gt; ()) {
    case lst {
        [] -&gt; ()
        [head | tail] -&gt; {
            f(head)
            for_each(tail, f)
        }
    }
}

pub fn filter_list(lst: List(Int), predicate: fn(Int) -&gt; Bool) -&gt; List(Int) {
    case lst {
        [] -&gt; []
        [head | tail] -&gt; if predicate(head) { [head | filter_list(tail, predicate)] } else { filter_list(tail, predicate) }
    }
}

pub fn reduce_list(lst: List(Int), f: fn(Int, Int) -&gt; Int, initial: Int) -&gt; Int {
    case lst {
        [] -&gt; initial
        [head | tail] -&gt; reduce_list(tail, f, f(initial, head))
    }
}

pub fn foldr_list(lst: List(Int), f: fn(Int, Int) -&gt; Int, initial: Int) -&gt; Int {
    case lst {
        [] -&gt; initial
        [head | tail] -&gt; f(head, foldr_list(tail, f, initial))
    }
}

// RECURSION
    // Gleam also allows for recursion to allow for more complex iteration over iterable structures

pub fn factorial(n: Int) -&gt; Int {
    case n {
        0 -&gt; 1 // base case
        _ -&gt; n * factorial(n - 1) // recursive case
    }
}
</code></pre>
<h2>Data structures</h2>
<pre><code class="language-gleam">// ----- DATA STRUCTURE -----
    // Tuple =&gt; fixed-size ordered collection of elements of multiple datatypes declared within () round brackets
    // List =&gt; dynamically-sized ordered collection of elements of the same datatype declared within [] straight brackets
    // Map =&gt; unordered collection of key-value pairs declared within %{} percentage sign and curly braces, the equivalent of dictionaries in Python and tables in Lua and PHP
    // Type =&gt; user-defined collection of comma-delimited named fields and their datatypes declared within {} curly braces, allowing for modelling of representative data in your Gleam program through type aliases, the equivalent of structs in Go and Rust

let anExampleTuple: (String, Int) = (&quot;Alice&quot;, 30)
let anExampleList: List(Int) = [1, 2, 3, 4, 5]
let anExampleMap: Map(String, String) = %{ &quot;red&quot; =&gt; &quot;#FF0000&quot;, &quot;green&quot; =&gt; &quot;#00FF00&quot;, &quot;blue&quot; =&gt; &quot;#0000FF&quot; }
type anExampleRecord = {
    name: String,
    age: Int
}
type coordinate = {
    X: String,
    Y: String
}
</code></pre>
<h2>Functions</h2>
<pre><code class="language-gleam">// ----- FUNCTION -----
    // similar to other functional languages, Gleam features implicit return of the last expression within a function, there is no explicit return keyword used traditionally in Gleam
    // fn &lt;functionName&gt; ( &lt;functionParameter(s)&gt; : &lt;functionParameterDatatype(s)&gt; ) -&gt; {returnDatatype(s)} { &lt;functionBodyDefinition&gt; } =&gt; declaration and definition of a named function
    // fn ( &lt;functonParameter(s)&gt; : &lt;functionParameterDatatype(s)&gt; ) -&gt; &lt;returnDatatype(s)&gt; { &lt;functionBodyDefinition&gt; } =&gt; declaration and definition of an anonymous function that is normally assigned to a named variable as seen below

fn greet(name: String) { // a named void function
    io.println(&quot;Hello, &quot; ++ name ++ &quot;!&quot;)
}
greet(&quot;Alice&quot;)

fn square(x: Int) -&gt; Int { // a named integer function
    x * x // implicit return of the last expression in the function
}

let double = fn(x: Int) -&gt; Int { x * 2 } // an anonymous function
</code></pre>
<h2>More on</h2>
<ul>
<li><a href="https://gleam.run/documentation/">gleam documentation</a></li>
<li><a href="https://learnxinyminutes.com/docs/gleam/">learn gleam in y minutes</a></li>
</ul>
