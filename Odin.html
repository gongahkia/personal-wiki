<h1><code>Odin</code></h1>
<p>Data-oriented language with low-level control.</p>
<h2>Comments</h2>
<pre><code class="language-odin">// ----- COMMENT -----

// this is a single-line comment

/*
this is a 
multi-line
comment
*/
</code></pre>
<h2>Printing</h2>
<pre><code class="language-odin">// ----- PRINTING -----
    // std.put() =&gt; prints the specified string argument to the stdout without including a newline by default

std.put(&quot;Hello, Odin!\n&quot;);
</code></pre>
<h2>Quickstart</h2>
<pre><code class="language-odin">// ----- QUICKSTART -----
    // all odin execution code is written within the main procedure
    // statically, strongly-typed
    // semicolon language
    // import =&gt; bring a specified library into the local scope of the given odin file

import std;

main :: proc() {
    std.put(&quot;this is my first odin program\n&quot;);
}
</code></pre>
<h2>Types</h2>
<pre><code class="language-odin">// ----- TYPE -----
    // int =&gt; integer value
    // float =&gt; floating point value
    // string =&gt; declared within &quot;&quot; double quotes, characters in odin are handled as one-character long strings
    // bool =&gt; true, false
    // () =&gt; empty tuple represents the absence of a datatype when a procedure does not return any value
</code></pre>
<h2>Operators</h2>
<pre><code class="language-odin">// ----- OPERATOR -----

// --- ARITHMETIC OPERATOR ---
    
+ // addition
- // subtraction
* // multiplication
/ // divison
% // modulo

// --- COMPARISON OPERATOR ---

== // complete equality, including type
!= // complete inequality, including type
&lt; // comparison operator
&gt; // comparison operator
&lt;= // comparison operator
&gt;= // comparison operator

// --- LOGICAL  OPERATOR ---

&amp;&amp; // and
|| // or
! // not
</code></pre>
<h2>Control structures</h2>
<pre><code class="language-odin">// ----- CONTROL STRUCTURE -----

// --- CONDITIONALS ---

// IF ELSE IF ELSE

isAdult(age: int) -&gt; void {
    if age &gt;= 18 {
        std.put(&quot;Adult\n&quot;);
    } else if age &gt;= 13 {
        std.put(&quot;Teenager\n&quot;);
    } else {
        std.put(&quot;Child\n&quot;);
    }
}

// CASE =&gt; _
    // equivalent of switch case construct in other programming languages
    // provides basic pattern-matching in odin
    // _ =&gt; represents the catch-all operator for all predicate conditional checks that fail and fall through, similar to Rust

getType(age: int) -&gt; string {
    case age {
        0 =&gt; return &quot;Baby&quot;;
        1 =&gt; return &quot;Toddler&quot;;
        2 =&gt; return &quot;Child&quot;;
        _ =&gt; return &quot;Unknown&quot;;
    }
}

// --- LOOPS ---

// FOR LOOPS
    // conventional C-style for loops with an explict start, end and step

for i: int = 0; i &lt;= 4; i += 1 {
    std.put(&quot;%d\n&quot;, i);
}

// FOREACH IN LOOPS
    // foreach loops allow for iteration over an iterable data structure in odin

numbers: []int = {1, 2, 3, 4, 5};
foreach number in numbers {
    std.put(&quot;%d\n&quot;, number);
}

// WHILE LOOPS

i: int = 0;
while i &lt; 5 {
    std.put(&quot;%d\n&quot;, i);
    i += 1;
}

// LOOP CONSTRUCT
    // loop =&gt; keyword can also be called directly to create an infinite loop similar to Rust, do note that the break condition must then be specified seperately

i: int = 0;
loop {
    std.put(&quot;%d\n&quot;, i);
    i += 1;
    if i &gt;= 5 { // break condition
        break; 
    }
}
</code></pre>
<h2>Data structures</h2>
<pre><code class="language-odin">// ----- DATA STRUCTURE -----
    // array =&gt; fixed-size ordered collection of elements of the same datatype
    // tuple =&gt; fixed-size ordered collection of elements of multiple datatypes
    // struct =&gt; composite datatype defined by its collection of user-defined comma-delimied fields, allowing for structured representation of data via type aliases similar to structs in Go and Typescript

anArray: [5] int = {1, 2, 3, 4, 5}; // array

aTuple: (string, int) = (&quot;Alice&quot;, 30); // tuple

type aStruct struct { // struct
    firstName: string,
    lastName: string,
}

type Coordinate struct { // another struct
    x: float,
    y: float,
};
</code></pre>
<h2>Functions and Procedures</h2>
<pre><code class="language-odin">// ----- FUNCTION -----
    // odin functions must return a value, similar to functions in ada
    // note that there are NO void functions in odin since the equivalent are written as procedures
    // &lt;functionName&gt; :: func(&lt;functionParameter(s)&gt;:&lt;functionDatatype(s)&gt;) -&gt; &lt;returnDataType&gt; =&gt; function definition for a named function in odin
    // functions are invoked with arguments using the same bracket syntax as many other programming languages

addNumbers :: func(a: int, b: int) -&gt; int {
    return a + b;
}
result: int = addNumbers(3, 5);

// ----- PROCEDURE ------
    // odin procedures do not return a value and are effectively void functions in other programming languages, similar to procedures in ada
    // &lt;procedureName&gt; :: proc(&lt;procedureParameter(s)&gt;:&lt;procedureDatatype(s)&gt;) =&gt; procedure definition for a named procedure in odin
    // procedures are invoked with arguments using the same bracket syntax as void functions in many other programming langauges

printMessage :: proc(message: string) {
    std.put(message); // Print the message
}
printMessage(&quot;Hello, Odin!&quot;);
</code></pre>
<h2>More on</h2>
<ul>
<li><a href="https://odin-lang.org/docs/">odin documentation</a></li>
</ul>
