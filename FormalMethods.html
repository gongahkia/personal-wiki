<h1><code>Formal methods</code></h1>
<ul>
<li>Mathematically <em>prove</em> or <em>disprove</em> the correctness of a system's design and behaviour according to formal specifications</li>
<li>Shows both the <em>presence</em> and <em>absence</em> of specific errors</li>
<li>For language design, software, hardware, algorithms</li>
</ul>
<h2>Quickstart</h2>
<p>Formal methods comprise the following 2 steps</p>
<ol>
<li>
<p><em><strong>Specification</strong></em></p>
<ul>
<li>Describe the desired properties (and behaviors) of a system</li>
<li>Written in formal languages
<ol>
<li>Tempora logic: specifies properties of systems that evolve over time</li>
<li>Algebraic specification: defines abstract datatypes and their operations</li>
</ol>
</li>
</ul>
</li>
<li>
<p><em><strong>Verification</strong></em></p>
<ol>
<li><strong>Model checking</strong>
<ul>
<li>System is modelled as a finite state model</li>
<li>Exhaustively explores whether user-specified properties <em>(expressed in temporal logic)</em> hold in every possible model state</li>
<li>Suitable for hardware verification and concurrent systems
<ol>
<li><a href="https://spinroot.com/spin/whatispin.html"><em>SPIN</em></a>: widely-used model checker for verifying the correctness of distributed software models</li>
<li><a href="https://nusmv.fbk.eu/"><em>NuSMV</em></a>: symbolic model checker supporting both BDD-based and SAT-based verification</li>
</ol>
</li>
<li>Pros
<ul>
<li>fully automated</li>
<li>able to handle concurrent systems</li>
<li>produces counterexamples when a given property does NOT hold</li>
</ul>
</li>
<li>Cons
<ul>
<li>suffers from State Space Explosion <em>(as a system grows, the number of states becomes unmanageably large)</em></li>
<li>limited to finite state systems</li>
</ul>
</li>
</ul>
</li>
<li><strong>Theorem proving</strong>
<ul>
<li>System is described in a formal language
<ol>
<li><a href="https://www.cs.umd.edu/~mvz/handouts/z-manual.pdf"><em>Z Notation</em></a>: used for describing the structure and behavior of software, particularly in safety-critical and high-assurance systems</li>
<li><a href="https://lamport.azurewebsites.net/tla/tla.html"><em>TLA+</em></a>: used for reasoning about concurrent and distributed systems, enabling precise descriptions of software system behaviors</li>
<li><a href="https://alloytools.org/"><em>Alloy</em></a>: lightweight modeling language for specifying complex structures and constraints in software systems</li>
<li><a href="https://www.overturetool.org/method/"><em>VDM</em></a>: Vienna Development Method is a formal method that provides a set of modeling languages for specifying and verifying software systems in the early stages of design</li>
<li><a href="https://www.copperpodip.com/post/vhdl-understanding-the-hardware-description-language"><em>VHDL</em></a>: VHSIC Hardware Description Language describes the behavior and structure of electronic systems, commonly used in the design and simulation of digital circuits and hardware components</li>
<li><a href="https://www.chipverify.com/tutorials/verilog"><em>Verilog</em></a>: hardware description language for modeling electronic systems at various levels of abstraction from gate level to system-level</li>
<li><a href="https://pvs.csl.sri.com/"><em>PVS</em></a>: Prototype Verification System used for formal specification and verification of algorithm in areas like automated reasoning</li>
<li><a href="https://coq.inria.fr/"><em>Coq</em></a>: formal language and proof assistant for developing and verifying mathematical proofs and algorithms, particularly in functional programming and theorem proving</li>
<li><a href="https://isabelle.in.tum.de/"><em>Isabelle</em></a>: generic proof assistant used for formal verification of both software and hardware systems</li>
</ol>
</li>
</ul>
</li>
<li><strong>Symbolic execution</strong>
<ul>
<li>Program is executed with symbolic inputs instead of literal values</li>
<li>Explores multiple execution paths simultaneously
<ol>
<li><a href="http://klee-se.org/releases/docs/v1.3.0/projects/"><em>KLEE</em></a>: symbolic execution tool that automatically generates high-coverage tests</li>
</ol>
</li>
<li>Pros
<ul>
<li>capable of analyzing ALL possible execution paths in a program</li>
<li>finds bugs in code WITHOUT requiring a full formal specification</li>
<li>checks for errors like division by zero or buffer overflows</li>
</ul>
</li>
<li>Cons
<ul>
<li>suffers from Path Explosion <em>(as program complexity grows, the number of paths quickly becomes unmanageably large)</em></li>
<li>limited to certain types of errors</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2>More on</h2>
<ul>
<li><a href="https://web.mit.edu/16.35/www/lecturenotes/FormalMethods.pdf">Formal Methods for Software Specification and Analysis: An Overview</a></li>
<li><a href="https://www.cs.ox.ac.uk/people/michael.wooldridge/teaching/soft-eng/lect06.pdf">Lecture 6: Introduction To Formal Methods</a> by Mike Wooldridge</li>
<li><a href="https://software.imdea.org/~mcarro/Material/Formal_Methods/Formal_Methods_Intro/formal-methods_3.pdf">A Short Introduction to Formal Methods</a> by Manuel Carro</li>
<li><a href="https://ptolemy.berkeley.edu/projects/embedded/research/vis/doc/VisUser/vis_user/node4.html">Introduction to Formal Verification</a> by The Donald O Pederson Center for Electronic Systems Design</li>
<li><a href="https://ahelwer.ca/post/2018-02-12-formal-verification/">Formal Verification, Casually Explained</a> by Andrew Helwer</li>
<li><a href="https://www.systemverilog.io/verification/gentle-introduction-to-formal-verification/">A Gentle Introduction to Formal Verification</a> by sv:io</li>
<li><a href="https://www.eeweb.com/introduction-to-formal-verification/">Introduction to Formal Verification</a> by EEWeb</li>
<li><a href="https://web.stanford.edu/class/archive/cs/cs103/cs103.1164/lectures/18/Small18.pdf">Context-Free Grammars</a> by Stanford University</li>
</ul>
