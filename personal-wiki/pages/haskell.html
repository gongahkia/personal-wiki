<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Haskell - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Gabriel Ong">
  <meta name="robots" content="index, follow">
  
  <meta property="og:title" content="Haskell | Gabriel Ong Wiki">
  <meta property="og:description" content="Wiki Note: Haskell - Gabriel Ong">
  <meta property="og:type" content="article">
  
  <meta property="og:image" content="https://gabrielongzm.com/asset/portrait/gong-2.png">
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Haskell | Gabriel Ong Wiki">
  <meta name="twitter:description" content="Wiki Note: Haskell - Gabriel Ong">
  
  <link rel="stylesheet" href="../../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">

  <style>.thin-space:after{content:"\2006"}</style>
  
  <style>pre { overflow-x: auto; max-width: 100%; }</style>

  <script src="../script.js" defer></script>
  <title>Haskell | Gabriel Ong Wiki</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>
  <main>
    <article class="overallArticleTags">
      
      <section class="note-header">
        <h2>Haskell</h2>
        <dl>
          <dt>File size</dt>
          <dd>92.6KB</dd>
          <dt>Lines of code</dt>
          <dd>528</dd>
        </dl>
      </section>
      <section class="note-content">
        <h1><code>Haskell</code></h1>
<p>Strict statically-typed functional language.</p>
<h2>Comments</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">-- ---------- COMMENT ----------</span>

<span class="c1">-- this is a single-line comment</span>

<span class="cm">{-</span>
<span class="cm">this </span>
<span class="cm">is a </span>
<span class="cm">multi-line</span>
<span class="cm">comment</span>
<span class="cm">-}</span>
</code></pre></div>

<h2>Printing</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">-- ---------- PRINT ----------</span>
<span class="w">    </span><span class="c1">-- putStrLn =&gt; prints a string to the stdout and appends a newline to the output</span>
<span class="w">    </span><span class="c1">-- putStr =&gt; prints a string to the stdout and does not include a newline</span>
<span class="w">    </span><span class="c1">-- print =&gt; prints a value of the Show typeclass to the stdout and appends a newline to the output</span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span><span class="w"> </span>
<span class="w">    </span><span class="n">putStrLn</span><span class="w"> </span><span class="s">&quot;this watermelon statement includes a newline at the end automatically&quot;</span>
<span class="w">    </span><span class="n">putStr</span><span class="w"> </span><span class="s">&quot;this pineapple statement does not include a newline at the end and must be specified explicitly by us</span><span class="se">\n</span><span class="s">&quot;</span>
</code></pre></div>

<h2>Quickstart</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">-- ---------- QUICKSTART ----------</span>
<span class="w">    </span><span class="c1">-- functional programming language with no side-effects, where everything is an expression that must evaluate to a value, including function definitions</span>
<span class="w">    </span><span class="c1">-- lazy evaluation, where functions will only be evaluated when called </span>
<span class="w">    </span><span class="c1">-- executable files require a main function to be called, which serves as the entry point for the program allowing for file IO (classified as a side-effect in pure functional languages)</span>

<span class="nf">main</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">main</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">putStr</span><span class="w"> </span><span class="s">&quot;fear and hunger truly is a game&quot;</span>
</code></pre></div>

<h2>Functions and Definitions</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">-- ---------- FUNCTION ----------</span>
<span class="w">    </span><span class="c1">-- as a functional language, Haskell revolves around functions, which are all expressions that evaluate to a value</span>
<span class="w">    </span><span class="c1">-- function defined with the syntax =&gt; {FUNCTION NAME} {FUNCTION PARAMETERS SPACE DELIMITED} = {FUNCTION BODY}</span>
<span class="w">    </span><span class="c1">-- functions called with the syntax =&gt; {FUNCTION NAME} {FUNCTION ARGUMENTS SPACE DELIMITED}</span>
<span class="w">    </span><span class="c1">-- function parameter and return type type signatures are optionally declared before function defintion, but encouraged for clear code</span>

<span class="nf">max</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="mi">101</span><span class="w"> </span><span class="c1">-- this evaluates to the Int value 101</span>

<span class="nf">doubleMe</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">doubleMe</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span>

<span class="nf">doubleUs</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">doubleUs</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">*</span><span class="mi">2</span>

<span class="c1">-- ---------- DEFINITION ----------</span>
<span class="w">    </span><span class="c1">-- as a functional language, Haskell has no concept of &#39;variables&#39; and every binding is immutable by default since modification of a value binding entails side-effects and instead, every value can be modified through a function expression which evaluates to a transformed return value</span>
<span class="w">    </span><span class="c1">-- these are called definitions, the equivalent of constant bindings in other languages</span>
<span class="w">    </span><span class="c1">-- where =&gt; adds a local definition to an existing definition</span>
<span class="w">    </span><span class="c1">-- let ... in =&gt; creates a local binding for expressions within a specified lexical scope</span>
<span class="w">        </span><span class="c1">-- both &#39;where&#39; and &#39;let ... in&#39; achieve the same purpose, just that their positional syntax is different when used</span>
<span class="w">        </span><span class="c1">-- note that functions can also be locally defined </span>
<span class="w">    </span><span class="c1">-- raw definition creates a global binding that can be accessed anywhere in the program</span>

<span class="nf">circleArea</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Double</span><span class="w"> </span><span class="c1">-- a function&#39;s type signature</span>

<span class="c1">-- this is a function defined with &#39;where&#39; to create local bindings that can only be accessed within the function circleArea</span>
<span class="nf">circleArea</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rsquare</span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mf">3.1415926</span><span class="w"> </span><span class="c1">-- pi is a local binding </span>
<span class="w">          </span><span class="n">rsquare</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="c1">-- rsquare is also a local binding </span>

<span class="c1">-- this is the same function if defined with &#39;let ... in&#39; that can only be accessed within the function circleArea</span>
<span class="nf">circleArea</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mf">3.1415926</span><span class="w"> </span><span class="c1">-- pi is a local binding here as well</span>
<span class="w">                   </span><span class="n">rsquare</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="c1">-- rsquare here is also a local binding</span>
<span class="w">               </span><span class="kr">in</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rsquare</span>

<span class="c1">-- using &#39;where&#39; </span>
<span class="nf">circleArea</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="n">r</span>
<span class="w">    </span><span class="kr">where</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mf">3.1415926</span>
<span class="w">          </span><span class="n">square</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="c1">-- square is a function locally defined within circleArea</span>

<span class="c1">-- using &#39;let .. in&#39;</span>
<span class="nf">circleArea</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mf">3.1415926</span>
<span class="w">                   </span><span class="n">square</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="c1">-- square here is also a local function defined within circleArea</span>
<span class="w">               </span><span class="kr">in</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="n">r</span>

<span class="nf">conanOBrien</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;It&#39;s a me, Conan O&#39;Brien!&quot;</span><span class="w"> </span><span class="c1">-- this creates a global binding</span>
</code></pre></div>

<h2>Types</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">-- ---------- TYPE ----------</span>
<span class="w">    </span><span class="c1">-- Int =&gt; bounded integer number with a minimum and maximum value</span>
<span class="w">    </span><span class="c1">-- Integer =&gt; unbounded integer number with no minimum and maximum value</span>
<span class="w">    </span><span class="c1">-- Float =&gt; single precision floating point number, 32 bits</span>
<span class="w">    </span><span class="c1">-- Double =&gt; double precision floating point number, 64 bits</span>
<span class="w">    </span><span class="c1">-- Bool =&gt; True, False</span>
<span class="w">    </span><span class="c1">-- Char =&gt; single quotation marks</span>
<span class="w">    </span><span class="c1">-- String =&gt; double quotation marks, a string list</span>
<span class="w">    </span><span class="c1">-- Maybe &lt;a&gt; =&gt; specifies a special nullable datatype where the value stored within the variable can either be of the specified type declared after the Maybe specifier or Nothing</span>
<span class="w">        </span><span class="c1">-- Nothing =&gt; special constant value representing the absence of a value</span>
<span class="w">        </span><span class="c1">-- Just &lt;literal value of a&gt; =&gt; special value that takes a parameter, the literal value of the non-null value stored within the Maybe &lt;a&gt; datatype</span>
<span class="w">    </span><span class="c1">-- Either &lt;a&gt; &lt;b&gt; =&gt; specifies a datatype that could one of two specified datatypes, referred to with Left and Right</span>
<span class="w">        </span><span class="c1">-- Left &lt;literal value of a&gt; =&gt; special value that takes a parameter, the literal value of the left-defined datatype a</span>
<span class="w">        </span><span class="c1">-- Right &lt;literal value of b&gt; =&gt; special value that takes a parameter, the literal value of the right-defined datatype b</span>

<span class="c1">-- Here&#39;s an example of Maybe in use</span>

<span class="nf">login</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="c1">-- type signature of a function that returns the username if login is succesful, and nothing if otherwise</span>
<span class="nf">login</span><span class="w"> </span><span class="s">&quot;f4bulous!&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="s">&quot;unicorn73&quot;</span><span class="w"> </span><span class="c1">-- function definition via pattern-matching</span>
<span class="nf">login</span><span class="w"> </span><span class="s">&quot;swordfish&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Just</span><span class="w"> </span><span class="s">&quot;megahacker&quot;</span>
<span class="nf">login</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Nothing</span>

<span class="c1">-- Maybe can also be called on function paramters</span>

<span class="nf">perhapsMultiply</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="c1">-- type signature</span>
<span class="nf">perhapsMultiply</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="kt">Nothing</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="c1">-- if empty argument provided</span>
<span class="nf">perhapsMultiply</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">(</span><span class="kt">Just</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="w">   </span><span class="c1">-- where non-empty argument provided</span>

<span class="c1">-- Here&#39;s an example of Either in use</span>

<span class="nf">readInt</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Either</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="c1">-- type signature</span>
<span class="nf">readInt</span><span class="w"> </span><span class="s">&quot;0&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Right</span><span class="w"> </span><span class="mi">0</span>
<span class="nf">readInt</span><span class="w"> </span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Right</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">readInt</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Unsupported string: &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">s</span><span class="p">)</span>

<span class="c1">-- Either can also be called on function parameters</span>

<span class="nf">iWantAString</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Either</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="c1">-- type signature</span>
<span class="nf">iWantAString</span><span class="w"> </span><span class="p">(</span><span class="kt">Right</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">str</span>
<span class="nf">iWantAString</span><span class="w"> </span><span class="p">(</span><span class="kt">Left</span><span class="w"> </span><span class="n">number</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">number</span>

<span class="c1">-- Either allows for flexible definitions of the given datatype within a list as well</span>

<span class="nf">lectureParticipants</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Either</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">lectureParticipants</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="kt">Left</span><span class="w"> </span><span class="s">&quot;lecturer was sick&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">Left</span><span class="w"> </span><span class="s">&quot;easter vacation&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">Right</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="kt">Right</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="kt">Right</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="kt">Right</span><span class="w"> </span><span class="mi">17</span><span class="p">]</span>

<span class="c1">-- TYPE SIGNATURES</span>
<span class="w">    </span><span class="c1">-- functions have their parameter and return type&#39;s type signatures explicitly declared before the function definition</span>
<span class="w">    </span><span class="c1">-- :: =&gt; means &quot;has the type of&quot;</span>
<span class="w">    </span><span class="c1">-- -&gt; =&gt; seperates each parameter type and return type with a syntax very similar to Clojure</span>

<span class="nf">removeNonUppercase</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Char</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Char</span><span class="p">]</span><span class="w"> </span><span class="c1">-- this function removes all uppercase characters</span>
<span class="nf">removeNonUppercase</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">`</span><span class="n">elem</span><span class="p">`</span><span class="w"> </span><span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]]</span>

<span class="nf">addThree</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="c1">-- this function receives three arguments of type Int and returns a value of type Int</span>
<span class="nf">addThree</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span>

<span class="c1">-- TYPE VARIABLES</span>
<span class="w">    </span><span class="c1">-- used in type signatures for functions that don&#39;t have type-specific behaviour and accept arguments of multiple types, Haskell&#39;s equivalent of generics in other languages</span>
<span class="w">    </span><span class="c1">-- these functions are called polymorphic functions</span>
<span class="w">    </span><span class="c1">-- type variables are specified with single-character names like &#39;a&#39; as seen below by convention</span>

<span class="nf">head</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="c1">-- the type signature of the head function employs a type variable since its behaviour could apply to tuples of Int, Char, Bool, Float or any other type</span>
<span class="nf">tail</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="c1">-- the same logic applies for the type signatures of the tail function, which take in a list of any datatype and return a list of that same datatype</span>
<span class="nf">fst</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="c1">-- similarly, the type signature of the fst function employs a type variables since its behaviour is not type-specific</span>

<span class="c1">-- TYPECLASSES</span>
<span class="w">    </span><span class="c1">-- specify behaviour for types by prescribing them within the typeclass, allowing for a degree of meta-programming similar to interfaces in other languages and metatables in Lua</span>
<span class="w">    </span><span class="c1">-- behaviours specified through class constraints which are decalred in () brackets within the function&#39;s type signature before the function&#39;s parameter and return types</span>
<span class="w">    </span><span class="c1">-- =&gt; =&gt; seperates class constraints from the function&#39;s parameters and return types</span>

<span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="c1">-- the equality function&#39;s type signature (a -&gt; a) specifies that it receives any two values that are the same type as arguments and returns a Boolean, while the typeclass specifies that the argument&#39;s type must be a member of the Eq class (Eq a)</span>
<span class="p">(</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Bool</span><span class="w"> </span><span class="c1">-- the comparison function&#39;s type signature (a -&gt; a) specifies that it receives any two values that are the same type as arguments and returns a Boolean, while the typeclass specifies that the argument&#39;s type must be a member of the Ord class (Ord a)</span>

<span class="c1">-- ADDITIONAL TERMINOLOGY</span>
<span class="w">    </span><span class="c1">-- type parameter =&gt; refers to a within the type [a]</span>
<span class="w">    </span><span class="c1">-- parameterized type =&gt; refers to data structure types like the list that require a type parameter</span>
<span class="w">    </span><span class="c1">-- polymorphism =&gt; where a function can receive many different types of arguments</span>
<span class="w">    </span><span class="c1">-- parametric polymorphism =&gt; refers to the use of type variables within functions</span>
</code></pre></div>

<h2>Operators</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">-- ---------- OPERATOR ----------</span>

<span class="c1">-- ARITHMETIC OPERATORS</span>
<span class="w">    </span><span class="c1">-- + =&gt; addition</span>
<span class="w">    </span><span class="c1">-- - =&gt; subtraction</span>
<span class="w">    </span><span class="c1">-- * =&gt; multiplication</span>
<span class="w">    </span><span class="c1">-- / =&gt; division</span>
<span class="w">    </span><span class="c1">-- div =&gt; floor divison</span>
<span class="w">    </span><span class="c1">-- mod =&gt; modulo operator</span>

<span class="c1">-- LOGICAL OPERATORS</span>
<span class="w">    </span><span class="c1">-- &amp;&amp; =&gt; and</span>
<span class="w">    </span><span class="c1">-- || =&gt; or</span>
<span class="w">    </span><span class="c1">-- not =&gt; logical not</span>

<span class="c1">-- COMPARISON OPERATORS</span>
<span class="w">    </span><span class="c1">-- == =&gt; partial equality check for value but not type</span>
<span class="w">    </span><span class="c1">-- /= =&gt; partial inequality check for value but not type</span>
<span class="w">    </span><span class="c1">-- &gt; &lt; &lt;= &gt;= are also comparsion operators</span>
</code></pre></div>

<h2>Data structures</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">-- ---------- DATA STRUCTURE ----------</span>

<span class="c1">-- LIST</span>
<span class="w">    </span><span class="c1">-- ordered sequence of elements of the same type, declared with [] square brackets where elements are comma-delimited </span>
<span class="w">    </span><span class="c1">-- therefore a String is a type alias for [Char], which means all list operations can also be run on Strings</span>
<span class="w">    </span><span class="c1">-- observe that Haskell lists are implemented as singly-linked lists on the backend</span>
<span class="w">    </span><span class="c1">-- .. =&gt; creates an inclusive integer range that is an iterable data structure beginning from the start index and ending at the specified end index</span>

<span class="nf">lostNumbers</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="c1">-- type signature</span>
<span class="nf">anotherRange</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="c1">-- also a type signature</span>
<span class="nf">lostNumbers</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- an Int list literal in Haskell</span>
<span class="nf">anotherRange</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>

<span class="c1">-- LIST OPERATIONS</span>
<span class="w">    </span><span class="c1">-- Haskell is pure and all variables are immutable by default (including lists), so list operations return the value of the modified list and do NOT modify the list itself in memory</span>
<span class="w">    </span><span class="c1">-- ++ =&gt; concatenates two lists together, though Haskell has to traverse the entire left list before processing the concatenation</span>
<span class="w">    </span><span class="c1">-- : =&gt; inserts a value to the start of the list immediately, much faster than concatenation</span>
<span class="w">    </span><span class="c1">-- !! =&gt; extracts a list element by index, the equivalent of [] square bracket indexing in Python</span>
<span class="w">    </span><span class="c1">-- &lt; &gt; == =&gt; compares list elements in lexographical order</span>
<span class="w">    </span><span class="c1">-- head =&gt; returns the first element of a list</span>
<span class="w">    </span><span class="c1">-- tail =&gt; returns everything but the list&#39;s head</span>
<span class="w">    </span><span class="c1">-- last =&gt; returns the last element of a list</span>
<span class="w">    </span><span class="c1">-- init =&gt; returns everything but the list&#39;s last element</span>
<span class="w">    </span><span class="c1">-- length =&gt; returns the length of the list</span>
<span class="w">    </span><span class="c1">-- null =&gt; checks whether a list is empty and returns a Boolean</span>
<span class="w">    </span><span class="c1">-- reverse =&gt; returns a reversed copy of a list</span>
<span class="w">    </span><span class="c1">-- take =&gt; extracts a specified number of elements from the start of a list</span>
<span class="w">    </span><span class="c1">-- drop =&gt; drops a specified number of elements from the start of a list and returns the remaining elements as a sublist</span>
<span class="w">    </span><span class="c1">-- maximum =&gt; returns the element of maximum value in a list</span>
<span class="w">    </span><span class="c1">-- minimum =&gt; returns the element of minimum value in a list</span>
<span class="w">    </span><span class="c1">-- sum =&gt; returns the sum of all elements in a list</span>
<span class="w">    </span><span class="c1">-- product =&gt; returns the product of all elements in a list</span>
<span class="w">    </span><span class="c1">-- elem =&gt; checks whether a specified element is part of a list and returns a Boolean</span>
<span class="w">    </span><span class="c1">-- further list operations can be found within the module Data.List</span>

<span class="nf">yesList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the list value [1,2,3,4,5,6,7,8,9,10]</span>
<span class="nf">yesGreeting</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s">&quot;uncle&quot;</span><span class="w"> </span><span class="c1">-- evaluates to the String (Char list) value &quot;hello uncle&quot;</span>
<span class="nf">observation</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="kt">:</span><span class="s">&quot; small cat&quot;</span><span class="w"> </span><span class="c1">-- evaluates to the String (Char list) value &quot;a small cat&quot;</span>
<span class="nf">theHero</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Steve Buscemi&quot;</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="c1">-- evaluates to the Char value &#39;B&#39;, which has an index of 6 in the String (Char list)</span>
<span class="nf">booleanYesOrNo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to Boolean True</span>
<span class="nf">theHead</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int value 5</span>
<span class="nf">theTail</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int list of [4,3,2,1] </span>
<span class="nf">theLastElement</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int value 5</span>
<span class="nf">theInit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int list of [5,4,3,2]</span>
<span class="nf">theLength</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int value 5</span>
<span class="nf">theNullCheck</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">null</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="c1">-- evaluates to Boolean True</span>
<span class="nf">anotherNullCheck</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">null</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to Boolean False</span>
<span class="nf">theReversedList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">reverse</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int list of [1,2,3,4,5]</span>
<span class="nf">extractedList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int list of [1,2,3]</span>
<span class="nf">anotherExtractedList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the empty list of [] since 0 elements were extracted</span>
<span class="nf">yetAnotherExtractedList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int list of [1,2] since the entire list was extracted</span>
<span class="nf">droppedList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">drop</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int list of [4,5,6,7,8]</span>
<span class="nf">anotherDroppedList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">drop</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int list of [1,2,3,4] since no values were dropped</span>
<span class="nf">yetAnotherDroppedList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">drop</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the empty list of [] since all the values were dropped</span>
<span class="nf">maximumValue</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">maximum</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">83</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int value of 83</span>
<span class="nf">minimumValue</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">minimum</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int value of 0</span>
<span class="nf">sumOfValues</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">129</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int value of 139</span>
<span class="nf">productOfValues</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">product</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to the Int value of 240</span>
<span class="nf">isItPartOfList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">`</span><span class="n">elem</span><span class="p">`</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to Boolean True</span>
<span class="nf">isItAlsoPartOfList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">`</span><span class="n">elem</span><span class="p">`</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="c1">-- evaluates to Boolean False</span>

<span class="c1">-- we can also combine multiple list operations as seen below</span>

<span class="nf">f</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">f</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">drop</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="c1">-- function that discards the 3rd and fourth element of a list</span>

<span class="nf">g</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">g</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="n">head</span><span class="w"> </span><span class="n">xs</span><span class="p">]</span><span class="w"> </span><span class="c1">-- function that rotates a list by taking the first element and moving it to the back of the list</span>

<span class="c1">-- TUPLE</span>
<span class="w">    </span><span class="c1">-- ordered sequence of elements of a fixed size that can store different types</span>
<span class="w">    </span><span class="c1">-- declared with () brackets, elements are comma-delimited</span>

<span class="nf">someTuple</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="c1">-- an Int tuple in Haskell</span>

<span class="c1">-- TUPLE OPERATIONS</span>
<span class="w">    </span><span class="c1">-- fst =&gt; receives a pair (tuple with two elements) as an argument and returns the first element</span>
<span class="w">    </span><span class="c1">-- snd =&gt; receives a pair (tuple with two elements) as an argument and returns the second element</span>
<span class="w">    </span><span class="c1">-- zip =&gt; takes two lists and returns a list of pairs comprised of elements of corresponding positions in the input lists</span>

<span class="nf">firstElement</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">fst</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">-- this evaluates to the Int value 1</span>
<span class="nf">secondElement</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">snd</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">-- this evaluates to the Int value 2</span>
<span class="nf">list1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span>
<span class="nf">list2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;one&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;three&quot;</span><span class="p">]</span>
<span class="nf">zippedList</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="n">list1</span><span class="w"> </span><span class="n">list2</span><span class="w"> </span><span class="c1">-- this evaluates to the Int tuple list value of [(1, &quot;one&quot;), (2, &quot;two&quot;), (3, &quot;three&quot;)]</span>
</code></pre></div>

<h2>Control structures</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">-- ---------- CONTROL STRUCTURE ----------</span>

<span class="c1">-- CONDITIONALS</span>

<span class="c1">-- IF THEN ELSE</span>
<span class="w">    </span><span class="c1">-- else =&gt; required in every if statement since every expression (including conditional expressions) must evalaute to a value</span>

<span class="nf">doubleSmallNumber</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">Ord</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span>
<span class="nf">doubleSmallNumber</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span>
<span class="w">                      </span><span class="kr">then</span><span class="w"> </span><span class="n">x</span><span class="w"> </span>
<span class="w">                      </span><span class="kr">else</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span>

<span class="c1">-- PATTERN-MATCHING WITHIN DEFINITION</span>
<span class="w">    </span><span class="c1">-- pattern-matching is most commonly executed on functions within the function definition</span>
<span class="w">    </span><span class="c1">-- a function definition can consist of multiple equations, where each equation is matched in order against the arguments until a suitable one is found</span>
<span class="w">    </span><span class="c1">-- here _ serves the same role as the catch-all operator where it evaluates when all other predicate equations fail to be matched</span>

<span class="nf">greet</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="c1">-- type annotation</span>
<span class="nf">greet</span><span class="w"> </span><span class="s">&quot;Finland&quot;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Hei, &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="c1">-- case 1</span>
<span class="nf">greet</span><span class="w"> </span><span class="s">&quot;Italy&quot;</span><span class="w">   </span><span class="n">name</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Ciao, &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="c1">-- case 2</span>
<span class="nf">greet</span><span class="w"> </span><span class="s">&quot;England&quot;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;How do you do, &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="c1">-- case 2</span>
<span class="nf">greet</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Hello, &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="c1">-- default case</span>

<span class="c1">-- the logical extension is that pattern-matching can occur on any number of arguments as seen below</span>

<span class="nf">login</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">login</span><span class="w"> </span><span class="s">&quot;unicorn73&quot;</span><span class="w"> </span><span class="s">&quot;f4bulous!&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;unicorn73 logged in&quot;</span>
<span class="nf">login</span><span class="w"> </span><span class="s">&quot;unicorn73&quot;</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;wrong password&quot;</span>
<span class="nf">login</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;unknown user&quot;</span>

<span class="c1">-- GUARDED DEFINITIONS</span>
<span class="w">    </span><span class="c1">-- provided as an alternative to the cumbersome IF THEN ELSE conditional constructs especially when there are multiple predicate cases</span>
<span class="w">    </span><span class="c1">-- instead, Haskell provides conditional definitions, AKA guarded definitions</span>
<span class="w">    </span><span class="c1">-- these operate similarly to pattern-matching by providing multiple equations that run based on specified predicate case conditions, and are particularly useful in recursive function call definitions</span>
<span class="w">    </span><span class="c1">-- | =&gt; pipe operator specifies the predicate case condition to be fulfilled </span>
<span class="w">    </span><span class="c1">-- = =&gt; specifies the relationship between a defined case condition and the arbitrary equation to be run when that case condition is fulfilled</span>
<span class="w">    </span><span class="c1">-- otherwise =&gt; acts as the default fall-through case, the equivalent of the _ catch-all operator in match-case constructs in most other programming languages</span>

<span class="c1">-- a simple conditional definition</span>
<span class="nf">describe</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">describe</span><span class="w"> </span><span class="n">n</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Two&quot;</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Even&quot;</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Three&quot;</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Big!!&quot;</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;The number &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">show</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="c1">-- default fall-through case</span>

<span class="c1">-- recursive function call with conditional definitions</span>
<span class="nf">factorial</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">factorial</span><span class="w"> </span><span class="n">n</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">-- guards can even be COMBINED with existing pattern-matching constructs as below</span>
<span class="nf">guessAge</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span>
<span class="nf">guessAge</span><span class="w"> </span><span class="s">&quot;Griselda&quot;</span><span class="w"> </span><span class="n">age</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">47</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Too low!&quot;</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">47</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Too high!&quot;</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Correct!&quot;</span>
<span class="nf">guessAge</span><span class="w"> </span><span class="s">&quot;Hansel&quot;</span><span class="w"> </span><span class="n">age</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Too low!&quot;</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Too high!&quot;</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Correct!&quot;</span>
<span class="nf">guessAge</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot;Wrong name!&quot;</span>

<span class="c1">-- CASE OF _</span>
<span class="w">    </span><span class="c1">-- Haskell features extremely powerful pattern-matching construct similar to the match case statements in other languages</span>
<span class="w">    </span><span class="c1">-- pattern cases are checked in order from top to bottom so arrangement matters</span>
<span class="w">    </span><span class="c1">-- this effectively enables pattern-matching within expressions as opposed to merely within definitions, as well as pattern-matching against function outputs</span>
<span class="w">    </span><span class="c1">-- _ =&gt; wildcard catch-all operator that acts as the equivalent of the default statement in other languages</span>

<span class="nf">numberAsString</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="c1">-- static type declaration of an expression prior to expression initialisation</span>
<span class="nf">numberAsString</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="kr">of</span>
<span class="w">    </span><span class="mi">1</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="s">&quot;One&quot;</span>
<span class="w">    </span><span class="mi">2</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="s">&quot;Two&quot;</span>
<span class="w">    </span><span class="mi">3</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="s">&quot;Three&quot;</span>
<span class="w">    </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="s">&quot;Unknown but also the catch-call wildcard operator&quot;</span>

<span class="c1">-- LOOPS DON&#39;T EXIST</span>
<span class="w">    </span><span class="c1">-- higher-order functions, recursion and list comprehension are used in place of imperative loop constructs like for or while loops, which Haskell does not have</span>
<span class="w">    </span><span class="c1">-- this is in line with most other functional programming paradigms that Haskell adheres to</span>

<span class="c1">-- HIGHER-ORDER FUNCTIONS</span>
<span class="w">    </span><span class="c1">-- map =&gt; applies a specified function on each element of an iterable structure and returns the transformed data structure</span>
<span class="w">    </span><span class="c1">-- filter =&gt; applies a specified predicate to each element of an iterable structure and returns the data structure with elements that fulfil the predicate</span>
<span class="w">    </span><span class="c1">-- foldl, foldr =&gt; reduces a list to a single value by repeatedly applying a specified binary function to each element of the list, the equivalent of reduce in Haskell</span>
<span class="w">    </span><span class="c1">-- zipWith =&gt; combines two lists with a specified function</span>
<span class="w">    </span><span class="c1">-- compose =&gt; declared with a . period, combines two functions into a new function</span>
<span class="w">    </span><span class="c1">-- flip =&gt; receives a function, reverses its first two arguments and returns that new function</span>

<span class="nf">squareList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">squareList</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="c1">-- calling map function</span>

<span class="nf">evenNumbers</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integral</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">evenNumbers</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="c1">-- calling filter function</span>

<span class="nf">sumList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span>
<span class="nf">sumList</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldl</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="c1">-- calling reduce function</span>

<span class="nf">addLists</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">addLists</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="c1">-- calling zipWith function</span>

<span class="nf">squareAndDouble</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span>
<span class="nf">squareAndDouble</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">-- calling compose function</span>

<span class="nf">subtractFrom</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span>
<span class="nf">subtractFrom</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">flip</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="p">)</span><span class="w"> </span><span class="c1">-- calling flip function</span>

<span class="c1">-- RECURSION</span>
<span class="w">    </span><span class="c1">-- Haskell function calls are very efficient, so performance is rarely a concern when it comes to recursion</span>
<span class="w">    </span><span class="c1">-- in reality recursion is merely a natural application of Haskell&#39;s powerful pattern-matching construct that occurs even in definitions</span>
<span class="w">    </span><span class="c1">-- helper functions are also very useful to declutter and simplify the visible logic of a recursive call, wherein helper functions are named originalFunctionName&#39; which is read as originalFunctionNamePrime by convention</span>
<span class="w">    </span><span class="c1">-- a simple way to think about recursion is always </span>
<span class="w">        </span><span class="c1">-- 1. FIRST define what the base case of a recursive function call that the call recurses to should be</span>
<span class="w">        </span><span class="c1">-- 2. THEN write out the otherwise case that runs when the base case is not yet called</span>
<span class="w">        </span><span class="c1">-- 3. WORK it out on paper if need be to visualise each iteration of the function call</span>

<span class="c1">-- to find the factorial! of a given number, noting the definition of factorial is n! = n * (n-1) *  * 1</span>
<span class="nf">factorial</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">factorial</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">-- base case</span>
<span class="nf">factorial</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">-- to find the sum of squares of all numbers from 1 to the given number, noting the definition of the squared sum is 1^2 + 2^2 + 3^2 + ... + n^2</span>
<span class="nf">squareSum</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span>
<span class="nf">squareSum</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">-- base case</span>
<span class="nf">squareSum</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">squareSum</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">-- to sum the elements of a list</span>
<span class="nf">sumList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span>
<span class="nf">sumList</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">-- base case</span>
<span class="nf">sumList</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sumList</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span>

<span class="c1">-- helper function </span>
<span class="nf">repeatHelper</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="c1">-- type signature</span>
<span class="nf">repeatHelper</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span>
<span class="w">                            </span><span class="kr">then</span><span class="w"> </span><span class="n">result</span>
<span class="w">                            </span><span class="kr">else</span><span class="w"> </span><span class="n">repeatHelper</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="o">++</span><span class="n">str</span><span class="p">)</span>

<span class="c1">-- helper function that has the same type signature as above but now we use pattern-matching INSTEAD of the if else construct within the function definition</span>
<span class="nf">repeatHelper</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">_</span><span class="w">   </span><span class="n">result</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="c1">-- as long as n == 0, then it does not matter what the string is, this first case will run</span>
<span class="nf">repeatHelper</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">repeatHelper</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="o">++</span><span class="n">str</span><span class="p">)</span>

<span class="c1">-- actual recursive function call</span>
<span class="nf">repeatString</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="c1">-- type signature</span>
<span class="nf">repeatString</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">repeatHelper</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="s">&quot;&quot;</span>

<span class="c1">-- LIST COMPREHENSION</span>
<span class="w">    </span><span class="c1">-- given Haskell&#39;s mathematical roots, concepts like list comprehension originate from set theory</span>
<span class="w">    </span><span class="c1">-- list comprehension syntax =&gt; [{OUTPUT FUNCTION} | {VARIABLE AND INPUT SET}, {PREDICATE}]</span>
<span class="w">        </span><span class="c1">-- output function =&gt; function applied on each element</span>
<span class="w">        </span><span class="c1">-- variable =&gt; element iterated over within the input set, commas can be used to delimit multiple variables</span>
<span class="w">        </span><span class="c1">-- input set =&gt; iterable collection over which the variable iterates over, can be expressed as a range in Haskell, commas can be used to delimit multiple input sets</span>
<span class="w">        </span><span class="c1">-- predicate =&gt; specifies conditional check on the variable that limits what values from the input set can have the output function applied to them, the equivalent of a filter in other programming languages, commas can be used to delimit multiple predicates</span>
<span class="w">    </span><span class="c1">-- &lt;- =&gt; specifies the relationship between the variable and input set</span>
<span class="w">    </span><span class="c1">-- _ =&gt; catch-all operator also acts as a throwaway variable that is not needed later</span>

<span class="nf">multiplyByTwo</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]]</span><span class="w"> </span><span class="c1">-- this evaluates to the Int list of [2,4,6,8,10,12,14,16,18,20] using list comprehension</span>
<span class="nf">multiplyByTwoWithPredicate</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">12</span><span class="p">]</span><span class="w"> </span><span class="c1">-- this evaluates to the Int list of [12,14,16,18,20] using list comprehension when x fulfills the predicate of 2 * x is bigger or equals to 12</span>
<span class="nf">applyAnotherPredicate</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">50</span><span class="o">..</span><span class="mi">100</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">`</span><span class="n">mod</span><span class="p">`</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">  </span><span class="c1">-- this evaluates to the Int list of [52,59,66,73,80,87,94] using list comprehension where x fulfills the predicate of x mod 7 == 3</span>
<span class="nf">applyMultiplePredicates</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="o">..</span><span class="mi">20</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">19</span><span class="p">]</span><span class="w"> </span><span class="c1">-- commas are used to delimit multiple predicates that specify x cannot be equals to 13, 15, 19</span>
<span class="nf">applyMultipleVariableAndInputSets</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">50</span><span class="p">]</span><span class="w"> </span><span class="c1">-- commas are used to delimit multiple variable and inpiut sets to evaluate to a list of all the possible products from a list that are more than 50, which is [55,80,100,110]</span>
<span class="nf">removeNonUppercase</span><span class="w"> </span><span class="n">inputString</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">inputString</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">`</span><span class="n">elem</span><span class="p">`</span><span class="w"> </span><span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]]</span><span class="w"> </span><span class="c1">-- Strings are just Char lists so we can use list comprehension to removes all non-uppercase letters from a string</span>
<span class="nf">length</span><span class="p">`</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="p">]</span><span class="w"> </span><span class="c1">-- _ catch-all wildcard operator used to signify throwing away that variable, so this function evaluates to the length of the list where every element of the list is replaced with 1 and the value of the Int list is summed up</span>
<span class="nf">squareList</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="c1">-- note this employs typeclasses for a generic function that does not have type-specific behaviour</span>
<span class="nf">squareList</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">xs</span><span class="p">]</span><span class="w"> </span><span class="c1">-- list comprehension can also be used with functions to generate an Int list where each value is its value squared</span>
</code></pre></div>

<h2>More on</h2>
<ul>
<li>shadowing</li>
<li>tail recursion</li>
<li>Data.List</li>
<li>show</li>
<li>enumeration</li>
<li><a href="https://haskell.mooc.fi/">haskell mooc</a></li>
<li><a href="https://learnyouahaskell.com/chapters">learn you a haskell for great good</a></li>
<li><a href="https://www.haskell.org/tutorial/">a gentle introduction to haskell version 98</a></li>
<li><a href="https://www.haskell.org/downloads/">install haskell</a></li>
<li><a href="https://www.haskell.org/">haskell.org</a></li>
<li><a href="https://www.haskell.org/documentation/">haskell documentation</a></li>
<li><a href="https://learnxinyminutes.com/docs/haskell/">learn haskell in y minutes</a></li>
<li><a href="https://haskellbook.com/">haskell programming from first principles</a></li>
<li><a href="https://www.cs.yale.edu/homes/hudak/SOE/index.htm">the haskell school of expression</a></li>
<li><a href="https://wiki.haskell.org/Functional_programming">haskell wiki on functional programming</a></li>
<li><a href="https://www.slideshare.net/slideshow/the-fuss/44059475">the fuss about || haskell || scala || f#</a></li>
<li><a href="https://www.mathstat.dal.ca/~selinger/quipper/">the quipper language</a></li>
</ul>
      </section>

    </article>
    <footer>
      <p>&copy; 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>
  <div class="wrapper"></div>
</body>
</html>