# `Esolangs`

## Conceptual Esolangs

```
# ----- STACK-BASED LANGUAGES -----

# FORTH-INSPIRED
    # Reverse Polish Notation (RPN)
    # Operations work on stack of values
    # Example: 3 4 + => pushes 3, pushes 4, adds them (result: 7)

# FALSE
    # Extremely terse syntax inspired by Forth
    # Variables are single letters
    # Î² => beta function for complex operations

# ----- FUNCTIONAL ESOTERICS -----

# UNLAMBDA  
    # Based purely on combinatory logic
    # Only combinators: S, K, I functions
    # No variables, only function application
    # s => S combinator, k => K combinator, i => I combinator
    # Continuation-based I/O system

# LAZY K
    # Programs are single expressions in combinatory logic
    # Evaluation is lazy (only computed when needed)
    # Input/output through Church encoding

# ----- CELLULAR AUTOMATA -----

# RULE 110
    # Based on elementary cellular automaton Rule 110
    # Proven to be Turing complete
    # Evolution follows simple local rules
    # Complex behavior emerges from simple rules
```

## Artistic and Conceptual Esolangs

```
# ----- TEXT-BASED CONCEPTS -----

# SHAKESPEARE
    # Programs written as Shakespearean plays
    # Characters are variables, dialogue contains instructions
    # "You are as lovely as the sum of a rose and a rose" => assignment
    # Act/Scene structure controls program flow
    # Questions perform conditional operations

# CHEF
    # Programs written as cooking recipes
    # Ingredients are variables with initial values
    # Cooking methods perform operations
    # "Mix the flour into the mixture" => variable manipulation
    # Serves and refrigerates control output

# ----- VISUAL PROGRAMMING -----

# PIET
    # Programs are abstract art images
    # Execution follows colored regions in the image
    # Color changes determine operations
    # Hue changes => mathematical operations
    # Lightness changes => stack operations  
    # Uses codel (colored pixel) as basic unit

# ----- AUDIO-BASED -----

# VELATO
    # Programs written as MIDI music files
    # Note pitches and durations encode instructions
    # Must sound pleasant while being valid code
    # Stack-based operations triggered by musical intervals
```

## Theoretical Exploration

```
# ----- TURING TARPIT LANGUAGES -----
    # Languages where "everything is possible but nothing of interest is easy"
    # Minimal instruction sets that are still Turing complete

# BRAINFUCK DERIVATIVES
    # Ook! => Uses only "Ook.", "Ook?", "Ook!" 
    # Designed to be writable by orangutans
    # Direct mapping to Brainfuck commands
    # Cow => Uses only "moo" with variations

# IOTA AND JOT
    # Based on single combinator (iota)
    # Iota expressed with just 0s and 1s
    # Universal programming with two symbols
    # Demonstrates minimal computational requirements

# ----- CONSTRAINT-BASED LANGUAGES -----

# MALBOLGE
    # Designed to be as difficult as possible to program
    # Self-modifying code with encryption
    # Ternary system with unusual arithmetic
    # First "Hello World" took two years to write
    # Instructions change after execution

# INTERCAL
    # Designed to have nothing in common with other languages
    # PLEASE keyword for politeness (required percentage)
    # COME FROM (opposite of GOTO)
    # Arithmetic operations like "mingle" and "select"
```

## Implementation Concepts

```
# ----- EXECUTION MODELS -----

# TAPE-BASED (TURING MACHINE STYLE)
    # Memory as infinite tape with head position
    # Operations move head and modify tape cells
    # Brainfuck, Blanks, and similar languages

# STACK-BASED
    # Primary data structure is stack (LIFO)
    # Operations push/pop values and manipulate stack
    # Forth derivatives, Factor-inspired languages

# QUEUE-BASED  
    # FIFO data structure instead of stack
    # Changes program behavior significantly
    # Example: FlipJump uses queue for unusual control flow

# REGISTER MACHINES
    # Fixed set of registers hold values
    # Operations transfer between registers
    # SUBLEQ (subtract and branch if less than or equal)

# ----- SELF-MODIFICATION -----
    # Programs that modify their own code during execution
    # Befunge can write to its 2D code space
    # Malbolge encrypts instructions after use
    # Creates dynamic, evolving programs
```

## Educational Value

```
# ----- COMPUTATIONAL THEORY -----
    # Demonstrate Turing completeness with minimal instruction sets
    # Explore different computational models (stack, tape, cellular automata)
    # Show equivalence between different programming paradigms
    # Illustrate Church-Turing thesis through extreme examples

# ----- LANGUAGE DESIGN -----
    # Challenge assumptions about what makes languages "useful"
    # Explore syntactic possibilities beyond conventional text
    # Question relationship between readability and functionality
    # Demonstrate creativity in constraint satisfaction

# ----- PROBLEM SOLVING -----
    # Force programmers to think in radically different ways
    # Develop deep understanding of algorithmic thinking
    # Practice working within severe constraints  
    # Build appreciation for conventional language features
```

## More on

* [Esolang Wiki](https://esolangs.org/) - Comprehensive database of esoteric programming languages
* [99 Bottles of Beer](http://99-bottles-of-beer.net/) - Same program in hundreds of languages including esolangs
* [Brainfuck](https://esolangs.org/wiki/Brainfuck) - Most famous minimalist esolang
* [Befunge](https://esolangs.org/wiki/Befunge) - Influential 2D programming language
* [Code Golf Stack Exchange](https://codegolf.stackexchange.com/) - Programming puzzles often featuring esolangs
* [Turing Complete](https://turingcomplete.game/) - Game teaching computational concepts through esolang-like puzzles  
* [IOCCC](https://www.ioccc.org/) - International Obfuscated C Code Contest
* [Programming Language Theory](https://github.com/steshaw/plt) - Academic resources on language design
* [Rosetta Code](https://rosettacode.org/wiki/Rosetta_Code) - Programming tasks in multiple languages including esolangs