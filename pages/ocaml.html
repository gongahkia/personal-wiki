<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: OCaml - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>OCaml</h2>

        <dl>
          <dt>File size</dt>
          <dd>30.3KB</dd>

          <dt>Lines of code</dt>
          <dd>393</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>OCaml</code></h1>
<h2>Comments</h2>
<div class="codehilite"><pre><span></span><code><span class="c">(* This is a comment *)</span>
</code></pre></div>

<h2>Introduction</h2>
<p>A strictly evaluated, functional language with imperative features.</p>
<div class="codehilite"><pre><span></span><code><span class="c">(*** FUNCTIONAL LAND ***)</span>

<span class="c">(* everything in OCaml is an expression *)</span>
<span class="c">(* every expression (* variables, functions *) evaluates to a value *)</span>
<span class="c">(* OCaml lacks &quot;procedures&quot; and every function must evaluate to a value, so functions that don&#39;t do that and are called for their side effects (* like print_endline *) return a value of &quot;unit&quot; type *)</span>
</code></pre></div>

<h2>Expressions, Variables and Functions</h2>
<ul>
<li>double semicolon language <em>(to separate expressions, though not always necessary)</em></li>
<li><code>let</code> for function and variable declaration</li>
<li><a href="https://www.codingame.com/playgrounds/6196/explaining-currying-to-myself">currying</a> and <a href="https://stackoverflow.com/questions/6005176/ocaml-explicit-type-signatures">type signatures</a> like haskell</li>
<li>optional type declaration <em>(OCaml compiler automatically infers types)</em></li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="c">(*** EXPRESSIONS ***)</span>

<span class="c">(* Expressions can be separated by a double semicolon, though in production source code often omits the double semicolon for stylistic purposes. *)</span>

<span class="c">(*** VARIABLES ***)</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;;</span>  <span class="c">(* this is a variable *)</span>

<span class="c">(* definitons can be chained together with &quot;let ... in&quot; constructs *)</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">in</span> 
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span> <span class="k">in</span>
<span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">;;</span> <span class="c">(* this expression evaluates to 30 *)</span>

<span class="c">(*** FUNCTIONS ***)</span>

<span class="k">let</span> <span class="n">func_int</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="kt">int</span><span class="o">):</span><span class="kt">int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;;</span> <span class="c">(* this is a function *)</span>

<span class="c">(* invoking functions usually doesn&#39;t require brackets UNLESS the function argument is an expression *)</span>

<span class="k">let</span> <span class="n">func_int_10</span> <span class="o">=</span> <span class="n">func_int</span> <span class="mi">10</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">func_inc_idk</span> <span class="o">=</span> <span class="n">func_int</span> <span class="o">(</span><span class="mi">11</span><span class="o">-</span><span class="mi">1</span><span class="o">);;</span>

<span class="c">(* every function must take at least one argument *)</span>

<span class="k">let</span> <span class="n">print_hlo_wrld</span><span class="bp">()</span> <span class="o">=</span> <span class="n">print_endline</span> <span class="s2">&quot;hello world&quot;</span><span class="o">;;</span> <span class="c">(* when creating void functions, we need to specify the bracket to denote the empty function *)</span>
<span class="n">print_hlo_wrld</span><span class="bp">()</span><span class="o">;;</span> <span class="c">(* when calling void functions, we must specify the empty bracket *)</span>

<span class="c">(* calling a function with an insufficient number of arguments creates a new function *)</span>
<span class="k">let</span> <span class="n">make_inc</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;;</span> <span class="c">(* the type signature for make_inc is int -&gt; int -&gt; int *)</span>
<span class="k">let</span> <span class="n">inc_2</span> <span class="o">=</span> <span class="n">make_inc</span> <span class="mi">2</span><span class="o">;;</span> <span class="c">(* this creates a new function inc_2 of type signature int -&gt; int *)</span>
<span class="n">inc_2</span> <span class="mi">3</span><span class="o">;;</span> <span class="c">(* this will evaluate to 5 *)</span>

<span class="c">(* when there are multiple expressions in the function body, the last expression becomes the return value and all other expressions are of &quot;unit&quot; type *)</span>

<span class="k">let</span> <span class="n">print_and_return</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="n">print_endline</span> <span class="o">(</span><span class="n">string_of_int</span> <span class="n">x</span><span class="o">);</span>
    <span class="n">x</span>
<span class="o">;;</span>

<span class="c">(*** RECURSIVE FUNCTIONS ***)</span>

<span class="c">(* recursive functions must be marked with a rec*)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">factorial</span> <span class="n">n</span> <span class="o">=</span> 
    <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
<span class="o">;;</span>

<span class="c">(* note the above can also be written like this *)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">factorial</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);;</span> <span class="c">(* just that this shit is really virtually unreadable so the above is preferred *)</span>

<span class="c">(* the &quot;let ... and ... in&quot; construct is also available for mutually recursive functions *)</span>

<span class="k">let</span> <span class="k">rec</span> 
    <span class="n">is_even</span> <span class="o">=</span> <span class="k">function</span> 
    <span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="bp">true</span>
    <span class="o">|</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">is_odd</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
<span class="k">and</span> 
    <span class="n">is_odd</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="bp">false</span>
    <span class="o">|</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">is_even</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
<span class="o">;;</span>

<span class="c">(*** ANONYMOUS FUNCTIONS ***)</span>

<span class="c">(* anonymous functions are declared with the fun keyword *)</span>

<span class="k">let</span> <span class="n">my_lambda</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">;;</span>
</code></pre></div>

<h2>Operators</h2>
<div class="codehilite"><pre><span></span><code><span class="c">(*** OPERATORS ***)</span>

<span class="c">(* in functional programming land, every operator is a function and can be called as such *)</span>
<span class="o">(+)</span> <span class="mi">3</span> <span class="mi">4</span><span class="o">;;</span> <span class="c">(* evaluates the same way as 3 + 4 *)</span>

<span class="c">(* OCaml DOESN&#39;T ONLY refrain from implict type conversion between floats and integers, float arithmetic uses wholly different operators *)</span>

<span class="mi">12</span> <span class="o">+</span> <span class="mi">3</span><span class="o">;;</span> <span class="c">(* integer arithmetic, evaluates to 15 *)</span>
<span class="mi">12</span> <span class="o">/</span> <span class="mi">3</span><span class="o">;;</span> <span class="c">(* integer arithmetic, evalutes to 4 *)</span>

<span class="mi">12</span><span class="o">.</span><span class="mi">0</span> <span class="o">+.</span> <span class="mi">3</span><span class="o">.</span><span class="mi">0</span><span class="o">;;</span> <span class="c">(* float arithmetic, evaluates to 15.0 *)</span>
<span class="mi">12</span><span class="o">.</span><span class="mi">0</span> <span class="o">/.</span> <span class="mi">3</span><span class="o">.</span><span class="mi">0</span><span class="o">;;</span> <span class="c">(* float arithmetic, evaluates to 4.0 *)</span>

<span class="mi">5</span> <span class="ow">mod</span> <span class="mi">2</span><span class="o">;;</span> <span class="c">(* modulo is universal across floats and integers *)</span>

<span class="c">(* Unary minus (* the negation operator *) is a marked exception to this rule as it is polymorphic, although type-specific versions of it do exist as well *)</span>

<span class="c">(* Unary operators are operators which are used to calculate the result on only one operand *)</span>
<span class="c">(* Binary operators are operatores which are used to calculate the result on two operands *)</span>

<span class="c">(* Polymorphic unary operator *)</span>

<span class="o">-</span><span class="mi">3</span><span class="o">;;</span> <span class="c">(* evaluates to the integer value -3 *)</span>
<span class="o">-</span><span class="mi">4</span><span class="o">.</span><span class="mi">5</span><span class="o">;;</span> <span class="c">(* evaluates to the float value -4.5 *)</span>

<span class="c">(* Type specific unary operators *)</span>

<span class="o">~-</span> <span class="mi">3</span><span class="o">;;</span> <span class="c">(* applicable for integers only *)</span>
<span class="o">~-.</span> <span class="mi">3</span><span class="o">.</span><span class="mi">4</span><span class="o">;;</span> <span class="c">(* applicable for floats only *)</span>
<span class="o">~-</span> <span class="mi">3</span><span class="o">.</span><span class="mi">4</span><span class="o">;;</span> <span class="c">(* this results in a type error *)</span>

<span class="c">(* You can also be sneaky and redefine your own operators for fun *)</span>

<span class="k">let</span> <span class="o">(~/)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="o">/.</span> <span class="n">x</span><span class="o">;;</span> <span class="c">(* unary operators must start with ~ *)</span>
<span class="o">~/</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span><span class="o">;;</span> <span class="c">(* this evaluates to the float value of 0.25 *)</span>
</code></pre></div>

<h2>Data structures</h2>
<div class="codehilite"><pre><span></span><code><span class="c">(*** DATA STRUCTURES ***)</span>

<span class="c">(* LIST *)</span>

<span class="c">(* square brackets, items are semi-colon separated *)</span>
<span class="c">(* dynamically allocated space, size can be casually changed *)</span>
<span class="c">(* dynamically allocated space, can store elements of different datat types *)</span>

<span class="k">let</span> <span class="n">my_list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span> <span class="c">(* of type &quot;int list&quot; *)</span>

<span class="c">(* LIST METHODS *)</span>

<span class="c">(* LIST INDEXING *)</span>

<span class="nn">List</span><span class="p">.</span><span class="n">nth</span> <span class="n">my_list</span> <span class="mi">1</span><span class="o">;;</span> <span class="c">(* evaluates to integer 2, the second element in the list of index 1 *)</span>

<span class="c">(* LIST MAP *)</span>

<span class="c">(* List.map() calls an anonymous function that is user-defined *)</span>

<span class="c">(* List.map() applies the given function to each iteration variablein the list *)</span>

<span class="nn">List</span><span class="p">.</span><span class="n">map</span><span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>  <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span> <span class="c">(* this should evaulate to [2;4;6] *)</span>

<span class="c">(* LIST FILTER *)</span>

<span class="c">(* List.filter() also calls an anonymous function that is user-defined *)</span>

<span class="c">(* List.filter() applies the specified conditonal check as a function to the list, and only those that pass said check are remaining in the list *)</span>

<span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="ow">mod</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">;</span><span class="mi">4</span><span class="o">];;</span> <span class="c">(* this should evaulate to [2;4] *)</span>

<span class="c">(* ADDING ELEMENTS *)</span>

<span class="c">(* add an item to the FRONT of a list with the :: constructor which is often referred to as a &quot;cons&quot; *)</span>

<span class="mi">1</span> <span class="o">::</span> <span class="o">[</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span> <span class="c">(* evaluates to [1;2;3] *)</span>

<span class="c">(* TUPLES *)</span>

<span class="c">(* (* optionally surrounded by *) round brackets, items are comma separated *)</span>

<span class="k">let</span> <span class="n">my_tuple</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">;;</span> <span class="c">(* of type &quot;int * int&quot; *)</span>
<span class="k">let</span> <span class="n">my_other_tuple</span> <span class="o">=</span> <span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">);;</span> <span class="c">(* this is a much clearer more approved syntax *)</span>

<span class="c">(* warning to not separate list items by commas, otherwise you&#39;ll accidentally create a list with a tuple inside *)</span>

<span class="k">let</span> <span class="n">bad_list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">];;</span> <span class="c">(* this shit becomes [(1,2)] *)</span>

<span class="c">(* ARRAYS *)</span>

<span class="c">(* &quot;[| |]&quot; surrounded, items are semicolon seperated *)</span>
<span class="c">(* statically allocated space, size of array declared at initialization * )</span>
<span class="c">(* statically allocated space, arrays can only contain same data type *)</span>

<span class="c">let my_array = [| 1;2;3 |];;</span>

<span class="c">(* ARRAY INDEXING *)</span>

<span class="c">my_array.(0);; (* this evaluates to the integer 1, the first element of the array with index 0 *)</span>
</code></pre></div>

<h2>Strings and Characters</h2>
<div class="codehilite"><pre><span></span><code><span class="c">(*** STRINGS and CHARACTERS ***)</span>

<span class="c">(* double quotes for string literals *)</span>
<span class="c">(* single quotes for character literals *)</span>
<span class="c">(* single and double quotes are not interchangeable, effects may vary depending on how you mix them up *)</span>

<span class="k">let</span> <span class="n">my_str</span> <span class="o">=</span> <span class="s2">&quot;Hello world&quot;</span><span class="o">;;</span> <span class="c">(* string literal *)</span>
<span class="k">let</span> <span class="n">my_char</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="o">;;</span> <span class="c">(* character literal *)</span>
<span class="k">let</span> <span class="n">unintended_effect</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="o">;;</span> <span class="c">(* this creates a single character string, not a character *)</span>
<span class="k">let</span> <span class="n">syntax_error</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">syntax</span> <span class="n">error&#39;</span><span class="o">;;</span> <span class="c">(* this results in a syntax error *)</span>

<span class="c">(* STRING CONCATENATION *)</span>

<span class="c">(* ^ operator *)</span>

<span class="k">let</span> <span class="n">some_str</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span> <span class="o">^</span> <span class="s2">&quot;world&quot;</span><span class="o">;;</span> <span class="c">(* evaluates to &quot;helloworld&quot; string *)</span>

<span class="c">(* CAVEAT *)</span>

<span class="c">(* strings are NOT arrays of characters, and the two data types cannot be mixed in expressions *)</span>
<span class="c">(* characters are converted to strings with String.make 1 my_char *)</span>

<span class="k">let</span> <span class="n">ocaml</span> <span class="o">=</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">make</span> <span class="mi">1</span> <span class="sc">&#39;O&#39;</span><span class="o">)</span> <span class="o">^</span> <span class="s2">&quot;Caml&quot;</span><span class="o">;;</span> <span class="c">(* this evaluates to the string value &quot;OCaml&quot; by type converting a character to a string and concatenating that single-character string with the &quot;Caml&quot; string *)</span>

<span class="c">(* FORMATTED STRING *)</span>

<span class="c">(* C or Bash-like syntax *)</span>

<span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%d %s&quot;</span> <span class="mi">99</span> <span class="s2">&quot;bottles of beer&quot;</span><span class="o">;;</span> <span class="c">(* evauates to the string value of &quot;99 bottles of beer&quot; *)</span>

<span class="c">(* PRINT STATEMENTS *)</span>

<span class="n">print_string</span> <span class="s2">&quot;hello world</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">;;</span> <span class="c">(* prints string values without the newline character *)</span>
<span class="n">print_endline</span> <span class="s2">&quot;hello world&quot;</span><span class="o">;;</span> <span class="c">(* prints string with a newline character *)</span>

<span class="c">(* READ STRINGS *)</span>

<span class="k">let</span> <span class="n">line</span> <span class="o">=</span> <span class="n">read_line</span><span class="bp">()</span><span class="o">;;</span> <span class="c">(* does what it says it does *)</span>
</code></pre></div>

<h2>User-defined data types</h2>
<div class="codehilite"><pre><span></span><code><span class="c">(*** USER-DEFINED DATA TYPES ***)</span>

<span class="c">(* defined using the type keyword *)</span>

<span class="k">type</span> <span class="n">my_int</span> <span class="o">=</span> <span class="kt">int</span><span class="o">;;</span> <span class="c">(* this is an incredibly useless type alias, refrain from doing this *)</span>

<span class="c">(* there are also magic type constructors that must start with a capital letter, do google what these do for more detail *)</span>

<span class="k">type</span> <span class="n">ml</span> <span class="o">=</span> <span class="nc">Ocaml</span> <span class="o">|</span> <span class="nc">StandardML</span><span class="o">;;</span> 
<span class="k">let</span> <span class="n">lang</span> <span class="o">=</span> <span class="nc">OCaml</span><span class="o">;;</span> <span class="c">(* has the type &quot;ml&quot; *)</span>

<span class="c">(* the below are also valid type constructors *)</span>

<span class="k">type</span> <span class="n">my_number</span> <span class="o">=</span> <span class="nc">PlusInfinity</span> <span class="o">|</span> <span class="nc">MinusInfinity</span> <span class="o">|</span> <span class="nc">Real</span> <span class="k">of</span> <span class="kt">float</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">r0</span> <span class="o">=</span> <span class="nc">Real</span> <span class="o">(-</span><span class="mi">3</span><span class="o">.</span><span class="mi">4</span><span class="o">);;</span> <span class="c">(* of type my_number *)</span>

<span class="c">(* type constructors can also be used to implement polymorphoc arithmetic *)</span>

<span class="k">type</span> <span class="n">number</span> <span class="o">=</span> <span class="nc">Int</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Float</span> <span class="k">of</span> <span class="kt">float</span><span class="o">;;</span> 

<span class="c">(* an example is of a point on a 2d plane *)</span>

<span class="k">type</span> <span class="n">point2d</span> <span class="o">=</span> <span class="nc">Point</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">my_point</span> <span class="o">=</span> <span class="nc">Point</span> <span class="o">(</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="mi">0</span><span class="o">);;</span>

<span class="c">(* types can also be parameterized, like in this type for &quot;list of lists of anything really&quot; where &#39;a can be substituted with any type *)</span>

<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">list_of_lists</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span> <span class="kt">list</span><span class="o">;;</span>
<span class="k">type</span> <span class="n">int_list_list</span> <span class="o">=</span> <span class="kt">int</span> <span class="n">list_of_lists</span><span class="o">;;</span>

<span class="c">(* types can also mysteriously be recursive, like this type analogous to a built-in list of integers *)</span>

<span class="k">type</span> <span class="n">my_int_list</span> <span class="o">=</span> <span class="nc">EmptyList</span> <span class="o">|</span> <span class="nc">IntList</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">my_int_list</span><span class="o">;;</span>
<span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="nc">IntList</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">EmptyList</span><span class="o">);;</span>
</code></pre></div>

<h2>Pattern matching</h2>
<div class="codehilite"><pre><span></span><code><span class="c">(*** PATTERN MATCHING ***)</span>

<span class="c">(* all hail the pattern matching statement *)</span>
<span class="c">(* matches an argument against an exact value, a predicate or a type constructor *)</span>
<span class="c">(* _ acts as the catch-all default statement similar to Rust *)</span>

<span class="c">(* MATCHING against exact values *)</span>

<span class="k">let</span> <span class="n">is_zero</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="n">x</span> <span class="k">with</span> 
    <span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="bp">true</span>
    <span class="o">|</span> <span class="o">_</span>  <span class="o">-&gt;</span> <span class="bp">false</span>
<span class="o">;;</span>

<span class="k">let</span> <span class="n">is_one</span> <span class="o">=</span> <span class="k">function</span>  <span class="c">(* the function keyword is interchangeable with the match with *)</span>
    <span class="o">|</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="bp">true</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>
<span class="o">;;</span>

<span class="c">(* MATCHING predicates *)</span>

<span class="c">(* basically guarded pattern matching aka pattern matching with a conditional check *)</span>

<span class="k">let</span> <span class="n">abs</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="n">x</span> <span class="k">with</span> 
    <span class="o">|</span> <span class="n">x</span> <span class="k">when</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="n">x</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">x</span>
<span class="o">;;</span>

<span class="n">abs</span> <span class="mi">5</span><span class="o">;;</span> <span class="c">(* evaluates to 5 *)</span>
<span class="n">abs</span> <span class="o">(-</span><span class="mi">5</span><span class="o">);;</span> <span class="c">(* also evaluates to 5 *)</span>

<span class="c">(* MATCHING type constructors *)</span>

<span class="k">type</span> <span class="n">animal</span> <span class="o">=</span> <span class="nc">Dog</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nc">Cat</span> <span class="k">of</span> <span class="kt">string</span><span class="o">;;</span>

<span class="k">let</span> <span class="n">say</span> <span class="n">x</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="n">x</span> <span class="k">with</span> 
    <span class="o">|</span> <span class="nc">Dog</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">^</span> <span class="s2">&quot; says woof&quot;</span> 
    <span class="o">|</span> <span class="nc">Cat</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">^</span> <span class="s2">&quot; says meow&quot;</span>
<span class="o">;;</span>

<span class="n">say</span> <span class="o">(</span><span class="nc">Cat</span> <span class="s2">&quot;Fluffy&quot;</span><span class="o">);;</span> <span class="c">(* evaluates to the string &quot;Fluffy says meow&quot; *)</span>

<span class="c">(* TRAVERSING DATA STRUCTURES with pattern matching *)</span>

<span class="c">(* most commonly used for recursive types *)</span>
<span class="c">(* built-in constructor operator :: covered previously can be matched like any other since its a type constructor *)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">sum_list</span> <span class="n">l</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span> 
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span> <span class="o">-&gt;</span> <span class="n">head</span> <span class="o">+</span> <span class="o">(</span><span class="n">sum_list</span> <span class="n">tail</span><span class="o">)</span>
<span class="o">;;</span>

<span class="n">sum_list</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">];;</span> <span class="c">(* evaluates to 6 *)</span>
</code></pre></div>

<h2>More on</h2>
<ul>
<li><a href="https://ocaml.org/">ocaml documentation</a></li>
<li><a href="https://github.com/ocsigen/eliom">eliom full stack</a></li>
<li><a href="https://ocaml.org/play">web-based editor and interpreter</a></li>
<li><a href="https://cs3110.github.io/textbook/cover.html">another tutorial</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
