<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Nim - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Nim</h2>

        <dl>
          <dt>File size</dt>
          <dd>11.7KB</dd>

          <dt>Lines of code</dt>
          <dd>303</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Nim</code></h1>
<p>Programming language that brings together the efficiency of C and the productivity of Python.</p>
<h2>Comments</h2>
<pre class="codehilite"><code class="language-nim"># ---------- COMMENT ----------

# this is a single-line comment

#[
this is a 
multi-line
comment
#]
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-nim"># ---------- PRINT ----------
    # write =&gt; prints a string and does not include a newline
    # echo =&gt; prints a string and appends a newline to the output

write(&quot;this does not include a newline and we must explicitly specify it\n&quot;)
echo &quot;this automatically includes a newline&quot;
</code></pre>

<h2>Quickstart</h2>
<pre class="codehilite"><code class="language-nim"># ---------- QUICKSTART ----------
    # var =&gt; declares and creates a mutable variable whose value can be reassigned after initial assignment at runtime
    # let =&gt; declares and creates an immutable variable whose value cannot be reassigned after initial assignment at runtime
    # const =&gt; declares and creates an immutable constant whose value cannot be reassigned after initial assignment at compile-time
    # : =&gt; used to specify the datatype of a given value

var string1:string = &quot;nim is&quot;
string1.add(&quot;handsome&quot;)

let age:int = 10

const fibonacci:int = fib(30)
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-nim"># ---------- TYPE ----------
    # int =&gt; integer number
    # float =&gt; floating point number
    # string =&gt; declared with &quot;&quot; double quotation marks
    # char =&gt; declared with '' single quotation marks
    # bool =&gt; true, false
    # .type =&gt; returns the datatype of a given variable or constant
</code></pre>

<h2>Operators</h2>
<pre class="codehilite"><code class="language-nim"># ---------- OPERATOR ----------

# ARITHMETIC OPERATORS
    # + =&gt; addition
    # - =&gt; subtraction
    # * =&gt; multiplication
    # / =&gt; division
    # mod =&gt; modulo operator

# LOGICAL OPERATORS
    # and =&gt; logical and
    # or =&gt; logical or
    # not =&gt; logical not

# COMPARISON OPERATORS
    # == =&gt; complete equality check for value and type
    # != =&gt; complete inequality check for value and type
    # &gt; &lt; &gt;= &lt;= are also comparison operators
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-nim"># ---------- CONTROL STRUCTURE ----------

# CONDITIONALS

# IF ELIF ELSE

if 10 &gt; 5:
    echo (&quot;10 is larger than 5&quot;)
if &quot;Hello&quot; != &quot;Hello&quot;:
    echo (&quot;both strings are the same&quot;)
elif 27.123.type == true.type:
    echo (&quot;they have the same data type&quot;)
else:
    echo (&quot;none of the prior conditions met&quot;)

# CASE OF ELSE STATEMENT
    # else =&gt; functions as the default statement in the case of block

case a:
    of 0:
        echo (&quot;a is 0&quot;)
    of 1:
        echo (&quot;a is 1&quot;)
    of 2:
        echo (&quot;a is 2&quot;)
    else:
        echo (&quot;none of the previous conditions were met&quot;)

# RANGES
    # .. =&gt; creates an inclusive range on both ends that can be iterated over

echo (&quot;Enter a number: &quot;)
let userNumber = stdin.readLine().parseInt

case userNumber:
    of 0 .. 10:
        echo &quot;Your number is smaller than 10&quot;
    of 11 .. 100 
        echo &quot;Your number is from 11 to 100&quot;
    else:
        echo &quot;Your number is larger than a 100&quot;

# LOOPS

# FOR IN LOOPS
    # allows for iteration over an iterable data structure like an array or a range
    # .low =&gt; returns the lowest index within an iterable data structure
    # .high =&gt; returns the largest index within an iterable data structure

a: array[3, int] = [1, 2, 5]
for i in a:
    stdout.write(i) # this prints out 1, 2 and 5 to the stdout on the same line

for i in a.low .. a.high:
    stdout.write(a[i]) # this prints out 1, 2 and 5 to the stdout on the same line, achieved by referencing list elements by index

# WHILE LOOPS

while true:
    stdout.write(&quot;A&quot;) # an infinite loop since there is no break condition

var i = 0
while i &lt; 10:
    if i mod 2 == 0:
        echo (i) # this will only print out even numbers
</code></pre>

<h2>Data structures</h2>
<pre class="codehilite"><code class="language-nim"># ---------- DATA STRUCTURE ----------

# ARRAY
    # array[{SIZE OF ARRAY}, {ELEMENT TYPE}] =&gt; creates and declares a fixed-size ordered sequence of elements of the same type within [] square brackets
    # [..] =&gt; creates an inclusive range of indexes that can be used to slice an array

var testArray: array[3, int] = [1, 2, 3]
var anotherArray = [4.23, 5.00, 6.19] # the nim compiler can infer the data type of an array even without type annotations
var thelastArray: array[2, string]

var array1 = [0, 2, 4, 6, 8, 10]
echo (array1[0 .. 2]) # this will print out the sliced array, containing the integers 0, 2 and 4 to the stdout

# SEQUENCE
    # seq[{ELEMENT TYPE}] =&gt; creates and declares a dynamically-sized ordered sequence of elements of the same type within @[] at symbol and square brackets
    # .add() =&gt; appends a specified element to a sequence
    # .del() =&gt; deletes an element at a specified index from the sequence
    # .len() =&gt; returns the length of a specified sequence
    # [..] =&gt; creates an inclusive range of indexes that can be used to slice a sequence

var testSequence: seq[int] = @[1, 2, 3, 4, 5]
var anotherSequence = @[6.239, 7.432, 8.412, 9.312, 10.123] # the nim compiler can also infer the data type of sequences
var thelastSequence: seq[string]

var thefirstofAnotherSequence: seq[int] = @[1, 2, 3, 4]
thefirstofAnotherSequence.add(10) # this appends the int value 10 to the sequence
stdout.write(thefirstofAnotherSequence[4]) # this prints out the int 10 to the stdout

var yetanotherArray: seq[int] = @[1, 2, 3]
yetanotherArray.del(0) # this deletes the element of index 0 in the sequence
stdout.write(yetanotherArray[0]) # this prints out the number 2 to the stdout

var aSequence: seq[string] = @[&quot;aight bet&quot;, &quot;aigh beh&quot;, &quot;good morning&quot;, &quot;peepl&quot;]
echo aSequence.len() # this prints out 4, which is the length of the sequence above

var sequence1 = @[1, 3, 5, 7, 9]
echo (sequence1[0 .. 2]) # this prints out a sliced sequence containing the integers 1, 3 and 5 to the stdout

# TUPLE
    # tuple[{DATA TYPE OF EACH ELEMENT}] =&gt; creates and declares a named tuple, a fixed-size ordered sequence of key-value pairs of different types within () brackets, where the datatype of each key and value is specified within the [] square brackets, similar to dictionaries in Python
        # . =&gt; dot notation is used to access tuple values by their key
    # anonymous tuples are tuples with no named fields
    # () =&gt; creates and declares an anonymous tuple, a fixed-size ordered sequence of elements of different types within () brackets, where the datatype of each element is specified within the () brackets

var someTuple = (10, 0.55, &quot;hello&quot;, true)
var lastTuple: (string, int, bool, float) = (&quot;ok&quot;, 20, false, 30.21) # both of these are named tuples

var emptyTuple: tuple[name: string, age: int] # this will initialize an empty tuple with the fields name and age
var namedTuple: tuple[name: string, age: int] = (&quot;Adam&quot;, 100) # this creates a named tuple
echo(namedTuple.name) # this will print out the string &quot;Adam&quot; to the stdout
namedTuple.age = 421 # reassign the int value of 421 to the field age within the namedTuple tuple variable
echo(namedTuple.age) # this will now print out the integer 421 to the stdout

# TABLE
    # .toTable =&gt; declares and creates a dynamically-sized unordered sequence of key-value pairs within {} curly braces, similar to dictionaries in Python and tables in Lua
    # .toOrderedTable =&gt; declares and creates a dynamically-sized ordered sequence of key-value pairs within {} curly braces, similar to hashmaps in other languages
    # tables are brought into the present namespace using import tables

var ioTable = {&quot;output&quot;: stdout, &quot;input&quot;: stdin}.toTable # note that this table is just an example, just make a note of the .toTable() procedure
var romanDigits = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}.toOrderedTable

# TYPE
    # type =&gt; declares and creates a custom datatype that we can then specify as a variable or constant type, similar to structs in other languages

type 
    customTuple = tuple
        name: string
        age: int

var aTuple: customTuple = (&quot;Andrew&quot;, 3000) # this will automatically assign the value of string &quot;Andrew&quot; to the field name, and the integer 3000 to the field age
</code></pre>

<h2>Procedures</h2>
<pre class="codehilite"><code class="language-nim"># ---------- PROCEDURE ----------
    # nim procedures are the equivalent of functions in other programming languages
    # proc =&gt; declares and creates a procedure, with the procedure parameters and return type specified in the procedure definition
    # result =&gt; a special variable within a procedure that is returned automatically, similar to return but assigned to an explicit variable within the procedure
    # varargs[{ELEMENT TYPE}] =&gt; allows a procedure to receive a variable number of arguments of a specified type as an array

proc hello() = 
    echo (&quot;Hello world!&quot;) # procedures can be run purely for their side-effects

proc bet(): int = 
    return 2 

proc aight(): int = 
    result = 2 # these two procedures return the same thing

proc okLah(water: string): string = 
    result =  fmt&quot;{water} is ok&quot;

proc payLah(water: string): string = 
    return fmt&quot;{water} is ok&quot; # these two procedures also return the same thing

proc multiSum(numbers: varargs[int]): int=
    var sum: int
    for num in numbers:
        sum += num
    return sum # this procedure takes in a variable number of integers as arguments, which it reads as an array 
</code></pre>

<h2>More on</h2>
<ul>
<li>enum</li>
<li>procedure overloading</li>
<li>OOP</li>
<li><a href="https://nim-lang.org/install.html">install nim</a></li>
<li><a href="https://nim-lang.org/documentation.html">nim documentation</a></li>
<li><a href="https://learnxinyminutes.com/docs/nim/">learn nim in y minutes</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
