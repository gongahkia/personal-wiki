<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Lua - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Lua</h2>

        <dl>
          <dt>File size</dt>
          <dd>14.6KB</dd>

          <dt>Lines of code</dt>
          <dd>397</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Lua</code></h1>
<h2>Comments</h2>
<pre class="codehilite"><code class="language-lua">-- single-line comment

--[[ 
this is 
a 
multi-line
comment
]]--
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-lua">-- ---------- PRINTING ----------
    -- print() appends a newline to the output by default
    -- io.write() does not append a newline to the output
    -- io.read() takes in user input from the stdin
    -- .. for string concatenation

print(&quot;this is just like python, it comes with a newline&quot;)
io.write(&quot;this also works, defaults to the standard out\n&quot;)

watermelon = io.read(&quot;Waiting for your input lah: &quot;) -- assigns user input to the string variable watermelon

stringOne = &quot;Hello &quot;
stringTwo = &quot;World!&quot;

print(stringOne .. stringTwo) -- this prints &quot;Hello World!&quot; to the console
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-lua">-- ---------- VARIABLE ----------
    -- variables are global by default
    -- local makes them local

iAmGlobal = &quot;Gojo Satoru&quot;
local iAmLocal = &quot;Geto Suguru&quot;

-- ---------- TYPE ----------
    -- number (integers, floats, doubles)
    -- string (single, double-quoted, [[]] square brackets; strings are immutable like python)
    -- boolean (true, false; only nil and false evaluate to false, everything else evalautes to true including 0 and '')
    -- nil (no data; undefined variables evalaute to nil, no error is hit)

aNumber = 42
anotherNumber = 12.890
aString = &quot;watermelon&quot;
aMultilineString = [[ Double brackets for 
                      multi-line
                      string ]]
aBoolean = true
aNil = nil
foo = anUndefinedVariable -- this evaluates to nil and the program continues running

-- TYPE CONVERSION 

tostring() 
tonumber()
.. -- string concatenation have implicit type conversion from number to string, though for greater readability we try to avoid this as far as possible
+ - * / -- arithmetic operations have implicit type conversion from boolean to number, true =&gt; 1 and false =&gt; 0, though for greater readability we try to avoid implicit type conversions as far as possible
</code></pre>

<h2>Operators</h2>
<pre class="codehilite"><code class="language-lua">-- ---------- OPERATOR ----------

-- ARITHMETIC OPERATOR

+ -- addition
- -- subtraction
* -- multiplication
/ -- divison
% -- modulo
^ -- exponentiation (to the power of)

-- RELATIONAL OPERATOR

== -- complete equality check of type and value
~= -- complete inequality check of type and value
&lt; -- comparison operator
&gt; -- comparison operator
&lt;= -- comparison operator
&gt;= -- comparison operator

-- LOGICAL OPERATOR

and -- logical and
or -- logical or
not -- logical not
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-lua">-- ---------- BLOCK -----------
    -- lua takes a page from bash's syntax by seperating its code blocks with do/end and indentation 

-- ---------- IF ELSEIF ELSE THEN ----------
    -- standard conditionals
    -- there are no switch case statements in lua

if num &gt; 40 then 
    print(&quot;Over 40&quot;)
elseif num == 20 then
    print(&quot;It's 20&quot;)
else 
    print(&quot;Lovely&quot;)

-- ---------- LOOP ----------

-- FOR LOOP
    -- for {VARIABLE BEGINNING}, {VARIABLE END}, {STEP}
    -- ranges are inclusive on both ends

for i=10, 1, -1
do 
    print(i) -- prints 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 to the console
end

for q=1,100 do 
    print(q) -- prints the numbers 1 to 100 to the console
end

-- FOR IN LOOP
    -- useful when looping over iterable data structures

for key,value in pairs(aTable) 
do
    aTable[key] = &quot;i am jujutsu kaisen&quot;
end

-- WHILE LOOP
    -- while do loop

while num &lt; 50 do 
    num = num + 1
end

-- REPEAT UNTIL LOOP
    -- basically a do while loop

breakCase = 10
repeat
    print(&quot;watermelon&quot;)
    breakCase = breakCase - 1
until breakCase == 0
</code></pre>

<h2>Data structures</h2>
<pre class="codehilite"><code class="language-lua">-- --------- WARNING ---------
    -- indice count starts at 1 in lua, important for indexing

-- ---------- TABLE ----------
    -- lua's only data structure is the table, similar to PHP's associative arrays (both a dictionary and a list)
    -- initialised using {} curly braces
    -- table keys are string values by default so quotation marks are unnecessary
    -- table keys can also be non-string values, and are declared via literal notation
    -- table values can be accessed via . dot notation or [] square bracket notation
    -- can assign functions to a table, wherein the function name is the key and the function body is the value (using both named function / anonymous function syntax are valid)
    -- table functions are called using the same . dot notation as other table values

aTable = {key1 = &quot;value1&quot;, key2 = false}
print(aTable.key1) -- prints the value associated with the key key1 in aTable
aTable.key3 = 200 -- adds a new key value pair to aTable of key key3 and value 200
aTable.key2 = nil -- removes key2 from the table

anotherTable = {[&quot;@!#&quot;] = 'qbert', [{}] = 1729, [6.29] = &quot;tau&quot;} -- initialise a table with non-string non-nil keys
print(anotherTable[6.29]) -- prints the string value &quot;tau&quot;

-- ---------- TABLE FUNCTION ----------
    -- note either of the below 2 syntax are valid and achieve the same result

-- NAMED FUNCTION SYNTAX

function anotherTable.aFunction() 
    print(&quot;Hello from a function!&quot;)
end

anotherTable.aFunction() -- calls the table function, printing &quot;Hello from a function!&quot;

-- ANONYMOUS FUNCTION SYNTAX

anotherTable.anAnonFunction() = function() 
    print(&quot;Hello from an anonymous function!&quot;)
end

anotherTable.anAnonFunction() -- calls the table function similarly, printing &quot;Hello from an anonymous function!&quot;

-- ---------- TABLE 'LIST' ----------
    -- 'lists' are really just tables with implicit indice keys associated with each value upon initalisation
    -- # for length of table (number of key value pairs)

aListButActuallyATable = {&quot;value1&quot;, 'value2', 1.21, true}
print(#aListButActuallyATable) -- # returns the size of the table, this works on strings too
for i = 1, #aListButActuallyATable do  -- recall that indices start at 1 in lua
    print(v[i]) -- this syntax works since we're technically using tables with implicit indice keys 
end

-- ---------- GLOBAL TABLE ----------
    -- every lua program has a special _G global table that stores all global variables and functions (global functionality)
    -- _G is the table name, and it has similar functionality as every other table

aNumber = 42

function aFunction() 
    print(&quot;Hello my function!&quot;)
end

print(_G.aNumber) -- prints 42
_G.aFunction -- calls the function, printing &quot;Hello my function!&quot;
_G.aNewBoolean = true -- assigns the key aNewBoolean with value true to the global table, though this is not recommended unless explicitly necessary for the sake of producing readable code

-- ---------- METATABLE -----------
    -- metatables are tables that define and customise table behaviour
    -- setmetatable() sets a metamethod on a specified table, creating a metatable

-- ---------- METAMETHOD ----------
    -- functions that define specific operations on tables, lua has a set of predefined metamethods as below
    -- __add =&gt; define behaviour when adding 2 tables
    -- __sub =&gt; define behaviour when subtracting 2 tables
    -- __mul =&gt; define behaviour when multiplying 2 tables
    -- __div =&gt; define behaviour when dividing 2 tables
    -- __mod =&gt; define behaviour when calling modulo operator on 2 tables
    -- __pow =&gt; define behaviour when calling exponentiation operator on 2 tables
    -- __len =&gt; define behaviour when calling the # length operator on a table or string
    -- __unm =&gt; define behaviour when calling the unary minus operator in a table, used for negating a table
    -- __concat =&gt; define behaviour when calling concatenation operator on 2 tables
    -- __call =&gt; define behaviour when calling a table as a function
    -- __index =&gt; define a fallback method when accessing a table key that no longer exists
    -- __newindex =&gt; define behaviour when assigning a value to a table key that no longer exists
    -- __eq, __lt, __le =&gt; define behaviour for == equality, &lt; less than and &lt;= less than or equal to operators
    -- __tostring =&gt; define behaviour when converting a table to a string

-- attempting to simulate behaviour of fractions via tables
numeratorTable = {a = 1, b = 2}
denominatorTable = {a = 2, b = 3}

metaFraction = {} -- metaFraction is just another table for now

function metaFraction.__add(numeratorTable, denominatorTable) -- __add is the metamethod called on the metaFraction table to define behaviour when adding 2 tables together
    sum = {}
    sum.b = numeratorTable.b * denominatorTable.b
    sum.a = numeratorTable.a * denominatorTable.b + denominatorTable.a * numeratorTable.b
    return sum
end

setmetatable(numeratorTable, metaFraction) -- by pairing the table on which the metamethod __add is called with the 2 other tables, we prescribe behaviour and thus crete metatables using the setmetatable() function
setmetatable(denominatorTable, metaFraction)

newSum = numeratorTable + denominatorTable -- this now calls __add(numeratorTable, denominatorTable) on numeratorTable's metatable

-- ---------- CLASS-LIKE TABLE ----------
    -- lua has no built-in classes, though OOP behaviour can be simulated with tables and metatables
    -- function {TABLE NAME}:{FUNCTION NAME}() is the same as function {TABLE NAME}.{FUNCTION NAME}(self), the : just adds the self as the first argument 
    -- self works as you would expect it to in conventional OOP, so here aDog is an object and Dog is the class

Dog = {} -- Dog might act like a class, but remember its just a table with a metatable and metamethods prescribed on it

function Dog.new(self)
    newObject = {sound = &quot;Woof&quot;}
    self.__index = self
    return setmetatable(newObject, self)
end

function Dog.makeSound()
    print(&quot;I say&quot; .. self.sound)
end

aDog = Dog:new()
aDog:makeSound() -- &quot;I say Woof&quot;

-- ---------- INHERITANCE ----------
    -- inheritance can be simulated by creating a new table off the original table and assigning new methods to that table, which is then used as a template for further tables
    -- since we're effectively copying keys and values off the original table, the new table template 'inherits' the keys values and methods off the old table which aren't overriden
    -- remember that everything here is a table

loudDog = Dog:new()

function loudDog.makesound()
    sound = self.sound .. &quot; &quot;
    print(sound .. sound .. sound)
end

aSuperLoudDog = loudDog:new()
aSuperLoudDog:makesound() -- &quot;Woof Woof Woof &quot;
</code></pre>

<h2>Functions</h2>
<pre class="codehilite"><code class="language-lua">-- ---------- FUNCTIONS ----------
    -- function/end declares a function block
    -- return works as expected
    -- closures and anonymous functions are allowed
    -- functions are first-class and can be fed into other functions
    -- fuction scope can be specified using the local/global keyword

function fib(n)
    if n &lt; 2 then 
        return 1 
    end 
    return fib(n-2) + fib(n-1)
end

function adder(x)
    return function (y) return x + y end -- returns an anonymous function which retains the value of x
end
</code></pre>

<h2>Modules</h2>
<pre class="codehilite"><code class="language-lua">-- ---------- MODULE ----------
    -- require() allows for global functionality from the specified file to be brought into global scope of current file
        -- require()'s return values are cached so a file is only run ONCE even if require() is run multiple times
    -- dofile() is like require() but without caching, so a file is run EVERYTIME dofile() is run
    -- loadfile() loads a lua file into the variable but does not run it, the variable is called again as a function to have it run
    -- load() is loadfile() for strings, the variable is called again as a function to have it run
    -- local functionality that is only ever within local scope and never brought into global scope from the specified file will be treated as invisible and unretrievable
    -- functionality is called using . dot notation

-- eg. the below code is in seperate.lua

local M = {}

local function sayMyName() 
    print(&quot;You're Heisenberg&quot;)  
end

function M.sayHello()
    print(&quot;Why hello there&quot;)
    sayMyName()
end

return M

-- eg. the below code is in main.lua

local mod = require(&quot;seperate&quot;) -- require() brings in all globally scoped functionality from seperate.lua, accessed via the variable mod
mod.sayHello() -- prints &quot;Why hello thereYou're Heisenberg&quot;, because sayHello() is in the global scope and it brings in sayMyName() despite that being only within local scope in seperate.lua
mod.sayMyName() -- this FAILS because sayMyName() is in the local scope only
</code></pre>

<h2>More on</h2>
<ul>
<li><a href="https://learnxinyminutes.com/docs/lua/">learn lua in y minutes</a></li>
<li><a href="http://www.lua.org/pil/contents.html">lua book</a></li>
<li><a href="https://devhints.io/lua">lua cheatsheet</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
