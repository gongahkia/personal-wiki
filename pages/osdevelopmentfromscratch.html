<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: OS Development from scratch - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>OS Development from scratch</h2>

        <dl>
          <dt>File size</dt>
          <dd>111.9KB</dd>

          <dt>Lines of code</dt>
          <dd>937</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>OS Development from scratch</code></h1>
<p>Building an operating system kernel and associated components from the ground up to understand low-level system programming and computer architecture.</p>
<h2>Introduction</h2>
<ul>
<li><strong>Operating System Development</strong> involves creating the software layer between hardware and applications</li>
<li>Requires understanding of computer architecture, assembly language, and systems programming</li>
<li>Covers kernel development, device drivers, memory management, and process scheduling</li>
<li>Educational journey through fundamental computer science concepts</li>
<li>Provides deep insight into how modern operating systems function</li>
</ul>
<h2>Prerequisites and Setup</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- DEVELOPMENT ENVIRONMENT -----</span>
<span class="w">    </span><span class="c1">// Cross-compilation toolchain for target architecture</span>
<span class="w">    </span><span class="c1">// QEMU or VirtualBox for testing and debugging</span>
<span class="w">    </span><span class="c1">// Assembly language knowledge (x86/x86_64, ARM, RISC-V)</span>
<span class="w">    </span><span class="c1">// C programming with understanding of pointers and memory management</span>
<span class="w">    </span><span class="c1">// Basic understanding of computer architecture and digital logic</span>

<span class="c1">// TOOLCHAIN SETUP (x86_64 TARGET)</span>
<span class="w">    </span><span class="c1">// GCC cross-compiler for bare metal development</span>
<span class="w">    </span><span class="c1">// NASM or GAS assembler for assembly language code</span>
<span class="w">    </span><span class="c1">// LD linker for combining object files</span>
<span class="w">    </span><span class="c1">// GRUB bootloader for initial system loading</span>
<span class="w">    </span><span class="c1">// Make or CMake for build automation</span>

<span class="c1">// HOST OPERATING SYSTEM</span>
<span class="w">    </span><span class="c1">// Linux =&gt; best support for cross-compilation tools</span>
<span class="w">    </span><span class="c1">// macOS =&gt; possible with Homebrew and cross-compilation setup  </span>
<span class="w">    </span><span class="c1">// Windows =&gt; WSL or virtual machine recommended</span>
<span class="w">    </span><span class="c1">// Docker containers for consistent development environment</span>

<span class="c1">// ----- HARDWARE ARCHITECTURE BASICS -----</span>
<span class="w">    </span><span class="c1">// CPU registers, instruction sets, and execution modes</span>
<span class="w">    </span><span class="c1">// Memory hierarchy: registers, cache, RAM, storage</span>
<span class="w">    </span><span class="c1">// Interrupt handling and exception mechanisms</span>
<span class="w">    </span><span class="c1">// I/O ports, memory-mapped I/O, and device communication</span>
<span class="w">    </span><span class="c1">// Boot process: BIOS/UEFI, bootloader, kernel initialization</span>
</code></pre></div>

<h2>Boot Process and Initialization</h2>
<div class="codehilite"><pre><span></span><code><span class="c1"># ----- BOOTLOADER DEVELOPMENT -----</span>
<span class="w">    </span><span class="c1"># First code executed when computer starts</span>
<span class="w">    </span><span class="c1"># Loaded by BIOS/UEFI firmware into memory</span>
<span class="w">    </span><span class="c1"># Must fit in 512-byte boot sector (MBR) or be chainloaded</span>
<span class="w">    </span><span class="c1"># Switches CPU from real mode to protected mode</span>

<span class="c1"># BOOT SECTOR ASSEMBLY (x86)</span>
<span class="na">.code16</span><span class="w">                     </span><span class="c1"># 16-bit real mode</span>
<span class="na">.globl</span><span class="w"> </span><span class="no">_start</span>

<span class="nl">_start:</span>
<span class="w">    </span><span class="nf">cli</span><span class="w">                     </span><span class="c1"># Disable interrupts</span>
<span class="w">    </span><span class="nf">xor</span><span class="w"> </span><span class="nv">%ax</span><span class="p">,</span><span class="w"> </span><span class="nv">%ax</span><span class="w">           </span><span class="c1"># Clear AX register  </span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="nv">%ax</span><span class="p">,</span><span class="w"> </span><span class="nv">%ds</span><span class="w">           </span><span class="c1"># Set data segment</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="nv">%ax</span><span class="p">,</span><span class="w"> </span><span class="nv">%ss</span><span class="w">           </span><span class="c1"># Set stack segment</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">$0x7C00</span><span class="p">,</span><span class="w"> </span><span class="nv">%sp</span><span class="w">       </span><span class="c1"># Set stack pointer</span>

<span class="w">    </span><span class="c1"># Load kernel from disk</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">$0x02</span><span class="p">,</span><span class="w"> </span><span class="nv">%ah</span><span class="w">         </span><span class="c1"># BIOS read sector function</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">$1</span><span class="p">,</span><span class="w"> </span><span class="nv">%al</span><span class="w">            </span><span class="c1"># Number of sectors to read</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">$0x0000</span><span class="p">,</span><span class="w"> </span><span class="nv">%ch</span><span class="w">       </span><span class="c1"># Cylinder number</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">$0x02</span><span class="p">,</span><span class="w"> </span><span class="nv">%cl</span><span class="w">         </span><span class="c1"># Sector number (1-indexed)</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">$0x00</span><span class="p">,</span><span class="w"> </span><span class="nv">%dh</span><span class="w">         </span><span class="c1"># Head number</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">$0x80</span><span class="p">,</span><span class="w"> </span><span class="nv">%dl</span><span class="w">         </span><span class="c1"># Drive number (first hard disk)</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">$0x1000</span><span class="p">,</span><span class="w"> </span><span class="nv">%bx</span><span class="w">       </span><span class="c1"># Buffer address</span>
<span class="w">    </span><span class="nf">int</span><span class="w"> </span><span class="no">$0x13</span><span class="w">              </span><span class="c1"># BIOS interrupt</span>

<span class="w">    </span><span class="nf">jmp</span><span class="w"> </span><span class="mi">0x1000</span><span class="w">             </span><span class="c1"># Jump to loaded kernel</span>

<span class="c1"># ----- MODE SWITCHING -----</span>
<span class="w">    </span><span class="c1"># Real Mode =&gt; 16-bit, 1MB memory limit, BIOS services</span>
<span class="w">    </span><span class="c1"># Protected Mode =&gt; 32-bit, 4GB memory, memory protection</span>
<span class="w">    </span><span class="c1"># Long Mode =&gt; 64-bit, virtual memory, modern features</span>

<span class="c1"># PROTECTED MODE TRANSITION</span>
<span class="w">    </span><span class="c1"># Set up Global Descriptor Table (GDT)</span>
<span class="w">    </span><span class="c1"># Enable A20 line for extended memory access</span>
<span class="w">    </span><span class="c1"># Load GDT register and switch to protected mode</span>
<span class="w">    </span><span class="c1"># Update segment registers and jump to 32-bit code</span>

<span class="c1"># ----- MULTIBOOT SPECIFICATION -----</span>
<span class="w">    </span><span class="c1"># Standard interface between bootloader and kernel</span>
<span class="w">    </span><span class="c1"># GRUB bootloader support for automatic loading</span>
<span class="w">    </span><span class="c1"># Provides memory map and hardware information to kernel</span>
<span class="w">    </span><span class="c1"># Simplifies kernel development by handling low-level boot tasks</span>

<span class="na">.section</span><span class="w"> </span><span class="no">.multiboot</span>
<span class="na">.align</span><span class="w"> </span><span class="mi">4</span>
<span class="na">.long</span><span class="w"> </span><span class="mi">0x1BADB002</span><span class="w">          </span><span class="c1"># Multiboot magic number</span>
<span class="na">.long</span><span class="w"> </span><span class="mi">0x00000003</span><span class="w">          </span><span class="c1"># Multiboot flags  </span>
<span class="na">.long</span><span class="w"> </span><span class="p">-(</span><span class="mi">0x1BADB002</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">0x00000003</span><span class="p">)</span><span class="w">  </span><span class="c1"># Checksum</span>
</code></pre></div>

<h2>Memory Management</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- PHYSICAL MEMORY MANAGEMENT -----</span>
<span class="w">    </span><span class="c1">// Track available RAM using bitmap or free list</span>
<span class="w">    </span><span class="c1">// Page frame allocation and deallocation</span>
<span class="w">    </span><span class="c1">// Memory map provided by BIOS/bootloader</span>
<span class="w">    </span><span class="c1">// Handle reserved and ACPI regions</span>

<span class="k">class</span><span class="w"> </span><span class="nc">PhysicalMemoryManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="n">BitMap</span><span class="w"> </span><span class="n">usedFrames</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">totalMemory</span><span class="p">;</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">usedMemory</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">allocateFrame</span><span class="p">();</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">freeFrame</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">frame</span><span class="p">);</span>
<span class="w">        </span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">getAvailableMemory</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ----- VIRTUAL MEMORY MANAGEMENT -----</span>
<span class="w">    </span><span class="c1">// Paging enables virtual address spaces</span>
<span class="w">    </span><span class="c1">// Page tables map virtual to physical addresses</span>
<span class="w">    </span><span class="c1">// Memory protection and isolation between processes</span>
<span class="w">    </span><span class="c1">// Demand paging and page replacement algorithms</span>

<span class="c1">// x86_64 PAGE TABLE STRUCTURE</span>
<span class="w">    </span><span class="c1">// 4-level page table hierarchy (PML4, PDP, PD, PT)</span>
<span class="w">    </span><span class="c1">// Each entry contains physical address and flags</span>
<span class="w">    </span><span class="c1">// Present, Writable, User, No Execute bits</span>
<span class="w">    </span><span class="c1">// Translation Lookaside Buffer (TLB) caches mappings</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">PageTableEntry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">present</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">writable</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">writeThrough</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">cacheDisabled</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">accessed</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">dirty</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">reserved</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">40</span><span class="p">;</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="n">Physical</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">12</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">reserved2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">11</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">noExecute</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ----- HEAP MANAGEMENT -----</span>
<span class="w">    </span><span class="c1">// Dynamic memory allocation for kernel and user programs</span>
<span class="w">    </span><span class="c1">// malloc/free implementation with coalescing</span>
<span class="w">    </span><span class="c1">// Slab allocator for fixed-size objects</span>
<span class="w">    </span><span class="c1">// Buddy system for efficient fragmentation handling</span>

<span class="k">class</span><span class="w"> </span><span class="nc">HeapManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">FreeBlock</span><span class="o">*</span><span class="w"> </span><span class="n">freeList</span><span class="p">;</span>
<span class="w">        </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">heapStart</span><span class="p">;</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">heapSize</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">coalesceBlocks</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div>

<h2>Process Management</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- PROCESS CONTROL BLOCK -----</span>
<span class="w">    </span><span class="c1">// Data structure containing process state information</span>
<span class="w">    </span><span class="c1">// CPU registers, memory mappings, file descriptors</span>
<span class="w">    </span><span class="c1">// Process ID, parent ID, priority, scheduling info</span>
<span class="w">    </span><span class="c1">// Signal handlers and inter-process communication data</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">ProcessControlBlock</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ProcessID</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>
<span class="w">    </span><span class="n">ProcessID</span><span class="w"> </span><span class="n">parentPid</span><span class="p">;</span>
<span class="w">    </span><span class="n">ProcessState</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="n">CPUContext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w">      </span><span class="c1">// Saved CPU registers</span>
<span class="w">    </span><span class="n">AddressSpace</span><span class="o">*</span><span class="w"> </span><span class="n">addressSpace</span><span class="p">;</span>
<span class="w">    </span><span class="n">FileDescriptor</span><span class="o">*</span><span class="w"> </span><span class="n">files</span><span class="p">;</span>
<span class="w">    </span><span class="n">SignalHandler</span><span class="o">*</span><span class="w"> </span><span class="n">signals</span><span class="p">;</span>
<span class="w">    </span><span class="n">Priority</span><span class="w"> </span><span class="n">priority</span><span class="p">;</span>
<span class="w">    </span><span class="n">TimeSlice</span><span class="w"> </span><span class="n">timeSlice</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// PROCESS STATES</span>
<span class="w">    </span><span class="c1">// NEW =&gt; process being created</span>
<span class="w">    </span><span class="c1">// READY =&gt; waiting to be scheduled</span>
<span class="w">    </span><span class="c1">// RUNNING =&gt; currently executing on CPU</span>
<span class="w">    </span><span class="c1">// BLOCKED =&gt; waiting for I/O or event</span>
<span class="w">    </span><span class="c1">// TERMINATED =&gt; process finished execution</span>

<span class="c1">// ----- CONTEXT SWITCHING -----</span>
<span class="w">    </span><span class="c1">// Save current process state to PCB</span>
<span class="w">    </span><span class="c1">// Load next process state from PCB</span>
<span class="w">    </span><span class="c1">// Switch address spaces (page table)</span>
<span class="w">    </span><span class="c1">// Update CPU registers and jump to new process</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">contextSwitch</span><span class="p">(</span><span class="n">Process</span><span class="o">*</span><span class="w"> </span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">Process</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Save current process context</span>
<span class="w">    </span><span class="n">saveRegisters</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
<span class="w">    </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READY</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Load next process context  </span>
<span class="w">    </span><span class="n">loadAddressSpace</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">addressSpace</span><span class="p">);</span>
<span class="w">    </span><span class="n">loadRegisters</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
<span class="w">    </span><span class="n">next</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RUNNING</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Jump to next process</span>
<span class="w">    </span><span class="n">jumpToProcess</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ----- PROCESS SCHEDULING -----</span>
<span class="w">    </span><span class="c1">// Decide which process to run next</span>
<span class="w">    </span><span class="c1">// Balance fairness, responsiveness, and efficiency</span>
<span class="w">    </span><span class="c1">// Preemptive vs cooperative scheduling</span>
<span class="w">    </span><span class="c1">// Real-time scheduling for time-critical tasks</span>

<span class="c1">// ROUND ROBIN SCHEDULER</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RoundRobinScheduler</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">Queue</span><span class="w"> </span><span class="n">readyQueue</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeQuantum</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">Process</span><span class="o">*</span><span class="w"> </span><span class="n">selectNextProcess</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">readyQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">            </span><span class="n">Process</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readyQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
<span class="w">            </span><span class="n">readyQueue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">            </span><span class="n">readyQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">next</span><span class="p">);</span><span class="w">  </span><span class="c1">// Move to back of queue</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">addProcess</span><span class="p">(</span><span class="n">Process</span><span class="o">*</span><span class="w"> </span><span class="n">process</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">readyQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">process</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ----- SYSTEM CALLS -----</span>
<span class="w">    </span><span class="c1">// Interface between user programs and kernel</span>
<span class="w">    </span><span class="c1">// Controlled entry points for privileged operations</span>
<span class="w">    </span><span class="c1">// Parameter passing via registers or stack</span>
<span class="w">    </span><span class="c1">// Return values and error codes</span>

<span class="c1">// System call numbers</span>
<span class="cp">#define SYS_EXIT    1</span>
<span class="cp">#define SYS_READ    3</span>
<span class="cp">#define SYS_WRITE   4</span>
<span class="cp">#define SYS_OPEN    5</span>
<span class="cp">#define SYS_CLOSE   6</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">syscallHandler</span><span class="p">(</span><span class="n">CPUContext</span><span class="o">*</span><span class="w"> </span><span class="n">context</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">syscallNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">rax</span><span class="p">;</span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">syscallNumber</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">SYS_WRITE</span><span class="p">:</span>
<span class="w">            </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">rax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sysWrite</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">rdi</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">rsi</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">rdx</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">SYS_READ</span><span class="p">:</span>
<span class="w">            </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">rax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sysRead</span><span class="p">(</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">rdi</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">rsi</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">rdx</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span>
<span class="w">            </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">rax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">  </span><span class="c1">// Invalid system call</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h2>Interrupt Handling</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- INTERRUPT DESCRIPTOR TABLE (IDT) -----</span>
<span class="w">    </span><span class="c1">// Table of interrupt and exception handlers</span>
<span class="w">    </span><span class="c1">// Hardware interrupts from devices (keyboard, timer, disk)</span>
<span class="w">    </span><span class="c1">// Software interrupts for system calls</span>
<span class="w">    </span><span class="c1">// CPU exceptions (page fault, divide by zero, illegal instruction)</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">IDTEntry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">offsetLow</span><span class="p">;</span><span class="w">     </span><span class="c1">// Handler address bits 0-15</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">selector</span><span class="p">;</span><span class="w">      </span><span class="c1">// Code segment selector</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ist</span><span class="p">;</span><span class="w">           </span><span class="c1">// Interrupt Stack Table index</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">attributes</span><span class="p">;</span><span class="w">     </span><span class="c1">// Gate type and privilege level</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">offsetMiddle</span><span class="p">;</span><span class="w">  </span><span class="c1">// Handler address bits 16-31</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">offsetHigh</span><span class="p">;</span><span class="w">    </span><span class="c1">// Handler address bits 32-63</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">reserved</span><span class="p">;</span><span class="w">      </span><span class="c1">// Must be zero</span>
<span class="p">};</span>

<span class="c1">// IDT SETUP</span>
<span class="k">class</span><span class="w"> </span><span class="nc">InterruptManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">IDTEntry</span><span class="w"> </span><span class="n">idt</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">installHandler</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">vector</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)());</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">enableInterrupts</span><span class="p">();</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">disableInterrupts</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// ----- INTERRUPT CATEGORIES -----</span>

<span class="c1">// HARDWARE INTERRUPTS (IRQ)</span>
<span class="w">    </span><span class="c1">// Timer (IRQ 0) =&gt; system clock, preemptive scheduling</span>
<span class="w">    </span><span class="c1">// Keyboard (IRQ 1) =&gt; user input handling</span>
<span class="w">    </span><span class="c1">// Mouse (IRQ 12) =&gt; pointer device input</span>
<span class="w">    </span><span class="c1">// Hard Disk (IRQ 14/15) =&gt; storage device completion</span>
<span class="w">    </span><span class="c1">// Network Card =&gt; packet receive/transmit notifications</span>

<span class="c1">// CPU EXCEPTIONS</span>
<span class="w">    </span><span class="c1">// Page Fault (14) =&gt; memory access violation</span>
<span class="w">    </span><span class="c1">// General Protection Fault (13) =&gt; privilege violation</span>
<span class="w">    </span><span class="c1">// Divide by Zero (0) =&gt; arithmetic error</span>
<span class="w">    </span><span class="c1">// Invalid Opcode (6) =&gt; illegal instruction</span>
<span class="w">    </span><span class="c1">// Stack Fault (12) =&gt; stack segment issues</span>

<span class="c1">// SOFTWARE INTERRUPTS</span>
<span class="w">    </span><span class="c1">// System Call (0x80 or SYSCALL instruction)</span>
<span class="w">    </span><span class="c1">// User-defined interrupts for IPC</span>
<span class="w">    </span><span class="c1">// Debugging breakpoints and traps</span>

<span class="c1">// ----- INTERRUPT HANDLING FLOW -----</span>
<span class="w">    </span><span class="c1">// CPU saves current state on stack</span>
<span class="w">    </span><span class="c1">// IDT lookup determines handler address</span>
<span class="w">    </span><span class="c1">// Switch to kernel mode and jump to handler</span>
<span class="w">    </span><span class="c1">// Handler processes interrupt and signals completion</span>
<span class="w">    </span><span class="c1">// Return to interrupted code with IRET instruction</span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">timerInterruptHandler</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Acknowledge interrupt to PIC</span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Update system timer</span>
<span class="w">    </span><span class="n">systemTicks</span><span class="o">++</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Preemptive scheduling check</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">currentProcess</span><span class="o">-&gt;</span><span class="n">timeSlice</span><span class="w"> </span><span class="n">scheduleNext</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ----- PROGRAMMABLE INTERRUPT CONTROLLER (PIC) -----</span>
<span class="w">    </span><span class="c1">// 8259 PIC manages hardware interrupt routing</span>
<span class="w">    </span><span class="c1">// Master PIC handles IRQ 0-7</span>
<span class="w">    </span><span class="c1">// Slave PIC handles IRQ 8-15</span>
<span class="w">    </span><span class="c1">// Interrupt masking and priority handling</span>
<span class="w">    </span><span class="c1">// Modern systems use Advanced PIC (APIC)</span>

<span class="kt">void</span><span class="w"> </span><span class="n">initializePIC</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Remap PIC vectors to avoid conflicts</span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span><span class="w"> </span><span class="mh">0x11</span><span class="p">);</span><span class="w">  </span><span class="c1">// Initialize command to master PIC</span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="mh">0xA0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x11</span><span class="p">);</span><span class="w">  </span><span class="c1">// Initialize command to slave PIC</span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="mh">0x21</span><span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">);</span><span class="w">  </span><span class="c1">// Master PIC vector offset (32)</span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="mh">0xA1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x28</span><span class="p">);</span><span class="w">  </span><span class="c1">// Slave PIC vector offset (40)</span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="mh">0x21</span><span class="p">,</span><span class="w"> </span><span class="mh">0x04</span><span class="p">);</span><span class="w">  </span><span class="c1">// Tell master PIC about slave</span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="mh">0xA1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x02</span><span class="p">);</span><span class="w">  </span><span class="c1">// Tell slave PIC about master</span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="mh">0x21</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">);</span><span class="w">  </span><span class="c1">// Enable 8086 mode</span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="mh">0xA1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">);</span><span class="w">  </span><span class="c1">// Enable 8086 mode</span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="mh">0x21</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">);</span><span class="w">  </span><span class="c1">// Unmask all interrupts</span>
<span class="w">    </span><span class="n">outb</span><span class="p">(</span><span class="mh">0xA1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">);</span><span class="w">  </span><span class="c1">// Unmask all interrupts</span>
<span class="p">}</span>
</code></pre></div>

<h2>Device Drivers</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- DRIVER ARCHITECTURE -----</span>
<span class="w">    </span><span class="c1">// Abstraction layer between kernel and hardware</span>
<span class="w">    </span><span class="c1">// Device-specific code isolated from kernel core</span>
<span class="w">    </span><span class="c1">// Standard interface for similar device types</span>
<span class="w">    </span><span class="c1">// Plug-and-play support and hot-swapping</span>

<span class="k">class</span><span class="w"> </span><span class="nc">DeviceDriver</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">protected</span><span class="o">:</span>
<span class="w">        </span><span class="n">DeviceType</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">baseAddress</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">irq</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">initialize</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">handleInterrupt</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ----- KEYBOARD DRIVER -----</span>
<span class="w">    </span><span class="c1">// PS/2 keyboard controller interface</span>
<span class="w">    </span><span class="c1">// Scan code translation to ASCII</span>
<span class="w">    </span><span class="c1">// Modifier key handling (Shift, Ctrl, Alt)</span>
<span class="w">    </span><span class="c1">// Key repeat and debouncing</span>

<span class="k">class</span><span class="w"> </span><span class="nc">KeyboardDriver</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">DeviceDriver</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">modifierState</span><span class="p">;</span>
<span class="w">        </span><span class="n">CircularBuffer</span><span class="w"> </span><span class="n">keyBuffer</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">handleInterrupt</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">scanCode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inb</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
<span class="w">            </span><span class="n">KeyEvent</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translateScanCode</span><span class="p">(</span><span class="n">scanCode</span><span class="p">);</span>
<span class="w">            </span><span class="n">keyBuffer</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">KeyEvent</span><span class="w"> </span><span class="n">getNextKey</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">keyBuffer</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ----- STORAGE DRIVER -----</span>
<span class="w">    </span><span class="c1">// ATA/SATA hard disk interface</span>
<span class="w">    </span><span class="c1">// Sector-based read/write operations</span>
<span class="w">    </span><span class="c1">// DMA transfers for performance</span>
<span class="w">    </span><span class="c1">// Error handling and retry logic</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ATADriver</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">DeviceDriver</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">ioBase</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">isDMA</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">readSector</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lba</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Send read command to drive</span>
<span class="w">            </span><span class="n">outb</span><span class="p">(</span><span class="n">ioBase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mh">0xE0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">((</span><span class="n">lba</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">));</span>
<span class="w">            </span><span class="n">outb</span><span class="p">(</span><span class="n">ioBase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// Sector count</span>
<span class="w">            </span><span class="n">outb</span><span class="p">(</span><span class="n">ioBase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">lba</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">);</span>
<span class="w">            </span><span class="n">outb</span><span class="p">(</span><span class="n">ioBase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">);</span>
<span class="w">            </span><span class="n">outb</span><span class="p">(</span><span class="n">ioBase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">lba</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">);</span>
<span class="w">            </span><span class="n">outb</span><span class="p">(</span><span class="n">ioBase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">);</span><span class="w">  </span><span class="c1">// Read sectors command</span>

<span class="w">            </span><span class="c1">// Wait for drive ready</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">ioBase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x08</span><span class="p">));</span>

<span class="w">            </span><span class="c1">// Read data</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="w">            </span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// Configure DMA and start transmission</span>
<span class="w">            </span><span class="n">configureTransmitDMA</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="w">            </span><span class="n">triggerTransmission</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">handleInterrupt</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readInterruptStatus</span><span class="p">();</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">RX_COMPLETE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">processReceivedPackets</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">TX_COMPLETE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">releaseTransmitBuffers</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h2>File System</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- FILE SYSTEM INTERFACE -----</span>
<span class="w">    </span><span class="c1">// Virtual File System (VFS) abstraction</span>
<span class="w">    </span><span class="c1">// Multiple file system support (FAT32, ext2/3/4, NTFS)</span>
<span class="w">    </span><span class="c1">// File and directory operations</span>
<span class="w">    </span><span class="c1">// Metadata management and permissions</span>

<span class="k">class</span><span class="w"> </span><span class="nc">VirtualFileSystem</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">Map</span><span class="w"> </span><span class="n">mountPoints</span><span class="p">;</span>
<span class="w">        </span><span class="n">FileDescriptorTable</span><span class="w"> </span><span class="n">fdTable</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">);</span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nf">mkdir</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="kt">mode_t</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nf">rmdir</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">path</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// ----- FAT32 FILE SYSTEM -----</span>
<span class="w">    </span><span class="c1">// Microsoft&#39;s FAT32 file system implementation</span>
<span class="w">    </span><span class="c1">// File Allocation Table for cluster management</span>
<span class="w">    </span><span class="c1">// Long filename support and directory entries</span>
<span class="w">    </span><span class="c1">// Compatible with Windows and other operating systems</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FAT32FileSystem</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">FileSystem</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">FAT32BootSector</span><span class="w"> </span><span class="n">bootSector</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="o">*</span><span class="w"> </span><span class="n">fileAllocationTable</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">rootDirectoryCluster</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">File</span><span class="o">*</span><span class="w"> </span><span class="n">openFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">DirectoryEntry</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">findDirectoryEntry</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FAT32File</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">startCluster</span><span class="p">,</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="n">fileSize</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">getNextCluster</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">cluster</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">fileAllocationTable</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0FFFFFFF</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ----- INODE-BASED FILE SYSTEM -----</span>
<span class="w">    </span><span class="c1">// Unix-style file system with inodes</span>
<span class="w">    </span><span class="c1">// Efficient metadata storage and access</span>
<span class="w">    </span><span class="c1">// Hard links and symbolic links support</span>
<span class="w">    </span><span class="c1">// Journaling for crash recovery</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mode</span><span class="p">;</span><span class="w">          </span><span class="c1">// File type and permissions</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">uid</span><span class="p">;</span><span class="w">           </span><span class="c1">// User ID</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">gid</span><span class="p">;</span><span class="w">           </span><span class="c1">// Group ID</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">          </span><span class="c1">// File size in bytes</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">atime</span><span class="p">;</span><span class="w">         </span><span class="c1">// Access time</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ctime</span><span class="p">;</span><span class="w">         </span><span class="c1">// Change time</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mtime</span><span class="p">;</span><span class="w">         </span><span class="c1">// Modification time</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">blocks</span><span class="p">;</span><span class="w">    </span><span class="c1">// Direct and indirect block pointers[1]</span>
<span class="p">};</span>

<span class="c1">// ----- BUFFER CACHE -----</span>
<span class="w">    </span><span class="c1">// Cache frequently accessed disk blocks</span>
<span class="w">    </span><span class="c1">// Write-back and write-through policies</span>
<span class="w">    </span><span class="c1">// LRU replacement algorithm</span>
<span class="w">    </span><span class="c1">// Dirty block tracking and flushing</span>

<span class="k">class</span><span class="w"> </span><span class="nc">BufferCache</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">Map</span><span class="w"> </span><span class="n">cache</span><span class="p">;</span>
<span class="w">        </span><span class="n">LRUList</span><span class="w"> </span><span class="n">lruList</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">CacheEntry</span><span class="o">*</span><span class="w"> </span><span class="n">getBlock</span><span class="p">(</span><span class="n">BlockID</span><span class="w"> </span><span class="n">block</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cache</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cache</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">lruList</span><span class="p">.</span><span class="n">moveToFront</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// Cache miss - load from disk</span>
<span class="w">            </span><span class="n">CacheEntry</span><span class="o">*</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">loadFromDisk</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
<span class="w">            </span><span class="n">insertIntoCache</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">entry</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">entry</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">flushDirtyBlocks</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">cache</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">isDirty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">writeToDisk</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="w">                    </span><span class="n">entry</span><span class="p">.</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">isDirty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h2>User Space and System Services</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- USER SPACE PROGRAMS -----</span>
<span class="w">    </span><span class="c1">// ELF executable loading and execution</span>
<span class="w">    </span><span class="c1">// Dynamic linking and shared libraries</span>
<span class="w">    </span><span class="c1">// Process creation (fork/exec) and termination</span>
<span class="w">    </span><span class="c1">// Standard C library implementation</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ELFLoader</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">ELF64Header</span><span class="o">*</span><span class="w"> </span><span class="n">elfHeader</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">ELF64ProgramHeader</span><span class="o">*</span><span class="w"> </span><span class="n">programHeaders</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">Process</span><span class="o">*</span><span class="w"> </span><span class="n">loadExecutable</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">File</span><span class="o">*</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vfs</span><span class="o">-&gt;</span><span class="n">openFile</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="w">            </span><span class="n">elfHeader</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ELF64Header</span><span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ELF64Header</span><span class="p">));</span>

<span class="w">            </span><span class="c1">// Verify ELF signature</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">elfHeader</span><span class="o">-&gt;</span><span class="n">signature</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ELF_SIGNATURE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// Create new process</span>
<span class="w">            </span><span class="n">Process</span><span class="o">*</span><span class="w"> </span><span class="n">process</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Process</span><span class="p">();</span>
<span class="w">            </span><span class="n">process</span><span class="o">-&gt;</span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createAddressSpace</span><span class="p">();</span>

<span class="w">            </span><span class="c1">// Load program segments</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">phnum</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">loadProgramSegment</span><span class="p">(</span><span class="o">&amp;</span><span class="n">programHeaders</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">process</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// Set entry point</span>
<span class="w">            </span><span class="n">process</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">rip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elfHeader</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">process</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ----- SHELL IMPLEMENTATION -----</span>
<span class="w">    </span><span class="c1">// Command-line interface for user interaction</span>
<span class="w">    </span><span class="c1">// Command parsing and execution</span>
<span class="w">    </span><span class="c1">// Built-in commands and external programs</span>
<span class="w">    </span><span class="c1">// I/O redirection and pipes</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Shell</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">commandBuffer</span><span class="p">;</span>
<span class="w">        </span><span class="n">Map</span><span class="w"> </span><span class="n">builtins</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;$ &quot;</span><span class="p">);</span>
<span class="w">                </span><span class="n">readLine</span><span class="p">(</span><span class="n">commandBuffer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">commandBuffer</span><span class="p">));</span>

<span class="w">                </span><span class="n">Command</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parseCommand</span><span class="p">(</span><span class="n">commandBuffer</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isBuiltin</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">name</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">executeBuiltin</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">executeProgram</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">executeProgram</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Command</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cmd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Process</span><span class="o">*</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="p">();</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// Child process</span>
<span class="w">                </span><span class="n">exec</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">cmd</span><span class="p">.</span><span class="n">args</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// Parent process</span>
<span class="w">                </span><span class="n">waitpid</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ----- INTER-PROCESS COMMUNICATION -----</span>
<span class="w">    </span><span class="c1">// Message passing between processes</span>
<span class="w">    </span><span class="c1">// Shared memory segments</span>
<span class="w">    </span><span class="c1">// Semaphores and mutexes</span>
<span class="w">    </span><span class="c1">// Named pipes and sockets</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MessageQueue</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">Queue</span><span class="w"> </span><span class="n">messages</span><span class="p">;</span>
<span class="w">        </span><span class="n">Semaphore</span><span class="w"> </span><span class="n">semaphore</span><span class="p">;</span>
<span class="w">        </span><span class="n">Mutex</span><span class="w"> </span><span class="n">mutex</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Message</span><span class="o">&amp;</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">            </span><span class="n">messages</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="w">            </span><span class="n">semaphore</span><span class="p">.</span><span class="n">signal</span><span class="p">();</span>
<span class="w">            </span><span class="n">mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">Message</span><span class="w"> </span><span class="n">receive</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">semaphore</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
<span class="w">            </span><span class="n">mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">            </span><span class="n">Message</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">messages</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
<span class="w">            </span><span class="n">messages</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">            </span><span class="n">mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">msg</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ----- SYSTEM SERVICES -----</span>
<span class="w">    </span><span class="c1">// Device manager for hardware abstraction</span>
<span class="w">    </span><span class="c1">// Network stack (TCP/IP implementation)</span>
<span class="w">    </span><span class="c1">// Security and access control</span>
<span class="w">    </span><span class="c1">// Time and date services</span>

<span class="k">class</span><span class="w"> </span><span class="nc">DeviceManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">Map</span><span class="w"> </span><span class="n">drivers</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">registerDriver</span><span class="p">(</span><span class="n">DeviceID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">DeviceDriver</span><span class="o">*</span><span class="w"> </span><span class="n">driver</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">drivers</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">driver</span><span class="p">;</span>
<span class="w">            </span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">deviceOpen</span><span class="p">(</span><span class="n">DeviceID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">drivers</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">drivers</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">  </span><span class="c1">// Device not found</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h2>Debugging and Testing</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- KERNEL DEBUGGING -----</span>
<span class="w">    </span><span class="c1">// Serial port output for debug messages</span>
<span class="w">    </span><span class="c1">// Kernel panic and stack trace generation</span>
<span class="w">    </span><span class="c1">// Memory corruption detection</span>
<span class="w">    </span><span class="c1">// Assertion macros for validation</span>

<span class="cp">#define ASSERT(condition) \</span>
<span class="cp">    if (!(condition)) { \</span>
<span class="cp">        kprintf(&quot;ASSERTION FAILED: %s:%d %s\n&quot;, __FILE__, __LINE__, #condition); \</span>
<span class="cp">        kernelPanic(&quot;Assertion failed&quot;); \</span>
<span class="cp">    }</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">kprintf</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">va_list</span><span class="w"> </span><span class="n">args</span><span class="p">;</span>
<span class="w">    </span><span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">format</span><span class="p">);</span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span>
<span class="w">    </span><span class="n">vsprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">format</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Output to serial port for debugging</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">serialWrite</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">kernelPanic</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">disableInterrupts</span><span class="p">();</span>
<span class="w">    </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;KERNEL PANIC: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="p">);</span>
<span class="w">    </span><span class="n">printStackTrace</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Halt the system</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">halt</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ----- UNIT TESTING -----</span>
<span class="w">    </span><span class="c1">// Test framework for kernel components</span>
<span class="w">    </span><span class="c1">// Mock objects for hardware interfaces</span>
<span class="w">    </span><span class="c1">// Automated test suites</span>
<span class="w">    </span><span class="c1">// Coverage analysis tools</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TestFramework</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">testsRun</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">testsPassed</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">testsFailed</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">runTest</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">testFunc</span><span class="p">)())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">testsRun</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">testFunc</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;PASS: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="w">                </span><span class="n">testsPassed</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;FAIL: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="w">                </span><span class="n">testsFailed</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">printResults</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;Tests run: %d, Passed: %d, Failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">                    </span><span class="n">testsRun</span><span class="p">,</span><span class="w"> </span><span class="n">testsPassed</span><span class="p">,</span><span class="w"> </span><span class="n">testsFailed</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ----- SYSTEM TESTING -----</span>
<span class="w">    </span><span class="c1">// Boot testing in virtual machines</span>
<span class="w">    </span><span class="c1">// Stress testing with heavy workloads</span>
<span class="w">    </span><span class="c1">// Hardware compatibility testing</span>
<span class="w">    </span><span class="c1">// Performance benchmarking</span>

<span class="c1">// Memory allocation stress test</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">testMemoryAllocation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numAllocs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptrs</span><span class="p">[</span><span class="n">numAllocs</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Allocate memory blocks</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w">  </span><span class="n">profiles</span><span class="p">);</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">profileFunction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">duration</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ProfileData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">profiles</span><span class="p">[</span><span class="n">name</span><span class="p">];</span>
<span class="w">            </span><span class="n">data</span><span class="p">.</span><span class="n">functionCalls</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">data</span><span class="p">.</span><span class="n">totalTime</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">duration</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">duration</span><span class="w">  </span><span class="n">data</span><span class="p">.</span><span class="n">maxTime</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">data</span><span class="p">.</span><span class="n">maxTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">duration</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">printProfile</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">profiles</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;%s: calls=%lu, avg=%lu, min=%lu, max=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">                        </span><span class="n">entry</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span>
<span class="w">                        </span><span class="n">entry</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">functionCalls</span><span class="p">,</span>
<span class="w">                        </span><span class="n">entry</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">totalTime</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">functionCalls</span><span class="p">,</span>
<span class="w">                        </span><span class="n">entry</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">minTime</span><span class="p">,</span>
<span class="w">                        </span><span class="n">entry</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">maxTime</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h2>Advanced Topics</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- MULTIPROCESSOR SUPPORT (SMP) -----</span>
<span class="w">    </span><span class="c1">// CPU detection and initialization</span>
<span class="w">    </span><span class="c1">// Inter-processor interrupts (IPIs)</span>
<span class="w">    </span><span class="c1">// Per-CPU data structures</span>
<span class="w">    </span><span class="c1">// CPU load balancing</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SMPManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">CPU</span><span class="o">*</span><span class="w"> </span><span class="n">cpus</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numCPUs</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">initializeCPUs</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Detect available CPUs</span>
<span class="w">            </span><span class="n">numCPUs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">detectCPUCount</span><span class="p">();</span>
<span class="w">            </span><span class="n">cpus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CPU</span><span class="p">[</span><span class="n">numCPUs</span><span class="p">];</span>

<span class="w">            </span><span class="c1">// Start application processors</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">addressSpace</span><span class="o">-&gt;</span><span class="n">heapBase</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">randomOffset</span><span class="p">;</span>
<span class="w">            </span><span class="n">process</span><span class="o">-&gt;</span><span class="n">addressSpace</span><span class="o">-&gt;</span><span class="n">stackBase</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">randomOffset</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">verifyCodeSignature</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">code</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Verify digital signature</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">cryptoVerify</span><span class="p">(</span><span class="n">code</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">publicKey</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ----- POWER MANAGEMENT -----</span>
<span class="w">    </span><span class="c1">// CPU frequency scaling</span>
<span class="w">    </span><span class="c1">// Device power states</span>
<span class="w">    </span><span class="c1">// Sleep and hibernation</span>
<span class="w">    </span><span class="c1">// Battery monitoring</span>

<span class="k">class</span><span class="w"> </span><span class="nc">PowerManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">PowerState</span><span class="w"> </span><span class="n">currentState</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">setCPUFrequency</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">percentage</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">msr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readMSR</span><span class="p">(</span><span class="n">IA32_PERF_CTL</span><span class="p">);</span>
<span class="w">            </span><span class="n">msr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">msr</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mh">0xFFFF</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">percentage</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0xFFFF</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="w">            </span><span class="n">writeMSR</span><span class="p">(</span><span class="n">IA32_PERF_CTL</span><span class="p">,</span><span class="w"> </span><span class="n">msr</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">enterSleepState</span><span class="p">(</span><span class="n">SleepState</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Save system state</span>
<span class="w">            </span><span class="n">saveProcessorState</span><span class="p">();</span>
<span class="w">            </span><span class="n">saveDeviceStates</span><span class="p">();</span>

<span class="w">            </span><span class="c1">// Enter sleep mode</span>
<span class="w">            </span><span class="n">acpiEnterSleepState</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ----- VIRTUALIZATION SUPPORT -----</span>
<span class="w">    </span><span class="c1">// Hardware-assisted virtualization (Intel VT-x, AMD-V)</span>
<span class="w">    </span><span class="c1">// Hypervisor implementation</span>
<span class="w">    </span><span class="c1">// Guest operating system isolation</span>
<span class="w">    </span><span class="c1">// Virtual device interfaces</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Hypervisor</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">VirtualMachine</span><span class="o">*</span><span class="w"> </span><span class="n">guests</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numGuests</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">VirtualMachine</span><span class="o">*</span><span class="w"> </span><span class="n">createGuest</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">VirtualMachine</span><span class="o">*</span><span class="w"> </span><span class="n">guest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">VirtualMachine</span><span class="p">();</span>

<span class="w">            </span><span class="c1">// Set up VMCS (Virtual Machine Control Structure)</span>
<span class="w">            </span><span class="n">setupVMCS</span><span class="p">(</span><span class="n">guest</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// Configure virtual devices</span>
<span class="w">            </span><span class="n">guest</span><span class="o">-&gt;</span><span class="n">virtualCPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">VirtualCPU</span><span class="p">();</span>
<span class="w">            </span><span class="n">guest</span><span class="o">-&gt;</span><span class="n">virtualMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">VirtualMemory</span><span class="p">();</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">guest</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">runGuest</span><span class="p">(</span><span class="n">VirtualMachine</span><span class="o">*</span><span class="w"> </span><span class="n">guest</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Enter guest mode</span>
<span class="w">            </span><span class="n">vmlaunch</span><span class="p">(</span><span class="n">guest</span><span class="o">-&gt;</span><span class="n">vmcs</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// Handle VM exits</span>
<span class="w">            </span><span class="n">handleVMExit</span><span class="p">(</span><span class="n">guest</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h2>More on</h2>
<ul>
<li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">Operating Systems: Three Easy Pieces</a> by Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau</li>
<li><a href="https://csc-knu.github.io/sys-prog/books/Andrew%20S.%20Tanenbaum%20-%20Modern%20Operating%20Systems.pdf">Modern Operating Systems</a> by Andrew S. Tanenbaum</li>
<li><a href="https://codex.cs.yale.edu/avi/os-book/">Operating System Concepts</a> by Abraham Silberschatz, Peter B. Galvin, and Greg Gagne</li>
<li><a href="https://www.freebsd.org/doc/en/books/design-44bsd/">The Design and Implementation of the FreeBSD Operating System</a> by Marshall Kirk McKusick and George V. Neville-Neil</li>
<li><a href="https://www.pearson.com/store/p/linux-kernel-development/P100000648849">Linux Kernel Development</a> by Robert Love</li>
<li><a href="https://wiki.osdev.org/">OSDev Wiki</a> - Comprehensive OS development resource</li>
<li><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel Software Developer Manuals</a> - x86/x86_64 architecture reference</li>
<li><a href="https://developer.arm.com/documentation/ddi0487/latest/">ARM Architecture Reference Manual</a> - ARM processor documentation</li>
<li><a href="https://riscv.org/specifications/">RISC-V Specifications</a> - Open ISA specifications</li>
<li><a href="https://www.minix3.org/">Minix</a> - Educational microkernel operating system</li>
<li><a href="https://pdos.csail.mit.edu/6.828/2012/xv6.html">xv6</a> - Simple Unix-like teaching operating system</li>
<li><a href="https://bootlin.com/training/embedded-linux/">Bootlin Embedded Linux Courses</a> - Linux kernel and embedded development</li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
