<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Mercury - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Mercury</h2>

        <dl>
          <dt>File size</dt>
          <dd>10.7KB</dd>

          <dt>Lines of code</dt>
          <dd>257</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Mercury</code></h1>
<p>Functional language for complex algorithm implementation and formal verification.</p>
<h2>Comments</h2>
<pre class="codehilite"><code class="language-m">% ----- COMMENT -----

% this is a single-line comment

/* this is a
multi-line 
comment */
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-m">% ----- PRINTING -----
    % io.write_string() =&gt; receives a string argument that is then printed to the stdout and does not include a newline by default
        % !IO =&gt; provided as the second argument to the io.write_string() function
    % note there is no built-in implementation for printing to the stdout with a newline included automatically

io.write_string(&quot;this does not have a newline&quot;, !IO).
io.write_string(&quot;this includes a newline but only because we explicitly specify its inclusion\n&quot;, !IO).
</code></pre>

<h2>Quickstart</h2>
<pre class="codehilite"><code class="language-m">% ----- QUICKSTART -----
    % period-delimited programming language
    % strongly, statically typed
    % encourages declarative programming with a sophisticated determinism system 
    % supports concurrency and automatic garbage collection
    % main(!IO) =&gt; specifies the entry point of a Mercury program wherein all execution code is written, the equivalent of the main function in many other programming languages within the C family
    % import_module =&gt; brings other user-defined and Mercury built-in modules into the current module's local scope
    % module =&gt; declares the beginning of a module
    % :- =&gt; general-purpose syntax used for variable declaration, directives, and clauses
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-m">% ----- TYPE -----
    % int =&gt; stores signed and unsigned integer number values
    % float =&gt; stores signed and unsigned floating-point number values
    % char =&gt; stores a single Unicode character value, declared within '' single quotation marks
    % bool =&gt; true, false
    % string =&gt; stores a string value, declared within &quot;&quot; double quotation marks

:- type int.
:- type float.
:- type char.
:- type bool.
:- type string.
</code></pre>

<h2>Operators</h2>
<pre class="codehilite"><code class="language-m">% ----- OPERATOR -----

% --- ARITHMETIC OPERATOR ---

+ % addition
- % subtraction
* % multiplication
/ % division
% % modulo

% --- COMPARISON OPERATOR ---

= % partial equality check for value but not type
\= % partial inequality check for value but not type
&gt; % comparison operator
&lt; % comparison operator
&gt;= % comparison operator
&lt;= % comparison operator

% --- LOGICAL OPERATOR ---

, % conjunction operator, used as logical and
; % disjunction operator, used as logical or
not % negation operator, used as logical not
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-m">% ----- CONTROL STRUCTURE -----

% --- CONDITIONALS ---

% IF ELSE IF ELSE 

:- pred check_age(int::in) is semidet.
check_age(Age) :-
    ( if Age &gt;= 18 then
        io.write_string(&quot;Adult\n&quot;)
    else if Age &gt;= 13 then
        io.write_string(&quot;Teenager\n&quot;)
    else
        io.write_string(&quot;Child\n&quot;) ).

% CASE = -&gt;
    % provides basic pattern-matching similar to Rust and other programming languages

:- type color ---&gt; red ; blue ; green.
:- pred describe_color(color::in, io::di, io::uo) is det.
describe_color(Color, !IO) :-
    ( Color = red -&gt;
        io.write_string(&quot;Color is Red\n&quot;, !IO)
    ; Color = blue -&gt;
        io.write_string(&quot;Color is Blue\n&quot;, !IO)
    ; Color = green -&gt;
        io.write_string(&quot;Color is Green\n&quot;, !IO)
    ).

% --- LOOPS ---
    % Mercury lacks coventional for and while loop constructs as in other programming languages
    % instead, recursion can be used as seen below to iterate over and traverse an iterable data structure similar to Clojure and other Lisp dialects in a manner similar to for loops
    % while loops can also be effected by including a recursive construct and adding a conditional predicate check that breaks out of the loop when the predicate condition is met

% RECURSION TO ITERATE OVER ITERABLE STRUCTURE

:- pred sum_list(list(int)::in, int::out, io::di, io::uo) is det.
sum_list(List, Sum, !IO) :-
    sum_list_loop(List, 0, Sum, !IO).

:- pred sum_list_loop(list(int)::in, int::in, int::out, io::di, io::uo) is det.
sum_list_loop([], Acc, Acc, !IO).
sum_list_loop([Head | Tail], Acc, Sum, !IO) :-
    NewAcc = Acc + Head,
    sum_list_loop(Tail, NewAcc, Sum, !IO).

% RECURSION WITH EXIT PREDICATE CONDITION

:- pred count_down(int::in, io::di, io::uo) is det.
count_down(N, !IO) :-
    ( if N &gt; 0 then
        io.write_string(string.format(&quot;Counting down: %d\n&quot;, [i(N)]), !IO),
        count_down(N - 1, !IO)
    else
        io.write_string(&quot;Countdown complete!\n&quot;, !IO)
    ).
</code></pre>

<h2>Data structures</h2>
<pre class="codehilite"><code class="language-m">% ----- DATA STRUCTURE -----
    % list =&gt; dynamically-sized ordered collection of elements of the same datatype
    % array =&gt; fixed-size ordered collection of elements of the same datatype
    % type =&gt; used to specify one of the following user-defined datatypes
        % user-defined set of named constants, the equivalent of enums in other languages
        % user-defined collection of named fields and their specified corresponding datatypes, the equivalent of structs in Rust and Go allowing for the modelling of structured data
        % option() =&gt; creates a nullable datatype that can either store a value of the specified datatype as some() or the special value none
        % some() =&gt; represents the presence of a value stored in a variable that is nullable and could be storing the none value
        % none =&gt; represents the absence of a value
        % alias =&gt; special keyword that creates a type alias for existing datatypes, from which that aliased datatype can then be called

:- type list(T).
:- type array(T, N).
:- type color. % enum equivalent
:- type person. % struct equivalent
:- type option(T).
:- type alias Name == string. % alias Name for the existing datatype string
</code></pre>

<h2>Functions and Predicates</h2>
<pre class="codehilite"><code class="language-m">% ----- FUNCTION -----
    % used for computation and deterministic, producing a single output for a given number of inputs
    % Mercury function definitions bear many similarities to functional languages like Haskell, where the function's type signature is specified first and function implementation within the function body is specified after
    % bearing hallmarks of the functional paradigm, Mercury's functions feature implicit return of the last expression within the function definition, and each function returns a single value
    % func &lt;functionName&gt; ( &lt;functionParameterDatatype(s)&gt; ) = &lt;functionReturnDatatype&gt; . &lt;functionName&gt; ( &lt;functionParameterName(s)&gt; ) &lt;functionBody&gt; =&gt; function declaration and definition of type signature of a named function

:- func add(int, int) = int. % named function's type signature
add(X, Y) = X + Y. % named function's function body

:- func multiply(int, int) = int. % another named function's type signature
multiply(X, Y) = X * Y. % named function's function body

:- func factorial(int) = int. % a final named function's type signature
factorial(N) = ( if N =&lt; 0 then 1 else N * factorial(N - 1) ). % that named function's function body

% ----- PREDICATE -----
    % used for logical assertions that can succeed or fail, with the following determinism categories such as the following
        % det =&gt; always succeeds exactly once
        % semidet =&gt; succeeds at most once and may fail
        % nondet =&gt; can succeed multiple times
        % multi =&gt; must succeed at least once, but can succeed multiple times
    % pred &lt;predicateName&gt; ( &lt;predicateParameterDatatype(s)&gt; :: &lt;predicateModeParameterDescriptions&gt;) is &lt;determinismCategory&gt; . &lt;predicateName&gt; ( &lt;predicateParameterName(s)&gt; ) :- &lt;predicateBody&gt; =&gt; predicate declaration and definition for a named predicate
    % predicate mode parameter descriptions are used to specify how parameters are passed to and from predicates
        % in =&gt; the predicate parameter will be read by the predicate but will not be modified by it
        % di =&gt; the predicate parameter will be consumed (destroyed) by the predicate
        % uo =&gt; the predicate parameter will be used to produce an output returned value

:- pred is_even(int::in) is semidet. % type signature for a predicate
is_even(N) :- N mod 2 = 0. % predicate implementation

:- pred check_age(int::in, io::di, io::uo) is det. % type signature for a more complex predicate
check_age(Age, !IO) :- % predicate implementation
    ( if Age &gt;= 18 then
        io.write_string(&quot;Adult\n&quot;, !IO)
    else if Age &gt;= 13 then
        io.write_string(&quot;Teenager\n&quot;, !IO)
    else
        io.write_string(&quot;Child\n&quot;, !IO)
    ).
</code></pre>

<h2>More on</h2>
<ul>
<li><a href="https://mercurylang.org/documentation/documentation.html">mercury documentation</a></li>
<li><a href="https://learnxinyminutes.com/docs/mercury/">learn mercury in y minutes</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>Â© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
