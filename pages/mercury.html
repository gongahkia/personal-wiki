<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Mercury - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Mercury</h2>

        <dl>
          <dt>File size</dt>
          <dd>19.8KB</dd>

          <dt>Lines of code</dt>
          <dd>257</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Mercury</code></h1>
<p>Functional language for complex algorithm implementation and formal verification.</p>
<h2>Comments</h2>
<div class="codehilite"><pre><span></span><code><span class="c">% ----- COMMENT -----</span>

<span class="c">% this is a single-line comment</span>

<span class="o">/*</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span>
<span class="n">multi</span><span class="o">-</span><span class="nb">line</span><span class="w"> </span>
<span class="n">comment</span><span class="w"> </span><span class="o">*/</span>
</code></pre></div>

<h2>Printing</h2>
<div class="codehilite"><pre><span></span><code><span class="c">% ----- PRINTING -----</span>
<span class="w">    </span><span class="c">% io.write_string() =&gt; receives a string argument that is then printed to the stdout and does not include a newline by default</span>
<span class="w">        </span><span class="c">% !IO =&gt; provided as the second argument to the io.write_string() function</span>
<span class="w">    </span><span class="c">% note there is no built-in implementation for printing to the stdout with a newline included automatically</span>

<span class="n">io</span><span class="p">.</span><span class="n">write_string</span><span class="p">(</span><span class="s">&quot;this does not have a newline&quot;</span><span class="p">,</span><span class="w"> </span>!<span class="n">IO</span><span class="p">).</span>
<span class="n">io</span><span class="p">.</span><span class="n">write_string</span><span class="p">(</span><span class="s">&quot;this includes a newline but only because we explicitly specify its inclusion\n&quot;</span><span class="p">,</span><span class="w"> </span>!<span class="n">IO</span><span class="p">).</span>
</code></pre></div>

<h2>Quickstart</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">% ----- QUICKSTART -----</span>
    <span class="c1">% period-delimited programming language</span>
    <span class="c1">% strongly, statically typed</span>
    <span class="c1">% encourages declarative programming with a sophisticated determinism system </span>
    <span class="c1">% supports concurrency and automatic garbage collection</span>
    <span class="c1">% main(!IO) =&gt; specifies the entry point of a Mercury program wherein all execution code is written, the equivalent of the main function in many other programming languages within the C family</span>
    <span class="c1">% import_module =&gt; brings other user-defined and Mercury built-in modules into the current module&#39;s local scope</span>
    <span class="c1">% module =&gt; declares the beginning of a module</span>
    <span class="c1">% :- =&gt; general-purpose syntax used for variable declaration, directives, and clauses</span>
</code></pre></div>

<h2>Types</h2>
<div class="codehilite"><pre><span></span><code><span class="c">% ----- TYPE -----</span>
    <span class="c">% int =&gt; stores signed and unsigned integer number values</span>
    <span class="c">% float =&gt; stores signed and unsigned floating-point number values</span>
    <span class="c">% char =&gt; stores a single Unicode character value, declared within &#39;&#39; single quotation marks</span>
    <span class="c">% bool =&gt; true, false</span>
    <span class="c">% string =&gt; stores a string value, declared within &quot;&quot; double quotation marks</span>

<span class="p">:- </span><span class="err">type </span>int.
<span class="p">:- </span><span class="err">type </span>float.
<span class="p">:- </span><span class="err">type </span>char.
<span class="p">:- </span><span class="err">type </span>bool.
<span class="p">:- </span><span class="err">type </span>string.
</code></pre></div>

<h2>Operators</h2>
<div class="codehilite"><pre><span></span><code><span class="c">% ----- OPERATOR -----</span>

<span class="c">% --- ARITHMETIC OPERATOR ---</span>

<span class="o">+</span><span class="w"> </span><span class="c">% addition</span>
<span class="o">-</span><span class="w"> </span><span class="c">% subtraction</span>
<span class="o">*</span><span class="w"> </span><span class="c">% multiplication</span>
<span class="o">/</span><span class="w"> </span><span class="c">% division</span>
<span class="c">% % modulo</span>

<span class="c">% --- COMPARISON OPERATOR ---</span>

<span class="p">=</span><span class="w"> </span><span class="c">% partial equality check for value but not type</span>
<span class="o">\</span><span class="p">=</span><span class="w"> </span><span class="c">% partial inequality check for value but not type</span>
<span class="o">&gt;</span><span class="w"> </span><span class="c">% comparison operator</span>
<span class="o">&lt;</span><span class="w"> </span><span class="c">% comparison operator</span>
<span class="o">&gt;=</span><span class="w"> </span><span class="c">% comparison operator</span>
<span class="o">&lt;=</span><span class="w"> </span><span class="c">% comparison operator</span>

<span class="c">% --- LOGICAL OPERATOR ---</span>

<span class="p">,</span><span class="w"> </span><span class="c">% conjunction operator, used as logical and</span>
<span class="p">;</span><span class="w"> </span><span class="c">% disjunction operator, used as logical or</span>
<span class="n">not</span><span class="w"> </span><span class="s">%</span><span class="w"> </span><span class="s">negation</span><span class="w"> </span><span class="s">operator,</span><span class="w"> </span><span class="s">used</span><span class="w"> </span><span class="s">as</span><span class="w"> </span><span class="s">logical</span><span class="w"> </span><span class="s">not</span>
</code></pre></div>

<h2>Control structures</h2>
<div class="codehilite"><pre><span></span><code><span class="c">% ----- CONTROL STRUCTURE -----</span>

<span class="c">% --- CONDITIONALS ---</span>

<span class="c">% IF ELSE IF ELSE </span>

<span class="p">:- </span><span class="err">pred </span>check_age(int<span class="o">::</span>in) <span class="k">is</span> semidet.
check_age(<span class="nv">Age</span>) <span class="o">:-</span>
    ( if <span class="nv">Age</span> <span class="o">&gt;=</span> <span class="m">18</span> then
        io.write_string(<span class="s">&quot;Adult</span><span class="se">\n</span><span class="s">&quot;</span>)
    else if <span class="nv">Age</span> <span class="o">&gt;=</span> <span class="m">13</span> then
        io.write_string(<span class="s">&quot;Teenager</span><span class="se">\n</span><span class="s">&quot;</span>)
    else
        io.write_string(<span class="s">&quot;Child</span><span class="se">\n</span><span class="s">&quot;</span>) ).

<span class="c">% CASE = -&gt;</span>
    <span class="c">% provides basic pattern-matching similar to Rust and other programming languages</span>

<span class="p">:- </span><span class="err">type color ---&gt; red ; blue ; </span>green.
<span class="p">:- </span><span class="err">pred </span>describe_color(color<span class="o">::</span>in, io<span class="o">::</span>di, io<span class="o">::</span>uo) <span class="k">is</span> det.
describe_color(<span class="nv">Color</span>, <span class="o">!</span><span class="nv">IO</span>) <span class="o">:-</span>
    ( <span class="nv">Color</span> <span class="o">=</span> red <span class="o">-&gt;</span>
        io.write_string(<span class="s">&quot;Color is Red</span><span class="se">\n</span><span class="s">&quot;</span>, <span class="o">!</span><span class="nv">IO</span>)
    <span class="o">;</span> <span class="nv">Color</span> <span class="o">=</span> blue <span class="o">-&gt;</span>
        io.write_string(<span class="s">&quot;Color is Blue</span><span class="se">\n</span><span class="s">&quot;</span>, <span class="o">!</span><span class="nv">IO</span>)
    <span class="o">;</span> <span class="nv">Color</span> <span class="o">=</span> green <span class="o">-&gt;</span>
        io.write_string(<span class="s">&quot;Color is Green</span><span class="se">\n</span><span class="s">&quot;</span>, <span class="o">!</span><span class="nv">IO</span>)
    ).

<span class="c">% --- LOOPS ---</span>
    <span class="c">% Mercury lacks coventional for and while loop constructs as in other programming languages</span>
    <span class="c">% instead, recursion can be used as seen below to iterate over and traverse an iterable data structure similar to Clojure and other Lisp dialects in a manner similar to for loops</span>
    <span class="c">% while loops can also be effected by including a recursive construct and adding a conditional predicate check that breaks out of the loop when the predicate condition is met</span>

<span class="c">% RECURSION TO ITERATE OVER ITERABLE STRUCTURE</span>

<span class="p">:- </span><span class="err">pred </span>sum_list(list(int)<span class="o">::</span>in, int<span class="o">::</span>out, io<span class="o">::</span>di, io<span class="o">::</span>uo) <span class="k">is</span> det.
sum_list(<span class="nv">List</span>, <span class="nv">Sum</span>, <span class="o">!</span><span class="nv">IO</span>) <span class="o">:-</span>
    sum_list_loop(<span class="nv">List</span>, <span class="m">0</span>, <span class="nv">Sum</span>, <span class="o">!</span><span class="nv">IO</span>).

<span class="p">:- </span><span class="err">pred </span>sum_list_loop(list(int)<span class="o">::</span>in, int<span class="o">::</span>in, int<span class="o">::</span>out, io<span class="o">::</span>di, io<span class="o">::</span>uo) <span class="k">is</span> det.
sum_list_loop([], <span class="nv">Acc</span>, <span class="nv">Acc</span>, <span class="o">!</span><span class="nv">IO</span>).
sum_list_loop([<span class="nv">Head</span> | <span class="nv">Tail</span>], <span class="nv">Acc</span>, <span class="nv">Sum</span>, <span class="o">!</span><span class="nv">IO</span>) <span class="o">:-</span>
    <span class="nv">NewAcc</span> <span class="o">=</span> <span class="nv">Acc</span> <span class="o">+</span> <span class="nv">Head</span>,
    sum_list_loop(<span class="nv">Tail</span>, <span class="nv">NewAcc</span>, <span class="nv">Sum</span>, <span class="o">!</span><span class="nv">IO</span>).

<span class="c">% RECURSION WITH EXIT PREDICATE CONDITION</span>

<span class="p">:- </span><span class="err">pred </span>count_down(int<span class="o">::</span>in, io<span class="o">::</span>di, io<span class="o">::</span>uo) <span class="k">is</span> det.
count_down(<span class="nv">N</span>, <span class="o">!</span><span class="nv">IO</span>) <span class="o">:-</span>
    ( if <span class="nv">N</span> <span class="o">&gt;</span> <span class="m">0</span> then
        io.write_string(string.format(<span class="s">&quot;Counting down: %d</span><span class="se">\n</span><span class="s">&quot;</span>, [i(<span class="nv">N</span>)]), <span class="o">!</span><span class="nv">IO</span>),
        count_down(<span class="nv">N</span> <span class="o">-</span> <span class="m">1</span>, <span class="o">!</span><span class="nv">IO</span>)
    else
        io.write_string(<span class="s">&quot;Countdown complete!</span><span class="se">\n</span><span class="s">&quot;</span>, <span class="o">!</span><span class="nv">IO</span>)
    ).
</code></pre></div>

<h2>Data structures</h2>
<div class="codehilite"><pre><span></span><code><span class="c">% ----- DATA STRUCTURE -----</span>
    <span class="c">% list =&gt; dynamically-sized ordered collection of elements of the same datatype</span>
    <span class="c">% array =&gt; fixed-size ordered collection of elements of the same datatype</span>
    <span class="c">% type =&gt; used to specify one of the following user-defined datatypes</span>
        <span class="c">% user-defined set of named constants, the equivalent of enums in other languages</span>
        <span class="c">% user-defined collection of named fields and their specified corresponding datatypes, the equivalent of structs in Rust and Go allowing for the modelling of structured data</span>
        <span class="c">% option() =&gt; creates a nullable datatype that can either store a value of the specified datatype as some() or the special value none</span>
        <span class="c">% some() =&gt; represents the presence of a value stored in a variable that is nullable and could be storing the none value</span>
        <span class="c">% none =&gt; represents the absence of a value</span>
        <span class="c">% alias =&gt; special keyword that creates a type alias for existing datatypes, from which that aliased datatype can then be called</span>

<span class="p">:- </span><span class="err">type </span>list(<span class="nv">T</span>).
<span class="p">:- </span><span class="err">type </span>array(<span class="nv">T</span>, <span class="nv">N</span>).
<span class="p">:- </span><span class="err">type </span>color. <span class="c">% enum equivalent</span>
<span class="p">:- </span><span class="err">type </span>person. <span class="c">% struct equivalent</span>
<span class="p">:- </span><span class="err">type </span>option(<span class="nv">T</span>).
<span class="p">:- </span><span class="err">type alias Name == </span>string. <span class="c">% alias Name for the existing datatype string</span>
</code></pre></div>

<h2>Functions and Predicates</h2>
<div class="codehilite"><pre><span></span><code><span class="c">% ----- FUNCTION -----</span>
    <span class="c">% used for computation and deterministic, producing a single output for a given number of inputs</span>
    <span class="c">% Mercury function definitions bear many similarities to functional languages like Haskell, where the function&#39;s type signature is specified first and function implementation within the function body is specified after</span>
    <span class="c">% bearing hallmarks of the functional paradigm, Mercury&#39;s functions feature implicit return of the last expression within the function definition, and each function returns a single value</span>
    <span class="c">% func &lt;functionName&gt; ( &lt;functionParameterDatatype(s)&gt; ) = &lt;functionReturnDatatype&gt; . &lt;functionName&gt; ( &lt;functionParameterName(s)&gt; ) &lt;functionBody&gt; =&gt; function declaration and definition of type signature of a named function</span>

<span class="p">:- </span><span class="err">func </span>add(int, int) <span class="o">=</span> int. <span class="c">% named function&#39;s type signature</span>
add(<span class="nv">X</span>, <span class="nv">Y</span>) <span class="o">=</span> <span class="nv">X</span> <span class="o">+</span> <span class="nv">Y</span>. <span class="c">% named function&#39;s function body</span>

<span class="p">:- </span><span class="err">func </span>multiply(int, int) <span class="o">=</span> int. <span class="c">% another named function&#39;s type signature</span>
multiply(<span class="nv">X</span>, <span class="nv">Y</span>) <span class="o">=</span> <span class="nv">X</span> <span class="o">*</span> <span class="nv">Y</span>. <span class="c">% named function&#39;s function body</span>

<span class="p">:- </span><span class="err">func </span>factorial(int) <span class="o">=</span> int. <span class="c">% a final named function&#39;s type signature</span>
factorial(<span class="nv">N</span>) <span class="o">=</span> ( if <span class="nv">N</span> <span class="o">=&lt;</span> <span class="m">0</span> then <span class="m">1</span> else <span class="nv">N</span> <span class="o">*</span> factorial(<span class="nv">N</span> <span class="o">-</span> <span class="m">1</span>) ). <span class="c">% that named function&#39;s function body</span>

<span class="c">% ----- PREDICATE -----</span>
    <span class="c">% used for logical assertions that can succeed or fail, with the following determinism categories such as the following</span>
        <span class="c">% det =&gt; always succeeds exactly once</span>
        <span class="c">% semidet =&gt; succeeds at most once and may fail</span>
        <span class="c">% nondet =&gt; can succeed multiple times</span>
        <span class="c">% multi =&gt; must succeed at least once, but can succeed multiple times</span>
    <span class="c">% pred &lt;predicateName&gt; ( &lt;predicateParameterDatatype(s)&gt; :: &lt;predicateModeParameterDescriptions&gt;) is &lt;determinismCategory&gt; . &lt;predicateName&gt; ( &lt;predicateParameterName(s)&gt; ) :- &lt;predicateBody&gt; =&gt; predicate declaration and definition for a named predicate</span>
    <span class="c">% predicate mode parameter descriptions are used to specify how parameters are passed to and from predicates</span>
        <span class="c">% in =&gt; the predicate parameter will be read by the predicate but will not be modified by it</span>
        <span class="c">% di =&gt; the predicate parameter will be consumed (destroyed) by the predicate</span>
        <span class="c">% uo =&gt; the predicate parameter will be used to produce an output returned value</span>

<span class="p">:- </span><span class="err">pred </span>is_even(int<span class="o">::</span>in) <span class="k">is</span> semidet. <span class="c">% type signature for a predicate</span>
is_even(<span class="nv">N</span>) <span class="o">:-</span> <span class="nv">N</span> <span class="o">mod</span> <span class="m">2</span> <span class="o">=</span> <span class="m">0.</span> <span class="c">% predicate implementation</span>

<span class="p">:- </span><span class="err">pred </span>check_age(int<span class="o">::</span>in, io<span class="o">::</span>di, io<span class="o">::</span>uo) <span class="k">is</span> det. <span class="c">% type signature for a more complex predicate</span>
check_age(<span class="nv">Age</span>, <span class="o">!</span><span class="nv">IO</span>) <span class="o">:-</span> <span class="c">% predicate implementation</span>
    ( if <span class="nv">Age</span> <span class="o">&gt;=</span> <span class="m">18</span> then
        io.write_string(<span class="s">&quot;Adult</span><span class="se">\n</span><span class="s">&quot;</span>, <span class="o">!</span><span class="nv">IO</span>)
    else if <span class="nv">Age</span> <span class="o">&gt;=</span> <span class="m">13</span> then
        io.write_string(<span class="s">&quot;Teenager</span><span class="se">\n</span><span class="s">&quot;</span>, <span class="o">!</span><span class="nv">IO</span>)
    else
        io.write_string(<span class="s">&quot;Child</span><span class="se">\n</span><span class="s">&quot;</span>, <span class="o">!</span><span class="nv">IO</span>)
    ).
</code></pre></div>

<h2>More on</h2>
<ul>
<li><a href="https://mercurylang.org/documentation/documentation.html">mercury documentation</a></li>
<li><a href="https://learnxinyminutes.com/docs/mercury/">learn mercury in y minutes</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
