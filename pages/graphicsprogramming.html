<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Graphics Programming - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Graphics Programming</h2>

        <dl>
          <dt>File size</dt>
          <dd>10.1KB</dd>

          <dt>Lines of code</dt>
          <dd>186</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Graphics Programming</code></h1>
<p>An overview of common APIs and languages used for graphics programming.</p>
<h2>Introduction to Graphics Programming</h2>
<p>Graphics programming involves using computers to create and manipulate visual images. It is a broad field that includes 2D and 3D graphics, rendering, and animation. At its core, it is about communicating with the Graphics Processing Unit (GPU) to render scenes. This is typically done through a graphics API (Application Programming Interface).</p>
<h3>The Rendering Pipeline</h3>
<p>The rendering pipeline is a sequence of steps that the GPU takes to render a 3D scene to a 2D screen. The modern, programmable pipeline consists of several stages, some of which can be controlled by developers using shaders. The main stages are:<br />
1.  <strong>Vertex Shader:</strong> Processes individual vertices and their attributes (position, color, texture coordinates).<br />
2.  <strong>Tessellation/Geometry Shader (Optional):</strong> Can create new geometry on the fly.<br />
3.  <strong>Rasterization:</strong> Converts geometric primitives (triangles, lines) into fragments (pixels).<br />
4.  <strong>Fragment Shader:</strong> Processes individual fragments to determine their final color.<br />
5.  <strong>Framebuffer Operations:</strong> The final fragments are written to the framebuffer, which is then displayed on the screen.</p>
<h2>OpenGL (Open Graphics Library)</h2>
<p>OpenGL is a mature, cross-platform API for rendering 2D and 3D vector graphics. It is known for being a state machine, where you set various states (like the current color or transformation matrix) and then issue drawing commands.</p>
<h3>Key Concepts</h3>
<ul>
<li><strong>Graphics Pipeline:</strong> As described above, OpenGL implements this pipeline.</li>
<li><strong>Shaders:</strong> Programs written in GLSL that run on the GPU.</li>
<li><strong>State Machine:</strong> You set the context for rendering by changing OpenGL's state. For example, you bind a texture or a shader, and it remains active until you unbind it or bind something else.</li>
<li><strong>Vertex Buffer Objects (VBOs) and Vertex Array Objects (VAOs):</strong> VBOs are memory buffers on the GPU for storing vertex data. VAOs store the configuration of vertex attributes, so you can quickly switch between different object-rendering setups.</li>
</ul>
<h2>GLSL (OpenGL Shading Language)</h2>
<p>GLSL is a high-level shading language with a syntax based on C. It is used to write shaders for the OpenGL API.</p>
<h3>Example Vertex Shader</h3>
<p>This shader takes a vertex position, a normal vector, and texture coordinates as input. It transforms the position using model, view, and projection matrices.</p>
<pre class="codehilite"><code class="language-glsl">#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoord;

out vec2 TexCoord;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    TexCoord = aTexCoord;
}
</code></pre>

<h3>Example Fragment Shader</h3>
<p>This shader uses the texture coordinates to sample a color from a texture.</p>
<pre class="codehilite"><code class="language-glsl">#version 330 core
out vec4 FragColor;

in vec2 TexCoord;

uniform sampler2D ourTexture;

void main()
{
    FragColor = texture(ourTexture, TexCoord);
}
</code></pre>

<h2>WebGL (Web Graphics Library)</h2>
<p>WebGL is a JavaScript API for rendering interactive 2D and 3D graphics within any compatible web browser without plug-ins. It is based on OpenGL ES, a subset of OpenGL for embedded systems.</p>
<h3>Relationship to the Browser</h3>
<p>WebGL renders to the HTML <code>&lt;canvas&gt;</code> element. You get a WebGL rendering context from a canvas and then use the WebGL API to draw to it. Popular libraries like <strong>Three.js</strong> and <strong>Babylon.js</strong> provide higher-level abstractions over the verbose WebGL API.</p>
<h3>Example: Getting a WebGL Context</h3>
<pre class="codehilite"><code class="language-javascript">const canvas = document.getElementById('myCanvas');
const gl = canvas.getContext('webgl');

if (!gl) {
  alert('WebGL not supported!');
}
</code></pre>

<h2>Vulkan</h2>
<p>Vulkan is a modern, low-overhead, cross-platform 3D graphics and computing API. It provides much more direct control over the GPU than OpenGL, which can lead to better performance but also requires more code.</p>
<h3>Key Concepts</h3>
<ul>
<li><strong>Explicit API:</strong> Unlike OpenGL's state machine, nothing happens in Vulkan unless you explicitly tell it to. You must manage memory, synchronization, and command submission yourself.</li>
<li><strong>Command Buffers:</strong> You record rendering commands into command buffers ahead of time. These can then be submitted to the GPU for execution, which is very efficient.</li>
<li><strong>Validation Layers:</strong> Because Vulkan has minimal error checking for performance reasons, you can enable validation layers during development to get detailed warnings and error messages.</li>
<li><strong>Render Passes:</strong> A render pass describes the set of attachments (images), subpasses, and dependencies between them, providing a structured way to handle rendering operations.</li>
</ul>
<h2>DirectX</h2>
<p>DirectX is a collection of APIs for multimedia tasks on Microsoft platforms. Its 3D graphics component, <strong>Direct3D</strong>, is the main competitor to OpenGL and Vulkan on Windows and Xbox.</p>
<h3>Key Components</h3>
<ul>
<li><strong>Direct3D:</strong> The 3D graphics API. DirectX 12 is the latest version and is a low-level API similar to Vulkan.</li>
<li><strong>HLSL (High-Level Shading Language):</strong> The shading language used with Direct3D.</li>
<li><strong>Direct2D, DirectWrite, DirectSound:</strong> Other components for 2D graphics, text, and audio.</li>
</ul>
<h2>HLSL (High-Level Shading Language)</h2>
<p>HLSL is the shading language for DirectX. Its syntax is very similar to GLSL and C.</p>
<h3>Example Pixel Shader (Fragment Shader)</h3>
<pre class="codehilite"><code class="language-hlsl">Texture2D txDiffuse : register(t0);
SamplerState samLinear : register(s0);

struct PS_INPUT
{
    float4 pos : SV_POSITION;
    float2 uv : TEXCOORD0;
};

float4 main(PS_INPUT input) : SV_Target
{
    return txDiffuse.Sample(samLinear, input.uv);
}
</code></pre>

<h2>Metal</h2>
<p>Metal is Apple's low-level graphics API for iOS, macOS, and tvOS. It was designed to provide high performance and low overhead, similar to Vulkan and DirectX 12.</p>
<h3>Key Concepts</h3>
<ul>
<li><strong>Metal Shading Language (MSL):</strong> The shading language for Metal, based on C++.</li>
<li><strong>Command-based:</strong> Like Vulkan, you encode commands into a command buffer and then commit it to a command queue for the GPU to execute.</li>
<li><strong>Unified Memory Model:</strong> On some Apple hardware, the CPU and GPU share memory, which can improve performance by avoiding the need to copy data.</li>
</ul>
<h2>BGFX</h2>
<p>BGFX is a cross-platform, graphics API-agnostic rendering library. It provides a single, unified API that works with multiple rendering backends, such as Direct3D, OpenGL, Vulkan, and Metal.</p>
<h3>Cross-Platform Nature</h3>
<p>BGFX abstracts away the differences between the underlying graphics APIs. You write your rendering code once using the BGFX API, and it can be compiled to run on different platforms with their native graphics APIs. It also has its own shader compiler, <code>shaderc</code>, to cross-compile shaders.</p>
<h2>OSL (Open Shading Language)</h2>
<p>OSL is a shading language developed by Sony Pictures Imageworks for offline, physically-based rendering. It is not designed for real-time graphics like GLSL and HLSL.</p>
<h3>Use in Rendering</h3>
<p>OSL is used in high-end renderers for film and animation. It allows for the creation of very complex and realistic materials. OSL shaders are evaluated at runtime, and the renderer can optimize the shading calculations.</p>
<h2>More on</h2>
<ul>
<li><a href="https://learnopengl.com/">Learn OpenGL</a></li>
<li><a href="https://webglfundamentals.org/">WebGL Fundamentals</a></li>
<li><a href="https://vulkan-tutorial.com/">Vulkan Tutorial</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/directx">DirectX Graphics and Gaming</a></li>
<li><a href="https://developer.apple.com/documentation/metal">Apple Metal Documentation</a></li>
<li><a href="https://bkaradzic.github.io/bgfx/overview.html">BGFX Documentation</a></li>
<li><a href="https://github.com/AcademySoftwareFoundation/OpenShadingLanguage">Open Shading Language on GitHub</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>Â© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
