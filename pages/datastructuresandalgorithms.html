<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Data Structures and Algorithms - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Data Structures and Algorithms</h2>

        <dl>
          <dt>File size</dt>
          <dd>247.2KB</dd>

          <dt>Lines of code</dt>
          <dd>1979</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Data Structures and Algorithms</code></h1>
<p>Code snippets in Go and Python.</p>
<h2>Definitions</h2>
<ul>
<li>Data structure: ordered collection of data provided by the language or defined and enforced by the programmer</li>
<li>Algorithm: sequence of steps to solve a problem</li>
<li>Big $O$ notation: describes performance of an algorithm as size of the dataset increases<ul>
<li>$n$: variable representing size of dataset</li>
</ul>
</li>
<li>Time complexity: time taken for an algorithm to complete execution</li>
<li>Space complexity: memory taken for an algorithm to complete execution</li>
</ul>
<h2>Big O Notation</h2>
<ol>
<li>CONSTANT time<ul>
<li>$O(1)$</li>
<li>number of steps for algorithm to complete execution is CONSTANT regardless of size of dataset</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">addUp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span><span class="w"> </span><span class="c1">// computation here has a time complexity of O(1)</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="kt">int</span>
<span class="w">    </span><span class="nx">sum</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">sum</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">add_up</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">return</span> <span class="nb">sum</span>
</code></pre></div>

<ol>
<li>LOGARITHMIC time<ul>
<li>$O(\log n)$</li>
<li>number of steps for algorithm to complete execution is MARGINALLY LOWER as size of dataset increases</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">binarySearch</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// computation here has a time complexity of O(log n)</span>
<span class="w">    </span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">mid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">right</span><span class="o">-</span><span class="nx">left</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">mid</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="c1">// target not found</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="c1"># note that the binary search here assumes a sorted integer array, which affords value comparison below</span>
    <span class="n">left_ptr</span><span class="p">,</span> <span class="n">right_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">left_ptr</span> <span class="o">&lt;=</span> <span class="n">right_ptr</span><span class="p">:</span> 
        <span class="n">mid_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">right_ptr</span> <span class="o">-</span> <span class="n">left_ptr</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">left_ptr</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid_ptr</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid_ptr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid_ptr</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">left_ptr</span> <span class="o">=</span> <span class="n">mid_ptr</span> <span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right_ptr</span> <span class="o">=</span> <span class="n">mid_ptr</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>

<ol>
<li>LINEAR time<ul>
<li>$O(n)$</li>
<li>number of steps for algorithm to complete execution INCREASES PROPORTIONALLY to size of dataset</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">addUp</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span><span class="w"> </span><span class="c1">// computation here has a time complexity of O(n)</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="kt">int</span>
<span class="w">    </span><span class="nx">sum</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">n</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">sum</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">add_up</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="nb">sum</span>
</code></pre></div>

<ol>
<li>QUASILINEAR time<ul>
<li>$O(n \log n)$</li>
<li>similar to LINEAR time, but slows down further when working with larger datasets</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// computation here has a time complexity of O(n log n)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">arr</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">mid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="nx">left</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">[:</span><span class="nx">mid</span><span class="p">])</span>
<span class="w">    </span><span class="nx">right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">:])</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">merge</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">merge</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="o">...</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">left</span><span class="o">...</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">left</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="w">            </span><span class="nx">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">left</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="w">            </span><span class="nx">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">right</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">:[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mid_ptr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="n">mid_ptr</span><span class="p">])</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid_ptr</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="c1"># called once</span>

<span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">:[</span><span class="nb">int</span><span class="p">],</span> <span class="n">right</span><span class="p">:[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="c1"># helper function called once</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>

<ol>
<li>QUADRATIC time<ul>
<li>$O(n^2)$</li>
<li>QUADRATIC increase in number of steps for algorithm to complete execution for a given increase in size of dataset</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">bubbleSort</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// computation here has a time complexity of O(n^2)</span>
<span class="w">    </span><span class="nx">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">n</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">:[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">q</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="c1"># just swap the values</span>
</code></pre></div>

<ol>
<li>FACTORIAL time<ul>
<li>$O(n!)$</li>
<li>extremely slow and rarely used</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// computation here has a time complexity of O(n!)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># recursive function call</span>
</code></pre></div>

<h3>Summary</h3>
<p><img alt="" src="https://paper-attachments.dropbox.com/s_2D428973624E7FC84C7D69D11421DE762BEA6B6F3361231FCDCAE0425D14526F_1664885448372_Untitled.drawio+17.png" /></p>
<h2>Data Structures</h2>
<ol>
<li>Stack<ul>
<li>Last-in First-out <em>(LIFO)</em> data structure</li>
<li><code>push()</code>: appends an element to the TOP of the stack</li>
<li><code>pop()</code>: removes an element from the TOP of the stack</li>
<li>Used in<ul>
<li>undo/redo features in text editors</li>
<li>moving backward/forward in browser history</li>
<li>backtracking algorithms <em>(mazes, file directories)</em></li>
<li>function call stacks</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Stack</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">items</span><span class="w"> </span><span class="p">[]</span><span class="kd">interface</span><span class="p">{}</span><span class="w"> </span><span class="c1">// interface is used here to allow the slice to hold elements of any datatype</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">Stack</span><span class="p">)</span><span class="w"> </span><span class="nx">Push</span><span class="p">(</span><span class="nx">item</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">s</span><span class="p">.</span><span class="nx">items</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">items</span><span class="p">,</span><span class="w"> </span><span class="nx">item</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="o">*</span><span class="nx">Stack</span><span class="p">)</span><span class="w"> </span><span class="nx">Pop</span><span class="p">()</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">items</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// empty stack</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">index</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">items</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="nx">item</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">s</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
<span class="w">    </span><span class="nx">s</span><span class="p">.</span><span class="nx">items</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">s</span><span class="p">.</span><span class="nx">items</span><span class="p">[:</span><span class="nx">index</span><span class="p">]</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">item</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">class</span> <span class="nc">Stack</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">:</span> <span class="c1"># if empty stack</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div>

<ol>
<li>Queue<ul>
<li>First-in First-out <em>(FIFO)</em> data structure</li>
<li><code>add()</code>: enqueues an element to the END of the queue</li>
<li><code>remove()</code>: dequeues an element from the FRONT of the queue</li>
<li>Used in<ul>
<li>keyboard buffers</li>
<li>printer queues</li>
<li>priority queues</li>
<li>linked lists</li>
<li>breadth-first search algorithm</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Queue</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">items</span><span class="w"> </span><span class="p">[]</span><span class="kd">interface</span><span class="p">{}</span><span class="w"> </span><span class="c1">// interface is used here to allow the slice to hold elements of any datatype</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">q</span><span class="w"> </span><span class="o">*</span><span class="nx">Queue</span><span class="p">)</span><span class="w"> </span><span class="nx">Add</span><span class="p">(</span><span class="nx">item</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">q</span><span class="p">.</span><span class="nx">items</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">items</span><span class="p">,</span><span class="w"> </span><span class="nx">item</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">q</span><span class="w"> </span><span class="o">*</span><span class="nx">Queue</span><span class="p">)</span><span class="w"> </span><span class="nx">Remove</span><span class="p">()</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">items</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// empty queue</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">item</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">q</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="w">    </span><span class="nx">q</span><span class="p">.</span><span class="nx">items</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">q</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">item</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">class</span> <span class="nc">Queue</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">:</span> <span class="c1"># if empty queue</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<ol>
<li>Priority Queue<ul>
<li>First-in First-out <em>(FIFO)</em> data structure</li>
<li>SORTS elements by PRIORITY, then dequeues elements of HIGHEST PRIORITY before elements of LOWER PRIORITY</li>
<li><code>add()</code>: enqueues an element to the END of the queue with a specified value and priority</li>
<li><code>remove()</code>: dequeues element of HIGHEST priority </li>
<li>Used in<ul>
<li>sorting algorithms <em>(heap sort)</em></li>
<li>graph algorithms <em>(dijkstra's algorithm, prim's algorithm)</em></li>
<li>system-related functions <em>(load balancing and interrupt handling)</em></li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Item</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// item being EACH ELEMENT of the priority queue</span>
<span class="w">    </span><span class="nx">value</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"> </span><span class="c1">// interface is used here to allow the value to hold elements of any datatype</span>
<span class="w">    </span><span class="nx">priority</span><span class="w"> </span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">PriorityQueue</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">Item</span><span class="w"> </span><span class="c1">// priority queue is implemented via a sorted slice of Item elements</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">pq</span><span class="w"> </span><span class="o">*</span><span class="nx">PriorityQueue</span><span class="p">)</span><span class="w"> </span><span class="nx">Add</span><span class="p">(</span><span class="nx">value</span><span class="w"> </span><span class="kd">interface</span><span class="p">{},</span><span class="w"> </span><span class="nx">priority</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">item</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Item</span><span class="p">{</span>
<span class="w">        </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nx">value</span><span class="p">,</span>
<span class="w">        </span><span class="nx">priority</span><span class="p">:</span><span class="w"> </span><span class="nx">priority</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">*</span><span class="nx">pq</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">,</span><span class="w"> </span><span class="nx">item</span><span class="p">)</span>
<span class="w">    </span><span class="nx">sort</span><span class="p">.</span><span class="nx">Slice</span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">,</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// sort the priority queue based on priority</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)[</span><span class="nx">i</span><span class="p">].</span><span class="nx">priority</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)[</span><span class="nx">j</span><span class="p">].</span><span class="nx">priority</span>
<span class="w">    </span><span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">pq</span><span class="w"> </span><span class="o">*</span><span class="nx">PriorityQueue</span><span class="p">)</span><span class="w"> </span><span class="nx">Remove</span><span class="p">()</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// empty priority queue</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">item</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="w">    </span><span class="o">*</span><span class="nx">pq</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">item</span><span class="p">.</span><span class="nx">value</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">class</span> <span class="nc">Item</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">priority</span>

<span class="k">class</span> <span class="nc">PriorityQueue</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">priority</span><span class="p">)</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">:</span> <span class="c1"># if empty priority queue</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span>
</code></pre></div>

<ol>
<li>Linked List<ul>
<li>Collection of nodes that are stored in non-consecutive memory locations <em>(each node comprising a VALUE + pointer(s) to OTHER NODE'S memory address(es))</em></li>
<li><strong>SINGLY LINKED LIST</strong><ul>
<li>nodes comprise...<ol>
<li>VALUE</li>
<li>NEXT node's memory address</li>
</ol>
</li>
</ul>
</li>
<li><strong>DOUBLY LINKED LIST</strong><ul>
<li>nodes comprise...<ol>
<li>VALUE</li>
<li>PREVIOUS node's memory address</li>
<li>NEXT node's memory address</li>
</ol>
</li>
</ul>
</li>
<li>Used because<ul>
<li>advantageous to arraylists<ul>
<li>faster insertion and deletion of nodes with $0(1)$ time complexity</li>
<li>low memory waste</li>
</ul>
</li>
<li>dynamically allocates memory as required</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Node</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// type definition for an element in a singly linked list</span>
<span class="w">    </span><span class="nx">value</span><span class="w"> </span><span class="kd">interface</span><span class="p">{}</span><span class="w"> </span><span class="c1">// interface is used here to allow the value to hold elements of any datatype</span>
<span class="w">    </span><span class="nx">next</span><span class="w"> </span><span class="o">*</span><span class="nx">Node</span><span class="w"> </span><span class="c1">// pointer to the next node</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">LinkedList</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// type definition for a singly linked list</span>
<span class="w">    </span><span class="nx">head</span><span class="w"> </span><span class="o">*</span><span class="nx">Node</span><span class="w"> </span><span class="c1">// define the head node</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">list</span><span class="w"> </span><span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">value</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// appends a new node to the END of the linked list</span>

<span class="w">    </span><span class="nx">newNode</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Node</span><span class="p">{</span><span class="w"> </span><span class="c1">// creation of current node</span>
<span class="w">        </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nx">value</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="nx">next</span><span class="p">:</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">list</span><span class="p">.</span><span class="nx">head</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// if linked list empty, make current node the new head node</span>
<span class="w">        </span><span class="nx">list</span><span class="p">.</span><span class="nx">head</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newNode</span>
<span class="w">        </span><span class="k">return</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">lastNode</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">list</span><span class="p">.</span><span class="nx">head</span><span class="w"> </span><span class="c1">// traverse through the entire linked list until we reach the actual last node in the linkedlist where the next node is nil</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">lastNode</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">lastNode</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">lastNode</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">lastNode</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newNode</span><span class="w"> </span><span class="c1">// make the current node the new last node</span>

<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">list</span><span class="w"> </span><span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span><span class="w"> </span><span class="nx">add</span><span class="p">(</span><span class="nx">value</span><span class="w"> </span><span class="kd">interface</span><span class="p">{},</span><span class="w"> </span><span class="nx">position</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// adds a new node to a specified position in the linked list</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">position</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// if negative index, invalid index</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;invalid position&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// error</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">newNode</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Node</span><span class="p">{</span><span class="w"> </span><span class="c1">// creation of current node</span>
<span class="w">        </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nx">value</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="nx">next</span><span class="p">:</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">position</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// if insert current node at start of linked list, then just point current node&#39;s next at the old head</span>
<span class="w">        </span><span class="nx">newNode</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">list</span><span class="p">.</span><span class="nx">head</span>
<span class="w">        </span><span class="nx">list</span><span class="p">.</span><span class="nx">head</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newNode</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">prevNode</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">list</span><span class="p">.</span><span class="nx">head</span><span class="w"> </span><span class="c1">// traverse through the entire linked list until we reach the node at the desired position</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">position</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">prevNode</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="nx">prevNode</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">prevNode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// if insert current node at index outside length of the list, invalid index</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;position out of range&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// error</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// assuming no error</span>
<span class="w">        </span><span class="nx">newNode</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="c1">// assigns current node pointer to the previousnode&#39;s pointer to insert the current node in between the old previous node and its old next node</span>
<span class="w">        </span><span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newNode</span><span class="w"> </span><span class="c1">// assigns pointer from previousnode to point to current node</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="p">}</span>

<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">list</span><span class="w"> </span><span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span><span class="w"> </span><span class="nx">remove</span><span class="p">(</span><span class="nx">value</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// remove a node from the linked list by value</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">list</span><span class="p">.</span><span class="nx">head</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// empty list</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;empty list&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// error</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">list</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// check if current list head is node with desired value</span>
<span class="w">        </span><span class="nx">list</span><span class="p">.</span><span class="nx">head</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">list</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">prevNode</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">list</span><span class="p">.</span><span class="nx">head</span><span class="w"> </span><span class="c1">// traverse through the entire linked list until we reach the node with the desired value</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">prevNode</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// if reach the end of the linked list and the node with desired value not found</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s">&quot;element not found&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// error</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// node with desired value is found and it is the next node</span>
<span class="w">        </span><span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="c1">// assigns pointer from current node to one node after the next node, to effectively &quot;remove&quot; it from the linked list</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="p">}</span>

<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">list</span><span class="w"> </span><span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span><span class="w"> </span><span class="nx">display</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// display all linkedlist nodes</span>
<span class="w">    </span><span class="nx">current</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">list</span><span class="p">.</span><span class="nx">head</span><span class="w"> </span><span class="c1">// assigns current node to starting node</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// traverses through the entire linked list from start to finish</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%v -&gt; &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">current</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
<span class="w">        </span><span class="nx">current</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">current</span><span class="p">.</span><span class="nx">next</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;nil&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>  <span class="c1"># store value of the node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># pointer to the next node</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># initialize the head of the list as None</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># create a new node</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if the list is empty, set the new node as the head</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_node</span>
            <span class="k">return</span>
        <span class="n">last_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">last_node</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>  <span class="c1"># traverse to the last node</span>
            <span class="n">last_node</span> <span class="o">=</span> <span class="n">last_node</span><span class="o">.</span><span class="n">next</span>
        <span class="n">last_node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_node</span>  <span class="c1"># set the new node as the next of the last node</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># negative index is invalid</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid position&quot;</span><span class="p">)</span>

        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># create a new node</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if inserting at the head of the list</span>
            <span class="n">new_node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_node</span>
            <span class="k">return</span>

        <span class="n">prev_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">prev_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position out of range&quot;</span><span class="p">)</span>  <span class="c1"># index is outside the length of the list</span>
            <span class="n">prev_node</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">next</span>

        <span class="k">if</span> <span class="n">prev_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position out of range&quot;</span><span class="p">)</span>

        <span class="n">new_node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">next</span>  <span class="c1"># link the new node to the node after the previous node</span>
        <span class="n">prev_node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_node</span>  <span class="c1"># link the previous node to the new node</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if the list is empty</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty list&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>  <span class="c1"># if the head is the node to remove</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">next</span>
            <span class="k">return</span>

        <span class="n">prev_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">next</span> <span class="ow">and</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>  <span class="c1"># traverse to the node before the one to remove</span>
            <span class="n">prev_node</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">next</span>

        <span class="k">if</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># node to remove was not found</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Element not found&quot;</span><span class="p">)</span>

        <span class="n">prev_node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev_node</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>  <span class="c1"># remove the node by bypassing it</span>

    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>  <span class="c1"># start from the head node</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>  <span class="c1"># traverse through the entire linked list</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">current</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> -&gt; &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>  <span class="c1"># end the display with &#39;None&#39;</span>
</code></pre></div>

<ol>
<li>Hash Table<ul>
<li>Collection of unique entries that enables fast insertion, lookup and deletion of entries by leveraging on hashing and buckets</li>
<li>Entry: a key-value pair</li>
<li>Hashing: computing an integer based on a key <em>(formulas vary depending on the key's datatype)</em> to determine an entry's index</li>
<li>Collision: when hashing a key returns the SAME index for more than one key</li>
<li>Bucket: indexed storage location for one or more entries that functions like a LINKED LIST, allowing multiple entries to be stored in cases of collision</li>
<li>Used because<ul>
<li>best case <strong>CONSTANT time complexity</strong> of $O(1)$</li>
<li>worst case <strong>LINEAR time complexity</strong> of $O(n)$<ul>
<li>less efficient for smaller datasets</li>
<li>extremely efficient for larger datasets</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Node</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// type definition for a node in a hashtable</span>
<span class="w">    </span><span class="nx">key</span><span class="w">   </span><span class="kt">string</span>
<span class="w">    </span><span class="nx">value</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="nx">next</span><span class="w">  </span><span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">HashTable</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// type definition for the actual hash table struct</span>
<span class="w">    </span><span class="nx">size</span><span class="w">  </span><span class="kt">int</span>
<span class="w">    </span><span class="nx">table</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">NewHashTable</span><span class="p">(</span><span class="nx">size</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">HashTable</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// initialize a hash table of a specified size</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">HashTable</span><span class="p">{</span>
<span class="w">        </span><span class="nx">size</span><span class="p">:</span><span class="w">  </span><span class="nx">size</span><span class="p">,</span>
<span class="w">        </span><span class="nx">table</span><span class="p">:</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">Node</span><span class="p">,</span><span class="w"> </span><span class="nx">size</span><span class="p">),</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">ht</span><span class="w"> </span><span class="o">*</span><span class="nx">HashTable</span><span class="p">)</span><span class="w"> </span><span class="nx">hash</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// generates an index from a key</span>
<span class="w">    </span><span class="nx">sum</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">char</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="nx">char</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="nx">ht</span><span class="p">.</span><span class="nx">size</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">ht</span><span class="w"> </span><span class="o">*</span><span class="nx">HashTable</span><span class="p">)</span><span class="w"> </span><span class="nx">Insert</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// insert a new key-value pair into the hash table</span>
<span class="w">    </span><span class="nx">index</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ht</span><span class="p">.</span><span class="nx">hash</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="w">    </span><span class="nx">newNode</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Node</span><span class="p">{</span>
<span class="w">        </span><span class="nx">key</span><span class="p">:</span><span class="w">   </span><span class="nx">key</span><span class="p">,</span>
<span class="w">        </span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nx">value</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">ht</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// handle collisions within the same bucket by implementing a linked list</span>
<span class="w">        </span><span class="nx">ht</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newNode</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">current</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ht</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">current</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">current</span><span class="p">.</span><span class="nx">next</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">current</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">newNode</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">ht</span><span class="w"> </span><span class="o">*</span><span class="nx">HashTable</span><span class="p">)</span><span class="w"> </span><span class="nx">Get</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// retrieve a value based on its key within the hash table</span>
<span class="w">    </span><span class="nx">index</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ht</span><span class="p">.</span><span class="nx">hash</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="w">    </span><span class="nx">current</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ht</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">current</span><span class="p">.</span><span class="nx">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">current</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">current</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">current</span><span class="p">.</span><span class="nx">next</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">ht</span><span class="w"> </span><span class="o">*</span><span class="nx">HashTable</span><span class="p">)</span><span class="w"> </span><span class="nx">Delete</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// delete a key-value pair from the hash table</span>
<span class="w">    </span><span class="nx">index</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ht</span><span class="p">.</span><span class="nx">hash</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">ht</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">ht</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">].</span><span class="nx">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">ht</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">ht</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">].</span><span class="nx">next</span>
<span class="w">        </span><span class="k">return</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">prev</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ht</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
<span class="w">    </span><span class="nx">current</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">prev</span><span class="p">.</span><span class="nx">next</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">current</span><span class="p">.</span><span class="nx">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">prev</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">current</span><span class="p">.</span><span class="nx">next</span>
<span class="w">            </span><span class="k">return</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">prev</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">current</span>
<span class="w">        </span><span class="nx">current</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">current</span><span class="p">.</span><span class="nx">next</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">class</span> <span class="nc">HashTable</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># Simple hash function: sum the ASCII values of all characters in the key and modulo by size</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No collision, insert directly</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Collision handling: chain nodes in a linked list</span>
            <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
            <span class="n">current</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_node</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">current</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="kc">True</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
            <span class="c1"># The node to delete is the first node in the chain</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
            <span class="k">return</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
        <span class="k">while</span> <span class="n">current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                <span class="c1"># Unlink the node from the chain</span>
                <span class="n">prev</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
                <span class="k">return</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>

    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; -&gt; (</span><span class="si">{</span><span class="n">current</span><span class="o">.</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">current</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">next</span>
            <span class="nb">print</span><span class="p">()</span>
</code></pre></div>

<ol>
<li>
<p>Graph</p>
<ul>
<li>Non-linear aggregation of nodes and edges<ul>
<li>node: vertex that stores data</li>
<li>edge: connection between two nodes</li>
<li>adjacency: relationship between two nodes when they are connected by an edge</li>
</ul>
</li>
<li><strong>UNDIRECTED GRAPH</strong><ul>
<li>graph with bi-directional adjacency by default</li>
<li>eg. graph of a social network</li>
</ul>
</li>
<li><strong>DIRECTED GRAPH</strong><ul>
<li>graph with uni-directional adjacency by default <em>(arrowheads specify direction adjacency flows in)</em>, and bi-directional adjacency has to be specified with two seperate arrows</li>
<li>eg. graph of a street map <em>(some roads only allow one-way traffic)</em></li>
</ul>
</li>
<li>graphs can be represented by ADJACENCY MATRIXes or ADJACENCY LISTs as covered below</li>
<li>Used in <ul>
<li>representing social networks</li>
<li>visualising network routing</li>
<li>recommendation engines</li>
<li>GPS mapping applications</li>
<li>knowledge graphs</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Adjacency Matrix </p>
<ul>
<li>2d nested array of 0s and 1s which acts as a conceptual representation of adjacency between any two nodes in the graph</li>
<li>Used because<ul>
<li><strong>CONSTANT time complexity</strong> of $O(1)$<ul>
<li>relatively quicker compared to an ADJACENCY LIST for any given dataset</li>
</ul>
</li>
<li><strong>QUADRATIC space complexity</strong> of $O(n^2)$<ul>
<li>less efficient for smaller graph datasets</li>
<li>extremely efficient for larger graph datasets</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Graph</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// type definition for an undirected graph represented by an adjacency matrix</span>
<span class="w">    </span><span class="nx">vertices</span><span class="w"> </span><span class="kt">int</span>
<span class="w">    </span><span class="nx">matrix</span><span class="w">   </span><span class="p">[][]</span><span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">NewGraph</span><span class="p">(</span><span class="nx">vertices</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">Graph</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// initializes an undirected graph with a given number of vertices</span>
<span class="w">    </span><span class="nx">matrix</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([][]</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">vertices</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">matrix</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">vertices</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Graph</span><span class="p">{</span>
<span class="w">        </span><span class="nx">vertices</span><span class="p">:</span><span class="w"> </span><span class="nx">vertices</span><span class="p">,</span>
<span class="w">        </span><span class="nx">matrix</span><span class="p">:</span><span class="w">   </span><span class="nx">matrix</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">g</span><span class="w"> </span><span class="o">*</span><span class="nx">Graph</span><span class="p">)</span><span class="w"> </span><span class="nx">AddEdge</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span><span class="w"> </span><span class="nx">v2</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// adds an undirected edge between two vertices</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">v1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">v1</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">g</span><span class="p">.</span><span class="nx">vertices</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">v2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">v2</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">g</span><span class="p">.</span><span class="nx">vertices</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">g</span><span class="p">.</span><span class="nx">matrix</span><span class="p">[</span><span class="nx">v1</span><span class="p">][</span><span class="nx">v2</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="nx">g</span><span class="p">.</span><span class="nx">matrix</span><span class="p">[</span><span class="nx">v2</span><span class="p">][</span><span class="nx">v1</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">g</span><span class="w"> </span><span class="o">*</span><span class="nx">Graph</span><span class="p">)</span><span class="w"> </span><span class="nx">PrintMatrix</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// displays adjacency matrix</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">g</span><span class="p">.</span><span class="nx">matrix</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>  <span class="c1"># Number of vertices in the graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">vertices</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vertices</span><span class="p">)]</span>  <span class="c1"># Initialize the adjacency matrix</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">v2</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>  <span class="c1"># Check if vertices are valid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">v1</span><span class="p">][</span><span class="n">v2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Add edge from v1 to v2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">v2</span><span class="p">][</span><span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Add edge from v2 to v1 since it&#39;s an undirected graph</span>

    <span class="k">def</span> <span class="nf">print_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">:</span>  <span class="c1"># Print each row of the adjacency matrix</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</code></pre></div>

<ol>
<li>Adjacency List<ul>
<li>Array of LINKED LISTs, where each LINKED LIST head represents a unique node and its adjacent neighbour nodes</li>
<li>Used because<ul>
<li><strong>LINEAR time complexity</strong> of $O(n)$</li>
<li>space complexity of $O(numVertex + numEdge)$<ul>
<li>uses less space compared to an ADJACENCY MATRIX for any given dataset</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Node</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// type definition for a node within an undirected graph </span>
<span class="w">    </span><span class="nx">vertex</span><span class="w"> </span><span class="kt">int</span>
<span class="w">    </span><span class="nx">next</span><span class="w">   </span><span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Graph</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// type definition for an undirected graph represented by an adjacency list</span>
<span class="w">    </span><span class="nx">vertices</span><span class="w"> </span><span class="kt">int</span>
<span class="w">    </span><span class="nx">adjList</span><span class="w">  </span><span class="p">[]</span><span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">NewGraph</span><span class="p">(</span><span class="nx">vertices</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">Graph</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// initializes an undirected graph with a given number of vertices</span>
<span class="w">    </span><span class="nx">adjList</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">Node</span><span class="p">,</span><span class="w"> </span><span class="nx">vertices</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Graph</span><span class="p">{</span>
<span class="w">        </span><span class="nx">vertices</span><span class="p">:</span><span class="w"> </span><span class="nx">vertices</span><span class="p">,</span>
<span class="w">        </span><span class="nx">adjList</span><span class="p">:</span><span class="w">  </span><span class="nx">adjList</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">g</span><span class="w"> </span><span class="o">*</span><span class="nx">Graph</span><span class="p">)</span><span class="w"> </span><span class="nx">AddEdge</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span><span class="w"> </span><span class="nx">v2</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// adds an undirected edge between two vertices</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">v1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">v1</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">g</span><span class="p">.</span><span class="nx">vertices</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">v2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">v2</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">g</span><span class="p">.</span><span class="nx">vertices</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">nodeV1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Node</span><span class="p">{</span><span class="nx">vertex</span><span class="p">:</span><span class="w"> </span><span class="nx">v2</span><span class="p">,</span><span class="w"> </span><span class="nx">next</span><span class="p">:</span><span class="w"> </span><span class="nx">g</span><span class="p">.</span><span class="nx">adjList</span><span class="p">[</span><span class="nx">v1</span><span class="p">]}</span>
<span class="w">        </span><span class="nx">g</span><span class="p">.</span><span class="nx">adjList</span><span class="p">[</span><span class="nx">v1</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">nodeV1</span>
<span class="w">        </span><span class="nx">nodeV2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Node</span><span class="p">{</span><span class="nx">vertex</span><span class="p">:</span><span class="w"> </span><span class="nx">v1</span><span class="p">,</span><span class="w"> </span><span class="nx">next</span><span class="p">:</span><span class="w"> </span><span class="nx">g</span><span class="p">.</span><span class="nx">adjList</span><span class="p">[</span><span class="nx">v2</span><span class="p">]}</span>
<span class="w">        </span><span class="nx">g</span><span class="p">.</span><span class="nx">adjList</span><span class="p">[</span><span class="nx">v2</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">nodeV2</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">g</span><span class="w"> </span><span class="o">*</span><span class="nx">Graph</span><span class="p">)</span><span class="w"> </span><span class="nx">PrintList</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// displays adjacency list</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">vertex</span><span class="p">,</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">g</span><span class="p">.</span><span class="nx">adjList</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Vertex %d -&gt; &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">vertex</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">vertex</span><span class="p">)</span>
<span class="w">            </span><span class="nx">node</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">next</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span> <span class="o">=</span> <span class="n">vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">vertices</span>  <span class="c1"># Initialize the adjacency list with None for each vertex</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">v2</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
            <span class="c1"># Add the edge from v1 to v2</span>
            <span class="n">node_v2</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
            <span class="n">node_v2</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_v2</span>

            <span class="c1"># Add the edge from v2 to v1 (since the graph is undirected)</span>
            <span class="n">node_v1</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
            <span class="n">node_v1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_v1</span>

    <span class="k">def</span> <span class="nf">print_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Vertex </span><span class="si">{</span><span class="n">vertex</span><span class="si">}</span><span class="s2"> -&gt;&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">temp</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">temp</span><span class="o">.</span><span class="n">vertex</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">next</span>
            <span class="nb">print</span><span class="p">()</span>
</code></pre></div>

<ol>
<li>
<p>Tree</p>
<ul>
<li>Non-linear collection of nodes <em>(which store data)</em> organised in a hierachy, where nodes are connected by edges</li>
<li>Root node: top-most node with no incoming edges</li>
<li>Leaf node: bottom-most nodes with no outgoing edges</li>
<li>Branch nodes: nodes in the middle with both incoming and outgoing edges</li>
<li>Parent nodes: any node with an outgoing edge</li>
<li>Child nodes: any node with an incoming edge</li>
<li>Sibling nodes: any nodes sharing the same parent node</li>
<li>Subtree: smaller tree nested within a larger tree</li>
<li>Size of tree: total number of nodes</li>
<li>Depth of node: number of edges below root node</li>
<li>Height of node: number of edges above furthest leaf node</li>
<li>Used in<ul>
<li>file explorers</li>
<li>database searches</li>
<li>domain name servers</li>
<li>HTML DOM structure</li>
<li>expression parsing in interpreters and transpilers</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Binary Search Tree</p>
<ul>
<li>Ordered tree where each parent node has only two child nodes <em>(binary)</em> and each parent node's value is greater than the left child node and smaller than the right child node, including the root node</li>
<li>Used because<ul>
<li>easier to locate a node when they are ordered within a binary search tree</li>
<li>best case <strong>LOGARITHMIC time complexity</strong> of $O(log n)$</li>
<li>worst case <strong>LINEAR time complexity</strong> of $O(n)$</li>
<li><strong>LINEAR space complexity</strong> of $O(n)$</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">Node</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// type definition for a generic node within a binary search tree</span>
<span class="w">    </span><span class="nx">key</span><span class="w">   </span><span class="kt">int</span>
<span class="w">    </span><span class="nx">left</span><span class="w">  </span><span class="o">*</span><span class="nx">Node</span>
<span class="w">    </span><span class="nx">right</span><span class="w"> </span><span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">BST</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// type definition for a binary search tree, which begins with its root node</span>
<span class="w">    </span><span class="nx">root</span><span class="w"> </span><span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">NewNode</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="nx">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// initializes a new node with a given key</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Node</span><span class="p">{</span>
<span class="w">        </span><span class="nx">key</span><span class="p">:</span><span class="w"> </span><span class="nx">key</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">bst</span><span class="w"> </span><span class="o">*</span><span class="nx">BST</span><span class="p">)</span><span class="w"> </span><span class="nx">Insert</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// inserts a key into the binary search tree</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">bst</span><span class="p">.</span><span class="nx">root</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">bst</span><span class="p">.</span><span class="nx">root</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">NewNode</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">insertRecursive</span><span class="p">(</span><span class="nx">bst</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">insertRecursive</span><span class="p">(</span><span class="nx">node</span><span class="w"> </span><span class="o">*</span><span class="nx">Node</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// helper function for recursive insertion</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">NewNode</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">insertRecursive</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">NewNode</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">insertRecursive</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">bst</span><span class="w"> </span><span class="o">*</span><span class="nx">BST</span><span class="p">)</span><span class="w"> </span><span class="nx">Search</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// searches for a key within the binary search tree</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">searchRecursive</span><span class="p">(</span><span class="nx">bst</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">searchRecursive</span><span class="p">(</span><span class="nx">node</span><span class="w"> </span><span class="o">*</span><span class="nx">Node</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// helper function for recursive search</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">searchRecursive</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">searchRecursive</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">bst</span><span class="w"> </span><span class="o">*</span><span class="nx">BST</span><span class="p">)</span><span class="w"> </span><span class="nx">InOrderTraversal</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// performs in-order traversal of binary search tree</span>
<span class="w">    </span><span class="nx">inOrderRecursive</span><span class="p">(</span><span class="nx">bst</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">inOrderRecursive</span><span class="p">(</span><span class="nx">node</span><span class="w"> </span><span class="o">*</span><span class="nx">Node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// helper function for recursive in-order traversal</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">inOrderRecursive</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
<span class="w">        </span><span class="nx">inOrderRecursive</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">class</span> <span class="nc">BST</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_insert_recursive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_insert_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_insert_recursive</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_insert_recursive</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_recursive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_search_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_recursive</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search_recursive</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">in_order_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_order_recursive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>  <span class="c1"># Newline for cleaner output</span>

    <span class="k">def</span> <span class="nf">_in_order_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_order_recursive</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_order_recursive</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div>

<h2>Algorithms</h2>
<ol>
<li>Linear Search<ul>
<li><strong>LINEAR time complexity</strong> of $O(n)$</li>
<li>iterates through a collection one element at a time</li>
<li>pros<ul>
<li>dataset can be unsorted</li>
<li>fast for searching small to medium-sized datasets</li>
<li>useful for data structures without random access </li>
</ul>
</li>
<li>cons<ul>
<li>slow for large datasets</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">linearSearch</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kd">interface</span><span class="p">{},</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// returns index of target element if found</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">item</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">arr</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">item</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="c1">// returns -1 if target element not found</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">linear_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>

<ol>
<li>Binary Search<ul>
<li><strong>LOGARITHMIC time complexity</strong> of $O(log n)$</li>
<li>eliminates half of the collection at each step to find the target element</li>
<li>pros<ul>
<li>more efficient for large datasets</li>
</ul>
</li>
<li>cons<ul>
<li>dataset has to be sorted</li>
<li>less efficient for smaller datasets</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">binarySearch</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kd">interface</span><span class="p">{},</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">mid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">right</span><span class="o">-</span><span class="nx">left</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">mid</span><span class="w"> </span><span class="c1">// returns index of target element</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="c1">// returns -1 if target element not found</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">elif</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>

<ol>
<li>Interpolation Search<ul>
<li><strong>average time complexity</strong> of $O(log(log n))$</li>
<li><strong>worst case LINEAR time complexity</strong> of $O(n)$</li>
<li>guesses where a value might be based on estimated probe results, with incorrect probes narrowing the search area and recalculating a new probe</li>
<li>improvement over BINARY searches that are best used for uniformly distributed datasets</li>
<li>pros<ul>
<li>more efficient for uniformly distributed datasets</li>
<li>more efficient for large datasets</li>
</ul>
</li>
<li>cons<ul>
<li>dataset has to be sorted</li>
<li>dataset has to be uniformly distributed</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">interpolationSearch</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kd">interface</span><span class="p">{},</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="kd">interface</span><span class="p">{})</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="nx">low</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="nx">high</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">low</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">high</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">high</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">pos</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">low</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="nx">target</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">low</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nx">high</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">low</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">high</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">low</span><span class="p">])</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">pos</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">pos</span><span class="w"> </span><span class="c1">// returns index of target element</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">pos</span><span class="p">]</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">low</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">high</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">pos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="c1">// returns -1 if target element not found</span>

<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">interpolation_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">high</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span> <span class="ow">and</span> <span class="n">target</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">low</span><span class="p">]</span> <span class="ow">and</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">high</span><span class="p">]:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">((</span><span class="n">target</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">low</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">high</span><span class="p">]</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">low</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pos</span>
        <span class="k">elif</span> <span class="n">arr</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>

<ol>
<li>Depth First Search<ul>
<li>search algorithm to traverse a tree or graph one BRANCH at a time<ol>
<li>pick a route</li>
<li>keep on going until a dead end or previously visited node is reached</li>
<li>backtrack to last node with unvisited adjacent neighbour nodes</li>
<li>repeat step 1</li>
</ol>
</li>
<li><strong>time complexity</strong> of $O(numVertex + numEdge)$</li>
<li><strong>LINEAR space complexity</strong> of $O(n)$</li>
<li>pros<ul>
<li>utilises a STACK</li>
<li>child nodes are visited before sibling nodes</li>
<li>better if destination node is on average FURTHER from start node</li>
</ul>
</li>
<li>cons<ul>
<li>often returns non-optimal paths</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">g</span><span class="w"> </span><span class="o">*</span><span class="nx">Graph</span><span class="p">)</span><span class="w"> </span><span class="nx">DFSUtil</span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// helper function for DFS</span>
<span class="w">    </span><span class="nx">g</span><span class="p">.</span><span class="nx">visited</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">v</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">g</span><span class="p">.</span><span class="nx">adjList</span><span class="p">[</span><span class="nx">v</span><span class="p">];</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="p">;</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// recur for all adjacent vertices</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">g</span><span class="p">.</span><span class="nx">visited</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">vertex</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">g</span><span class="p">.</span><span class="nx">DFSUtil</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">vertex</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">g</span><span class="w"> </span><span class="o">*</span><span class="nx">Graph</span><span class="p">)</span><span class="w"> </span><span class="nx">DFS</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">g</span><span class="p">.</span><span class="nx">vertices</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">g</span><span class="p">.</span><span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">g</span><span class="p">.</span><span class="nx">DFSUtil</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vertices</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">vertices</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dfs_util</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs_util</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs_util</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div>

<ol>
<li>Breadth First Search<ul>
<li>search algorithm to traverse a tree or graph one LEVEL at a time<ol>
<li>traverse one node at a time in every direction</li>
<li>once all directions have been expanded one node, repeat step 1</li>
</ol>
</li>
<li><strong>time complexity</strong> of $O(numVertex + numEdge)$</li>
<li><strong>LINEAR space complexity</strong> of $O(n)$ if implemented with a queue</li>
<li><strong>space complexity</strong> of $O(numVertex + numEdge)$ if implemented with an adjacency list</li>
<li>pros<ul>
<li>utilises a QUEUE</li>
<li>sibling nodes are visited before child nodes</li>
<li>better if destination node is on average CLOSER to start node</li>
</ul>
</li>
<li>cons<ul>
<li>less efficient on denser graph datasets with many edges</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">g</span><span class="w"> </span><span class="o">*</span><span class="nx">Graph</span><span class="p">)</span><span class="w"> </span><span class="nx">BFS</span><span class="p">(</span><span class="nx">startVertex</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">queue</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span><span class="w"> </span><span class="c1">// initializes a queue for BFS traversal</span>
<span class="w">    </span><span class="nx">g</span><span class="p">.</span><span class="nx">visited</span><span class="p">[</span><span class="nx">startVertex</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="nx">queue</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span><span class="w"> </span><span class="nx">startVertex</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="nx">currentVertex</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="w">        </span><span class="nx">queue</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="w"> </span><span class="c1">// dequeues a vertex from the queue</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">currentVertex</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">g</span><span class="p">.</span><span class="nx">adjList</span><span class="p">[</span><span class="nx">currentVertex</span><span class="p">];</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">nil</span><span class="p">;</span><span class="w"> </span><span class="nx">node</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// check to ensure adjacent vertices have not been visited</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">g</span><span class="p">.</span><span class="nx">visited</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">vertex</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">g</span><span class="p">.</span><span class="nx">visited</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">vertex</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span>
<span class="w">                </span><span class="nx">queue</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">vertex</span><span class="p">)</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vertices</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">vertices</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_vertex</span><span class="p">):</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="n">start_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_vertex</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">current_vertex</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">current_vertex</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">[</span><span class="n">current_vertex</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</code></pre></div>

<ol>
<li>Bubble Sort<ul>
<li><strong>QUADRATIC time complexity</strong> of $O(n^2)$</li>
<li><strong>CONSTANT space complexity</strong> of $O(1)$</li>
<li>compares pairs of adjacent elements and swaps them if they are not in order</li>
<li>pros<ul>
<li>relatively fast for small datasets</li>
<li>lower CONSTANT space complexity since collection sorted in place</li>
</ul>
</li>
<li>cons<ul>
<li>extremely slow for medium and large datasets</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">bubbleSort</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// slices are reference types in Go so changes made to the slice within the function are reflected outside the function</span>
<span class="w">    </span><span class="nx">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">n</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</code></pre></div>

<ol>
<li>Selection Sort<ul>
<li><strong>QUADRATIC time complexity</strong> of $O(n^2)$</li>
<li><strong>CONSTANT space complexity</strong> of $O(1)$</li>
<li>iterates across each element in a collection and compares against and stores the minimum value, swapping variables after each iteration</li>
<li>pros<ul>
<li>relatively fast for small and medium datasets</li>
<li>lower CONSTANT space complexity since collection sorted in place</li>
</ul>
</li>
<li>cons<ul>
<li>slower for large datasets</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">selectionSort</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// slices are reference types in Go so changes made to the slice within the function are reflected outside the function</span>
<span class="w">    </span><span class="nx">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">minIndex</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">n</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">minIndex</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">minIndex</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">j</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">minIndex</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">minIndex</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">selection_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">min_index</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_index</span><span class="p">]:</span>
                <span class="n">min_index</span> <span class="o">=</span> <span class="n">j</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_index</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</code></pre></div>

<ol>
<li>Insertion Sort<ul>
<li><strong>QUADRATIC time complexity</strong> of $O(n^2)$</li>
<li><strong>CONSTANT space complexity</strong> of $O(1)$</li>
<li>compares all elements to the left of a given element, then shift elements to the right to make room to insert a value</li>
<li>pros<ul>
<li>fast for small and medium datasets</li>
<li>fewer steps than BUBBLE SORT</li>
<li>best case LINEAR time complexity is $O(n)$ compared to SELECTION SORT'S $O(n^2)$</li>
<li>lower CONSTANT space complexity since collection sorted in place</li>
</ul>
</li>
<li>cons<ul>
<li>slower for large datasets</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">insertionSort</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// slices are reference types in Go so changes made to the slice within the function are reflected outside the function</span>
<span class="w">    </span><span class="nx">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">n</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">key</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="w">        </span><span class="nx">j</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">key</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
<span class="w">            </span><span class="nx">j</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">key</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
</code></pre></div>

<ol>
<li>Merge Sort<ul>
<li><strong>QUASILINEAR time complexity</strong> of $O(n log n)$</li>
<li><strong>LINEAR space complexity</strong> of $O(n)$</li>
<li>recursively split collection in half, sort each half, then recombine the two halves</li>
<li>pros<ul>
<li>faster than all sorting algorithms with QUADRATIC time complexity <em>(bubble sort, selection sort, insertion sort)</em></li>
</ul>
</li>
<li>cons<ul>
<li>higher LINEAR space complexity since new subarrays are created to store elements for each level of recursion</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">arr</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">mid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="nx">left</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">[:</span><span class="nx">mid</span><span class="p">])</span>
<span class="w">    </span><span class="nx">right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">mid</span><span class="p">:])</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">merge</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">merge</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="o">...</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">left</span><span class="o">...</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">left</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="w">            </span><span class="nx">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">left</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">right</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="w">            </span><span class="nx">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">right</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="n">right</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="n">left</span>
        <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>

<ol>
<li>Quick Sort<ul>
<li><strong>QUASILINEAR time complexity</strong> of $O(n log n)$ in best case and average case</li>
<li><strong>QUADRATIC time complexity</strong> of $O(n^2)$ in worst case </li>
<li><strong>LOGARITHMIC space complexity</strong> of $O(log n)$</li>
<li>moves smaller elements in a collection to left side of a pivot element, then recursively divide the collection into 2 partitions</li>
<li>pros<ul>
<li>faster than all sorting algorithms with QUADRATIC time complexity <em>(bubble sort, selection sort, insertion sort)</em> in best and average cases</li>
<li>lower LOGARITHMIC space complexity than MERGE SORT'S LINEAR space complexity since collection sorted in place</li>
</ul>
</li>
<li>cons<ul>
<li>higher LOGARITHMIC space complexity since quick sort relies on recursion </li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// slices are reference types in Go so changes made to the slice within the function are reflected outside the function</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">pivotIndex</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">partition</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="w">    </span><span class="nx">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">[:</span><span class="nx">pivotIndex</span><span class="p">])</span>
<span class="w">    </span><span class="nx">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">pivotIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">partition</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">pivot</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="w">    </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="nx">j</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">pivot</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">i</span><span class="o">++</span>
<span class="w">            </span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="n">pivot_index</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="n">pivot_index</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">]]</span> <span class="o">+</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">pivot_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>

<span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div>

<h3>Leetcode Algorithms</h3>
<p>The below algorithms are often used within Leetcode problems.</p>
<ol>
<li>Sliding Window <ul>
<li>Create a fixed-size window that moves through an array and performs a given operation</li>
<li>Used in problems involving<ul>
<li>substring searches </li>
<li>subarray slice searches</li>
</ul>
</li>
<li>Example questions <ul>
<li><a href="https://leetcode.com/problems/maximum-subarray/">Leetcode Problem #53: Maximum Subarray</a></li>
<li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">Leetcode Problem #3: Longest Substring Without Repeating Characters</a></li>
<li><a href="https://leetcode.com/problems/longest-consecutive-sequence/description/">Leetcode Problem #128: Longest Consecutive Sequence</a></li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">findMaxSum</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">k</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="nx">windowSum</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="nx">maxSum</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>

<span class="w">    </span><span class="nx">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">k</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="c1">// out of range index error</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">k</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">windowSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">maxSum</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">windowSum</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">k</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">n</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">windowSum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">k</span><span class="p">]</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">windowSum</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">maxSum</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">maxSum</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">windowSum</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">maxSum</span>

<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">find_max_sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># out of range index error</span>

    <span class="n">window_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="n">k</span><span class="p">])</span>
    <span class="n">max_sum</span> <span class="o">=</span> <span class="n">window_sum</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">window_sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">window_sum</span> <span class="o">&gt;</span> <span class="n">max_sum</span><span class="p">:</span>
            <span class="n">max_sum</span> <span class="o">=</span> <span class="n">window_sum</span>

    <span class="k">return</span> <span class="n">max_sum</span>
</code></pre></div>

<ol>
<li>Two Pointer<ul>
<li>Two pointers traverse an array simultaneously <em>(from different ends or with a stipulated distance between them)</em></li>
<li>Just a glorified way of saying two values are being stored for a given solution</li>
<li>Used in problems involving<ul>
<li>finding pairs in a sorted array </li>
<li>merging two sorted arrays</li>
</ul>
</li>
<li>Example questions<ul>
<li><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">Leetcode Problem #167: Two Sum II - Input array is sorted</a></li>
<li><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">Leetcode Problem #19: Remove Nth Node From End of List</a></li>
<li><a href="https://leetcode.com/problems/container-with-most-water/">Leetcode Problem #11: Container With Most Water</a></li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">findPairSum</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="nx">left</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">// left pointer index</span>
<span class="w">    </span><span class="nx">right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// right pointer index</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">left</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">sum</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">arr</span><span class="p">[</span><span class="nx">left</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">right</span><span class="p">]}</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">left</span><span class="o">++</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">right</span><span class="o">--</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="c1">// nothing found</span>

<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">find_pair_sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>

    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>

        <span class="n">current_sum</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">current_sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]]</span>

        <span class="k">elif</span> <span class="n">current_sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>

<ol>
<li>Three Pointer<ul>
<li>Extension of two pointer algorithm</li>
<li>Three pointers traverse an array simultaneously <em>(from different ends or with a stipulated distance between them)</em></li>
<li>Just a glorified way of saying three values are being stored for a given solution</li>
<li>Used in problems involving<ul>
<li>finding triplets satisfying a predicate</li>
<li>merging three or more sorted arrays</li>
<li>partitioning </li>
</ul>
</li>
<li>Example questions<ul>
<li><a href="https://leetcode.com/problems/3sum/">Leetcode Problem #15: 3Sum</a></li>
<li><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/">Leetcode Problem #21: Merge Two Sorted Lists</a></li>
<li><a href="https://leetcode.com/problems/merge-k-sorted-lists/">Leetcode Problem #23: Merge k Sorted Lists</a></li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// ----- Go implementation -----</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">findTriplet</span><span class="p">(</span><span class="nx">arr</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="nx">n</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="nx">left</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// left pointer</span>
<span class="w">        </span><span class="nx">right</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// right pointer</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">left</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">right</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">sum</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">left</span><span class="p">],</span><span class="w"> </span><span class="nx">arr</span><span class="p">[</span><span class="nx">right</span><span class="p">]}</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">target</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">left</span><span class="o">++</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">right</span><span class="o">--</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="c1">// nothing found</span>

<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># ----- Python implementation -----</span>

<span class="k">def</span> <span class="nf">find_triplet</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>

        <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>

            <span class="n">current_sum</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">current_sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]]</span>

            <span class="k">elif</span> <span class="n">current_sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>

<h2>More on</h2>
<ul>
<li><a href="https://frontendmasters.com/courses/algorithms/">primeagen's last algorithms course</a></li>
<li><a href="https://youtube.com/playlist?list=PLZPZq0r_RZON1eaqfafTnEexRzuHbfZX8&amp;si=Fdvpj73H-3FqQpBs">brocode playlist</a></li>
<li><a href="https://youtu.be/8hly31xKli0?si=aEbuILtMyqXl5PPu">freecodecamp</a></li>
<li><a href="https://cs50.harvard.edu/x/2024/weeks/5/">cs50 week 5 data structures</a></li>
<li><a href="https://youtu.be/5NgNicANyqM?si=qYD6DDvV5Fe3n-AA">cs50 ai with python</a></li>
<li><a href="https://visualgo.net/en/sorting">sorting algorithms explained</a></li>
<li><a href="https://www.toptal.com/developers/sorting-algorithms">sorting algorithms visualised</a></li>
<li><a href="https://www.bigocheatsheet.com/">big o notation cheatsheet</a></li>
<li><a href="https://learnxinyminutes.com/docs/asymptotic-notation/">learn asymptotic notation in y minutes</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
