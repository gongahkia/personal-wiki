<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Data Structures and Algorithms - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Data Structures and Algorithms</h2>

        <dl>
          <dt>File size</dt>
          <dd>58.4KB</dd>

          <dt>Lines of code</dt>
          <dd>1979</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Data Structures and Algorithms</code></h1>
<p>Code snippets in Go and Python.</p>
<h2>Definitions</h2>
<ul>
<li>Data structure: ordered collection of data provided by the language or defined and enforced by the programmer</li>
<li>Algorithm: sequence of steps to solve a problem</li>
<li>Big $O$ notation: describes performance of an algorithm as size of the dataset increases<ul>
<li>$n$: variable representing size of dataset</li>
</ul>
</li>
<li>Time complexity: time taken for an algorithm to complete execution</li>
<li>Space complexity: memory taken for an algorithm to complete execution</li>
</ul>
<h2>Big O Notation</h2>
<ol>
<li>CONSTANT time<ul>
<li>$O(1)$</li>
<li>number of steps for algorithm to complete execution is CONSTANT regardless of size of dataset</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func addUp(int n) int{ // computation here has a time complexity of O(1)
    var sum int
    sum = n * (n + 1)/2
    return sum
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def add_up(n:int) -&gt; int:
    sum = 0
    sum = n * (n+1)/2
    return sum
</code></pre>

<ol>
<li>LOGARITHMIC time<ul>
<li>$O(\log n)$</li>
<li>number of steps for algorithm to complete execution is MARGINALLY LOWER as size of dataset increases</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func binarySearch(arr []int, target int) int { // computation here has a time complexity of O(log n)
    left, right := 0, len(arr)-1
    for left &lt;= right {
        mid := left + (right-left)/2
        if arr[mid] == target {
            return mid
        }
        if arr[mid] &lt; target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1 // target not found
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def binary_search(arr: [int], target:int) -&gt; int: # note that the binary search here assumes a sorted integer array, which affords value comparison below
    left_ptr, right_ptr = 0, len(arr) - 1
    for left_ptr &lt;= right_ptr: 
        mid_ptr = (right_ptr - left_ptr)/2 + left_ptr
        if arr[mid_ptr] == target:
            return mid_ptr
        else:
            if arr[mid_ptr] &lt; target:
                left_ptr = mid_ptr +1
            else:
                right_ptr = mid_ptr - 1
    return -1
</code></pre>

<ol>
<li>LINEAR time<ul>
<li>$O(n)$</li>
<li>number of steps for algorithm to complete execution INCREASES PROPORTIONALLY to size of dataset</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func addUp(int n) int{ // computation here has a time complexity of O(n)
    var sum int
    sum = 0
    for i := 0; i &lt;= n; i++ {
        sum += i;
    }
    return sum
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def add_up(n:int) -&gt; int:
    sum = 0
    for i in range(n):
        sum += i
    return sum
</code></pre>

<ol>
<li>QUASILINEAR time<ul>
<li>$O(n \log n)$</li>
<li>similar to LINEAR time, but slows down further when working with larger datasets</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func mergeSort(arr []int) []int { // computation here has a time complexity of O(n log n)
    if len(arr) &lt;= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := make([]int, 0)
    for len(left) &gt; 0 || len(right) &gt; 0 {
        if len(left) == 0 {
            return append(result, right...)
        }
        if len(right) == 0 {
            return append(result, left...)
        }
        if left[0] &lt;= right[0] {
            result = append(result, left[0])
            left = left[1:]
        } else {
            result = append(result, right[0])
            right = right[1:]
        }
    }
    return result
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def merge_sort(arr:[int]) -&gt; [int]:
    if len(arr) &lt;= 1:
        return arr
    else:
        mid_ptr = len(arr) / 2
        left = merge_sort(arr[:mid_ptr])
        right = merge_sort(arr[mid_ptr:])
        return merge(left, right) # called once

def merge(left:[int], right:[int]) -&gt; [int]: # helper function called once
    result = [0]
    while len(left) &gt; 0 or len(right) &gt; 0:
        if len(left) == 0:
            return result.append(right)
        if len(right) == 0:
            return result.append(left)
        if left[0] &lt;= right[0]:
            result.append(left[0])
        else:
            result.append(right[0])
            right = right[1:]
    return result
</code></pre>

<ol>
<li>QUADRATIC time<ul>
<li>$O(n^2)$</li>
<li>QUADRATIC increase in number of steps for algorithm to complete execution for a given increase in size of dataset</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func bubbleSort(arr []int) { // computation here has a time complexity of O(n^2)
    n := len(arr)
    for i := 0; i &lt; n-1; i++ {
        for j := 0; j &lt; n-i-1; j++ {
            if arr[j] &gt; arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def bubble_sort(arr:[int]):
    for i in range(len(arr)):
        for q in range(len(arr)-i):
            if arr[q] &gt; arr[q+1]:
                arr[q], arr[q+1] = arr[q+1], arr[q] # just swap the values
</code></pre>

<ol>
<li>FACTORIAL time<ul>
<li>$O(n!)$</li>
<li>extremely slow and rarely used</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func factorial(n int) int { // computation here has a time complexity of O(n!)
    if n == 0 {
        return 1
    }
    return n * factorial(n-1)
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def factorial(n:int) -&gt; int:
    if n == 0:
        return 1
    else:
        return n * factorial(n-1) # recursive function call
</code></pre>

<h3>Summary</h3>
<p><img alt="" src="https://paper-attachments.dropbox.com/s_2D428973624E7FC84C7D69D11421DE762BEA6B6F3361231FCDCAE0425D14526F_1664885448372_Untitled.drawio+17.png" /></p>
<h2>Data Structures</h2>
<ol>
<li>Stack<ul>
<li>Last-in First-out <em>(LIFO)</em> data structure</li>
<li><code>push()</code>: appends an element to the TOP of the stack</li>
<li><code>pop()</code>: removes an element from the TOP of the stack</li>
<li>Used in<ul>
<li>undo/redo features in text editors</li>
<li>moving backward/forward in browser history</li>
<li>backtracking algorithms <em>(mazes, file directories)</em></li>
<li>function call stacks</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

type Stack struct {
    items []interface{} // interface is used here to allow the slice to hold elements of any datatype
}

func (s *Stack) Push(item interface{}) {
    s.items = append(s.items, item)
}

func (s *Stack) Pop() interface{} {
    if len(s.items) == 0 { // empty stack
        return nil 
    }
    index := len(s.items) - 1
    item := s.items[index]
    s.items = s.items[:index] 
    return item
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

class Stack:

    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.items: # if empty stack
            return None
        return self.items.pop()
</code></pre>

<ol>
<li>Queue<ul>
<li>First-in First-out <em>(FIFO)</em> data structure</li>
<li><code>add()</code>: enqueues an element to the END of the queue</li>
<li><code>remove()</code>: dequeues an element from the FRONT of the queue</li>
<li>Used in<ul>
<li>keyboard buffers</li>
<li>printer queues</li>
<li>priority queues</li>
<li>linked lists</li>
<li>breadth-first search algorithm</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

type Queue struct {
    items []interface{} // interface is used here to allow the slice to hold elements of any datatype
}

func (q *Queue) Add(item interface{}) {
    q.items = append(q.items, item)
}

func (q *Queue) Remove() interface{} {
    if len(q.items) == 0 { // empty queue
        return nil
    }
    item := q.items[0]
    q.items = q.items[1:] 
    return item
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

class Queue:

    def __init__(self):
        self.items = []

    def add(self, item):
        self.items.append(item)

    def remove(self):
        if not self.items: # if empty queue
            return None
        return self.items.pop(0)
</code></pre>

<ol>
<li>Priority Queue<ul>
<li>First-in First-out <em>(FIFO)</em> data structure</li>
<li>SORTS elements by PRIORITY, then dequeues elements of HIGHEST PRIORITY before elements of LOWER PRIORITY</li>
<li><code>add()</code>: enqueues an element to the END of the queue with a specified value and priority</li>
<li><code>remove()</code>: dequeues element of HIGHEST priority </li>
<li>Used in<ul>
<li>sorting algorithms <em>(heap sort)</em></li>
<li>graph algorithms <em>(dijkstra's algorithm, prim's algorithm)</em></li>
<li>system-related functions <em>(load balancing and interrupt handling)</em></li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

type Item struct { // item being EACH ELEMENT of the priority queue
    value interface{} // interface is used here to allow the value to hold elements of any datatype
    priority int
}

type PriorityQueue []*Item // priority queue is implemented via a sorted slice of Item elements

func (pq *PriorityQueue) Add(value interface{}, priority int) {
    item := &amp;Item{
        value: value,
        priority: priority,
    }
    *pq = append(*pq, item)
    sort.Slice(*pq, func(i int, j int) bool { // sort the priority queue based on priority
        return (*pq)[i].priority &lt; (*pq)[j].priority
    })
}

func (pq *PriorityQueue) Remove() interface{} {
    if len(*pq) == 0 { // empty priority queue
        return nil
    }
    item := (*pq)[0]
    *pq = (*pq)[1:] 
    return item.value
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

import heapq

class Item:

    def __init__(self, value, priority):
        self.value = value
        self.priority = priority

    def __lt__(self, other):
        return self.priority &lt; other.priority

class PriorityQueue:

    def __init__(self):
        self.items = []

    def add(self, value, priority):
        item = Item(value, priority)
        heapq.heappush(self.items, item)

    def remove(self):
        if not self.items: # if empty priority queue
            return None
        item = heapq.heappop(self.items)
        return item.value
</code></pre>

<ol>
<li>Linked List<ul>
<li>Collection of nodes that are stored in non-consecutive memory locations <em>(each node comprising a VALUE + pointer(s) to OTHER NODE'S memory address(es))</em></li>
<li><strong>SINGLY LINKED LIST</strong><ul>
<li>nodes comprise...<ol>
<li>VALUE</li>
<li>NEXT node's memory address</li>
</ol>
</li>
</ul>
</li>
<li><strong>DOUBLY LINKED LIST</strong><ul>
<li>nodes comprise...<ol>
<li>VALUE</li>
<li>PREVIOUS node's memory address</li>
<li>NEXT node's memory address</li>
</ol>
</li>
</ul>
</li>
<li>Used because<ul>
<li>advantageous to arraylists<ul>
<li>faster insertion and deletion of nodes with $0(1)$ time complexity</li>
<li>low memory waste</li>
</ul>
</li>
<li>dynamically allocates memory as required</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

type Node struct { // type definition for an element in a singly linked list
    value interface{} // interface is used here to allow the value to hold elements of any datatype
    next *Node // pointer to the next node
}

type LinkedList struct { // type definition for a singly linked list
    head *Node // define the head node
}

func (list *LinkedList) append(value interface{}) { // appends a new node to the END of the linked list

    newNode := &amp;Node{ // creation of current node
        value: value, 
        next: nil,
    }

    if list.head == nil { // if linked list empty, make current node the new head node
        list.head = newNode
        return
    }

    lastNode := list.head // traverse through the entire linked list until we reach the actual last node in the linkedlist where the next node is nil
    for lastNode.next != nil {
        lastNode = lastNode.next 
    }
    lastNode.next = newNode // make the current node the new last node

}

func (list *LinkedList) add(value interface{}, position int) error { // adds a new node to a specified position in the linked list

    if position &lt; 0 { // if negative index, invalid index
        return fmt.Errorf(&quot;invalid position&quot;) // error
    }

    newNode := &amp;Node{ // creation of current node
        value: value, 
        next: nil,
    }

    if position == 0 { // if insert current node at start of linked list, then just point current node's next at the old head
        newNode.next = list.head
        list.head = newNode
        return nil 
    }

    prevNode := list.head // traverse through the entire linked list until we reach the node at the desired position
    for i := 0; i &lt; position-1 &amp;&amp; prevNode != nil; i++ { 
        prevNode = prevNode.next
    }

    if prevNode == nil { // if insert current node at index outside length of the list, invalid index
        return fmt.Errorf(&quot;position out of range&quot;) // error
    } else { // assuming no error
        newNode.next = prevNode.next // assigns current node pointer to the previousnode's pointer to insert the current node in between the old previous node and its old next node
        prevNode.next = newNode // assigns pointer from previousnode to point to current node
        return nil
    }

}

func (list *LinkedList) remove(value interface{}) error { // remove a node from the linked list by value

    if list.head == nil { // empty list
        return fmt.Errorf(&quot;empty list&quot;) // error
    }

    if list.head.value == value { // check if current list head is node with desired value
        list.head = list.head.next
        return nil
    }

    prevNode := list.head // traverse through the entire linked list until we reach the node with the desired value
    for prevNode.next != nil &amp;&amp; prevNode.next.value != value {
        prevNode = prevNode.next
    }

    if prevNode.next == nil { // if reach the end of the linked list and the node with desired value not found
        return fmt.Errorf(&quot;element not found&quot;) // error
    } else { // node with desired value is found and it is the next node
        prevNode.next = prevNode.next.next // assigns pointer from current node to one node after the next node, to effectively &quot;remove&quot; it from the linked list
        return nil
    }

}

func (list *LinkedList) display() { // display all linkedlist nodes
    current := list.head // assigns current node to starting node
    for current != nil { // traverses through the entire linked list from start to finish
        fmt.Printf(&quot;%v -&gt; &quot;, current.value)
        current = current.next
    }
    fmt.Println(&quot;nil&quot;)
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

class Node:

    def __init__(self, value):
        self.value = value  # store value of the node
        self.next = None  # pointer to the next node

class LinkedList:

    def __init__(self):
        self.head = None  # initialize the head of the list as None

    def append(self, value):
        new_node = Node(value)  # create a new node
        if self.head is None:  # if the list is empty, set the new node as the head
            self.head = new_node
            return
        last_node = self.head
        while last_node.next:  # traverse to the last node
            last_node = last_node.next
        last_node.next = new_node  # set the new node as the next of the last node

    def add(self, value, position):
        if position &lt; 0:  # negative index is invalid
            raise ValueError(&quot;Invalid position&quot;)

        new_node = Node(value)  # create a new node
        if position == 0:  # if inserting at the head of the list
            new_node.next = self.head
            self.head = new_node
            return

        prev_node = self.head
        for _ in range(position - 1):
            if prev_node is None:
                raise ValueError(&quot;Position out of range&quot;)  # index is outside the length of the list
            prev_node = prev_node.next

        if prev_node is None:
            raise ValueError(&quot;Position out of range&quot;)

        new_node.next = prev_node.next  # link the new node to the node after the previous node
        prev_node.next = new_node  # link the previous node to the new node

    def remove(self, value):
        if self.head is None:  # if the list is empty
            raise ValueError(&quot;Empty list&quot;)

        if self.head.value == value:  # if the head is the node to remove
            self.head = self.head.next
            return

        prev_node = self.head
        while prev_node.next and prev_node.next.value != value:  # traverse to the node before the one to remove
            prev_node = prev_node.next

        if prev_node.next is None:  # node to remove was not found
            raise ValueError(&quot;Element not found&quot;)

        prev_node.next = prev_node.next.next  # remove the node by bypassing it

    def display(self):
        current = self.head  # start from the head node
        while current:  # traverse through the entire linked list
            print(f&quot;{current.value} -&gt; &quot;, end=&quot;&quot;)
            current = current.next
        print(&quot;None&quot;)  # end the display with 'None'
</code></pre>

<ol>
<li>Hash Table<ul>
<li>Collection of unique entries that enables fast insertion, lookup and deletion of entries by leveraging on hashing and buckets</li>
<li>Entry: a key-value pair</li>
<li>Hashing: computing an integer based on a key <em>(formulas vary depending on the key's datatype)</em> to determine an entry's index</li>
<li>Collision: when hashing a key returns the SAME index for more than one key</li>
<li>Bucket: indexed storage location for one or more entries that functions like a LINKED LIST, allowing multiple entries to be stored in cases of collision</li>
<li>Used because<ul>
<li>best case <strong>CONSTANT time complexity</strong> of $O(1)$</li>
<li>worst case <strong>LINEAR time complexity</strong> of $O(n)$<ul>
<li>less efficient for smaller datasets</li>
<li>extremely efficient for larger datasets</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

type Node struct { // type definition for a node in a hashtable
    key   string
    value string
    next  *Node
}

type HashTable struct { // type definition for the actual hash table struct
    size  int
    table []*Node
}

func NewHashTable(size int) *HashTable { // initialize a hash table of a specified size
    return &amp;HashTable{
        size:  size,
        table: make([]*Node, size),
    }
}

func (ht *HashTable) hash(key string) int { // generates an index from a key
    sum := 0
    for _, char := range key {
        sum += int(char)
    }
    return sum % ht.size
}

func (ht *HashTable) Insert(key, value string) { // insert a new key-value pair into the hash table
    index := ht.hash(key)
    newNode := &amp;Node{
        key:   key,
        value: value,
    }
    if ht.table[index] == nil { // handle collisions within the same bucket by implementing a linked list
        ht.table[index] = newNode
    } else {
        current := ht.table[index]
        for current.next != nil {
            current = current.next
        }
        current.next = newNode
    }
}

func (ht *HashTable) Get(key string) (string, bool) { // retrieve a value based on its key within the hash table
    index := ht.hash(key)
    current := ht.table[index]
    for current != nil {
        if current.key == key {
            return current.value, true
        }
        current = current.next
    }
    return &quot;&quot;, false
}

func (ht *HashTable) Delete(key string) { // delete a key-value pair from the hash table
    index := ht.hash(key)
    if ht.table[index] == nil {
        return
    }
    if ht.table[index].key == key {
        ht.table[index] = ht.table[index].next
        return
    }
    prev := ht.table[index]
    current := prev.next
    for current != nil {
        if current.key == key {
            prev.next = current.next
            return
        }
        prev = current
        current = current.next
    }
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

class Node:

    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None

class HashTable:

    def __init__(self, size):
        self.size = size
        self.table = [None] * size

    def hash(self, key):
        # Simple hash function: sum the ASCII values of all characters in the key and modulo by size
        return sum(ord(char) for char in key) % self.size

    def insert(self, key, value):
        index = self.hash(key)
        new_node = Node(key, value)
        if self.table[index] is None:
            # No collision, insert directly
            self.table[index] = new_node
        else:
            # Collision handling: chain nodes in a linked list
            current = self.table[index]
            while current.next is not None:
                current = current.next
            current.next = new_node

    def get(self, key):
        index = self.hash(key)
        current = self.table[index]
        while current is not None:
            if current.key == key:
                return current.value, True
            current = current.next
        return &quot;&quot;, False

    def delete(self, key):
        index = self.hash(key)
        current = self.table[index]
        if current is None:
            return
        if current.key == key:
            # The node to delete is the first node in the chain
            self.table[index] = current.next
            return
        prev = current
        current = current.next
        while current is not None:
            if current.key == key:
                # Unlink the node from the chain
                prev.next = current.next
                return
            prev = current
            current = current.next

    def display(self):
        for i in range(self.size):
            print(f&quot;Index {i}:&quot;, end=&quot;&quot;)
            current = self.table[i]
            while current:
                print(f&quot; -&gt; ({current.key}: {current.value})&quot;, end=&quot;&quot;)
                current = current.next
            print()
</code></pre>

<ol>
<li>
<p>Graph</p>
<ul>
<li>Non-linear aggregation of nodes and edges<ul>
<li>node: vertex that stores data</li>
<li>edge: connection between two nodes</li>
<li>adjacency: relationship between two nodes when they are connected by an edge</li>
</ul>
</li>
<li><strong>UNDIRECTED GRAPH</strong><ul>
<li>graph with bi-directional adjacency by default</li>
<li>eg. graph of a social network</li>
</ul>
</li>
<li><strong>DIRECTED GRAPH</strong><ul>
<li>graph with uni-directional adjacency by default <em>(arrowheads specify direction adjacency flows in)</em>, and bi-directional adjacency has to be specified with two seperate arrows</li>
<li>eg. graph of a street map <em>(some roads only allow one-way traffic)</em></li>
</ul>
</li>
<li>graphs can be represented by ADJACENCY MATRIXes or ADJACENCY LISTs as covered below</li>
<li>Used in <ul>
<li>representing social networks</li>
<li>visualising network routing</li>
<li>recommendation engines</li>
<li>GPS mapping applications</li>
<li>knowledge graphs</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Adjacency Matrix </p>
<ul>
<li>2d nested array of 0s and 1s which acts as a conceptual representation of adjacency between any two nodes in the graph</li>
<li>Used because<ul>
<li><strong>CONSTANT time complexity</strong> of $O(1)$<ul>
<li>relatively quicker compared to an ADJACENCY LIST for any given dataset</li>
</ul>
</li>
<li><strong>QUADRATIC space complexity</strong> of $O(n^2)$<ul>
<li>less efficient for smaller graph datasets</li>
<li>extremely efficient for larger graph datasets</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

type Graph struct { // type definition for an undirected graph represented by an adjacency matrix
    vertices int
    matrix   [][]bool
}

func NewGraph(vertices int) *Graph { // initializes an undirected graph with a given number of vertices
    matrix := make([][]bool, vertices)
    for i := range matrix {
        matrix[i] = make([]bool, vertices)
    }
    return &amp;Graph{
        vertices: vertices,
        matrix:   matrix,
    }
}

func (g *Graph) AddEdge(v1, v2 int) { // adds an undirected edge between two vertices
    if v1 &gt;= 0 &amp;&amp; v1 &lt; g.vertices &amp;&amp; v2 &gt;= 0 &amp;&amp; v2 &lt; g.vertices {
        g.matrix[v1][v2] = true
        g.matrix[v2][v1] = true
    }
}

func (g *Graph) PrintMatrix() { // displays adjacency matrix
    for _, row := range g.matrix {
        fmt.Println(row)
    }
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

class Graph:

    def __init__(self, vertices):
        self.vertices = vertices  # Number of vertices in the graph
        self.matrix = [[False] * vertices for _ in range(vertices)]  # Initialize the adjacency matrix

    def add_edge(self, v1, v2):
        if 0 &lt;= v1 &lt; self.vertices and 0 &lt;= v2 &lt; self.vertices:  # Check if vertices are valid
            self.matrix[v1][v2] = True  # Add edge from v1 to v2
            self.matrix[v2][v1] = True  # Add edge from v2 to v1 since it's an undirected graph

    def print_matrix(self):
        for row in self.matrix:  # Print each row of the adjacency matrix
            print(row)
</code></pre>

<ol>
<li>Adjacency List<ul>
<li>Array of LINKED LISTs, where each LINKED LIST head represents a unique node and its adjacent neighbour nodes</li>
<li>Used because<ul>
<li><strong>LINEAR time complexity</strong> of $O(n)$</li>
<li>space complexity of $O(numVertex + numEdge)$<ul>
<li>uses less space compared to an ADJACENCY MATRIX for any given dataset</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

type Node struct { // type definition for a node within an undirected graph 
    vertex int
    next   *Node
}

type Graph struct { // type definition for an undirected graph represented by an adjacency list
    vertices int
    adjList  []*Node
}

func NewGraph(vertices int) *Graph { // initializes an undirected graph with a given number of vertices
    adjList := make([]*Node, vertices)
    return &amp;Graph{
        vertices: vertices,
        adjList:  adjList,
    }
}

func (g *Graph) AddEdge(v1, v2 int) { // adds an undirected edge between two vertices
    if v1 &gt;= 0 &amp;&amp; v1 &lt; g.vertices &amp;&amp; v2 &gt;= 0 &amp;&amp; v2 &lt; g.vertices {
        nodeV1 := &amp;Node{vertex: v2, next: g.adjList[v1]}
        g.adjList[v1] = nodeV1
        nodeV2 := &amp;Node{vertex: v1, next: g.adjList[v2]}
        g.adjList[v2] = nodeV2
    }
}

func (g *Graph) PrintList() { // displays adjacency list
    for vertex, node := range g.adjList {
        fmt.Printf(&quot;Vertex %d -&gt; &quot;, vertex)
        for node != nil {
            fmt.Printf(&quot;%d &quot;, node.vertex)
            node = node.next
        }
        fmt.Println()
    }
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

class Node:

    def __init__(self, vertex):
        self.vertex = vertex
        self.next = None

class Graph:

    def __init__(self, vertices):
        self.vertices = vertices
        self.adj_list = [None] * vertices  # Initialize the adjacency list with None for each vertex

    def add_edge(self, v1, v2):
        if 0 &lt;= v1 &lt; self.vertices and 0 &lt;= v2 &lt; self.vertices:
            # Add the edge from v1 to v2
            node_v2 = Node(v2)
            node_v2.next = self.adj_list[v1]
            self.adj_list[v1] = node_v2

            # Add the edge from v2 to v1 (since the graph is undirected)
            node_v1 = Node(v1)
            node_v1.next = self.adj_list[v2]
            self.adj_list[v2] = node_v1

    def print_list(self):
        for vertex in range(self.vertices):
            print(f&quot;Vertex {vertex} -&gt;&quot;, end=&quot; &quot;)
            temp = self.adj_list[vertex]
            while temp:
                print(f&quot;{temp.vertex}&quot;, end=&quot; &quot;)
                temp = temp.next
            print()
</code></pre>

<ol>
<li>
<p>Tree</p>
<ul>
<li>Non-linear collection of nodes <em>(which store data)</em> organised in a hierachy, where nodes are connected by edges</li>
<li>Root node: top-most node with no incoming edges</li>
<li>Leaf node: bottom-most nodes with no outgoing edges</li>
<li>Branch nodes: nodes in the middle with both incoming and outgoing edges</li>
<li>Parent nodes: any node with an outgoing edge</li>
<li>Child nodes: any node with an incoming edge</li>
<li>Sibling nodes: any nodes sharing the same parent node</li>
<li>Subtree: smaller tree nested within a larger tree</li>
<li>Size of tree: total number of nodes</li>
<li>Depth of node: number of edges below root node</li>
<li>Height of node: number of edges above furthest leaf node</li>
<li>Used in<ul>
<li>file explorers</li>
<li>database searches</li>
<li>domain name servers</li>
<li>HTML DOM structure</li>
<li>expression parsing in interpreters and transpilers</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Binary Search Tree</p>
<ul>
<li>Ordered tree where each parent node has only two child nodes <em>(binary)</em> and each parent node's value is greater than the left child node and smaller than the right child node, including the root node</li>
<li>Used because<ul>
<li>easier to locate a node when they are ordered within a binary search tree</li>
<li>best case <strong>LOGARITHMIC time complexity</strong> of $O(log n)$</li>
<li>worst case <strong>LINEAR time complexity</strong> of $O(n)$</li>
<li><strong>LINEAR space complexity</strong> of $O(n)$</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

type Node struct { // type definition for a generic node within a binary search tree
    key   int
    left  *Node
    right *Node
}

type BST struct { // type definition for a binary search tree, which begins with its root node
    root *Node
}

func NewNode(key int) *Node { // initializes a new node with a given key
    return &amp;Node{
        key: key,
    }
}

func (bst *BST) Insert(key int) { // inserts a key into the binary search tree
    if bst.root == nil {
        bst.root = NewNode(key)
    } else {
        insertRecursive(bst.root, key)
    }
}

func insertRecursive(node *Node, key int) { // helper function for recursive insertion
    if key &lt; node.key {
        if node.left == nil {
            node.left = NewNode(key)
        } else {
            insertRecursive(node.left, key)
        }
    } else if key &gt; node.key {
        if node.right == nil {
            node.right = NewNode(key)
        } else {
            insertRecursive(node.right, key)
        }
    }
}

func (bst *BST) Search(key int) bool { // searches for a key within the binary search tree
    return searchRecursive(bst.root, key)
}

func searchRecursive(node *Node, key int) bool { // helper function for recursive search
    if node == nil {
        return false
    }
    if key == node.key {
        return true
    } else if key &lt; node.key {
        return searchRecursive(node.left, key)
    } else {
        return searchRecursive(node.right, key)
    }
}

func (bst *BST) InOrderTraversal() { // performs in-order traversal of binary search tree
    inOrderRecursive(bst.root)
    fmt.Println()
}

func inOrderRecursive(node *Node) { // helper function for recursive in-order traversal
    if node != nil {
        inOrderRecursive(node.left)
        fmt.Printf(&quot;%d &quot;, node.key)
        inOrderRecursive(node.right)
    }
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

class Node:

    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

class BST:

    def __init__(self):
        self.root = None

    def insert(self, key):
        if self.root is None:
            self.root = Node(key)
        else:
            self._insert_recursive(self.root, key)

    def _insert_recursive(self, node, key):
        if key &lt; node.key:
            if node.left is None:
                node.left = Node(key)
            else:
                self._insert_recursive(node.left, key)
        elif key &gt; node.key:
            if node.right is None:
                node.right = Node(key)
            else:
                self._insert_recursive(node.right, key)

    def search(self, key):
        return self._search_recursive(self.root, key)

    def _search_recursive(self, node, key):
        if node is None:
            return False
        if key == node.key:
            return True
        elif key &lt; node.key:
            return self._search_recursive(node.left, key)
        else:
            return self._search_recursive(node.right, key)

    def in_order_traversal(self):
        self._in_order_recursive(self.root)
        print()  # Newline for cleaner output

    def _in_order_recursive(self, node):
        if node is not None:
            self._in_order_recursive(node.left)
            print(node.key, end=' ')
            self._in_order_recursive(node.right)
</code></pre>

<h2>Algorithms</h2>
<ol>
<li>Linear Search<ul>
<li><strong>LINEAR time complexity</strong> of $O(n)$</li>
<li>iterates through a collection one element at a time</li>
<li>pros<ul>
<li>dataset can be unsorted</li>
<li>fast for searching small to medium-sized datasets</li>
<li>useful for data structures without random access </li>
</ul>
</li>
<li>cons<ul>
<li>slow for large datasets</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func linearSearch(arr []interface{}, target interface{}) int { // returns index of target element if found
    for i, item := range arr {
        if item == target {
            return i 
        }
    }
    return -1 // returns -1 if target element not found
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def linear_search(arr, target):
    for i, item in enumerate(arr):
        if item == target:
            return i
    return -1
</code></pre>

<ol>
<li>Binary Search<ul>
<li><strong>LOGARITHMIC time complexity</strong> of $O(log n)$</li>
<li>eliminates half of the collection at each step to find the target element</li>
<li>pros<ul>
<li>more efficient for large datasets</li>
</ul>
</li>
<li>cons<ul>
<li>dataset has to be sorted</li>
<li>less efficient for smaller datasets</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func binarySearch(arr []interface{}, target interface{}) int { 
    left, right := 0, len(arr)-1
    for left &lt;= right {
        mid := left + (right-left)/2
        if arr[mid] == target {
            return mid // returns index of target element
        }
        if arr[mid] &lt; target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1 // returns -1 if target element not found
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left &lt;= right:
        mid = left + (right - left) * 2
        if arr[mid] == target:
            return mid
        elif arr[mid] &lt; target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
</code></pre>

<ol>
<li>Interpolation Search<ul>
<li><strong>average time complexity</strong> of $O(log(log n))$</li>
<li><strong>worst case LINEAR time complexity</strong> of $O(n)$</li>
<li>guesses where a value might be based on estimated probe results, with incorrect probes narrowing the search area and recalculating a new probe</li>
<li>improvement over BINARY searches that are best used for uniformly distributed datasets</li>
<li>pros<ul>
<li>more efficient for uniformly distributed datasets</li>
<li>more efficient for large datasets</li>
</ul>
</li>
<li>cons<ul>
<li>dataset has to be sorted</li>
<li>dataset has to be uniformly distributed</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func interpolationSearch(arr []interface{}, target interface{}) int {

    low := 0
    high := len(arr) - 1

    for low &lt;= high &amp;&amp; target &gt;= arr[low] &amp;&amp; target &lt;= arr[high] {
        pos := low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low])

        if arr[pos] == target {
            return pos // returns index of target element
        }

        if arr[pos] &lt; target {
            low = pos + 1
        } else {
            high = pos - 1
        }

    }

    return -1 // returns -1 if target element not found

}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def interpolation_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low &lt;= high and target &gt;= arr[low] and target &lt;= arr[high]:
        pos = low + ((target - arr[low]) * (high - low)) * (arr[high] - arr[low])

        if arr[pos] == target:
            return pos
        elif arr[pos] &lt; target:
            low = pos + 1
        else:
            high = pos - 1

    return -1
</code></pre>

<ol>
<li>Depth First Search<ul>
<li>search algorithm to traverse a tree or graph one BRANCH at a time<ol>
<li>pick a route</li>
<li>keep on going until a dead end or previously visited node is reached</li>
<li>backtrack to last node with unvisited adjacent neighbour nodes</li>
<li>repeat step 1</li>
</ol>
</li>
<li><strong>time complexity</strong> of $O(numVertex + numEdge)$</li>
<li><strong>LINEAR space complexity</strong> of $O(n)$</li>
<li>pros<ul>
<li>utilises a STACK</li>
<li>child nodes are visited before sibling nodes</li>
<li>better if destination node is on average FURTHER from start node</li>
</ul>
</li>
<li>cons<ul>
<li>often returns non-optimal paths</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func (g *Graph) DFSUtil(v int) { // helper function for DFS
    g.visited[v] = true
    fmt.Printf(&quot;%d &quot;, v)
    for node := g.adjList[v]; node != nil; node = node.next { // recur for all adjacent vertices
        if !g.visited[node.vertex] {
            g.DFSUtil(node.vertex)
        }
    }
}

func (g *Graph) DFS() {
    for i := 0; i &lt; g.vertices; i++ {
        if !g.visited[i] {
            g.DFSUtil(i)
        }
    }
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

class Graph:

    def __init__(self, vertices):
        self.vertices = vertices
        self.adj_list = [[] for _ in range(vertices)]
        self.visited = [False] * vertices

    def add_edge(self, u, v):
        self.adj_list[u].append(v)

    def dfs_util(self, v):
        self.visited[v] = True
        print(v, end=&quot; &quot;)
        for node in self.adj_list[v]:
            if not self.visited[node]:
                self.dfs_util(node)

    def dfs(self):
        for i in range(self.vertices):
            if not self.visited[i]:
                self.dfs_util(i)
</code></pre>

<ol>
<li>Breadth First Search<ul>
<li>search algorithm to traverse a tree or graph one LEVEL at a time<ol>
<li>traverse one node at a time in every direction</li>
<li>once all directions have been expanded one node, repeat step 1</li>
</ol>
</li>
<li><strong>time complexity</strong> of $O(numVertex + numEdge)$</li>
<li><strong>LINEAR space complexity</strong> of $O(n)$ if implemented with a queue</li>
<li><strong>space complexity</strong> of $O(numVertex + numEdge)$ if implemented with an adjacency list</li>
<li>pros<ul>
<li>utilises a QUEUE</li>
<li>sibling nodes are visited before child nodes</li>
<li>better if destination node is on average CLOSER to start node</li>
</ul>
</li>
<li>cons<ul>
<li>less efficient on denser graph datasets with many edges</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func (g *Graph) BFS(startVertex int) {
    queue := []int{} // initializes a queue for BFS traversal
    g.visited[startVertex] = true
    queue = append(queue, startVertex)
    for len(queue) &gt; 0 { 
        currentVertex := queue[0]
        queue = queue[1:] // dequeues a vertex from the queue
        fmt.Printf(&quot;%d &quot;, currentVertex)
        for node := g.adjList[currentVertex]; node != nil; node = node.next { // check to ensure adjacent vertices have not been visited
            if !g.visited[node.vertex] {
                g.visited[node.vertex] = true
                queue = append(queue, node.vertex)
            }
        }
    }
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

from collections import deque

class Graph:

    def __init__(self, vertices):
        self.vertices = vertices
        self.adj_list = [[] for _ in range(vertices)]
        self.visited = [False] * vertices

    def add_edge(self, u, v):
        self.adj_list[u].append(v)

    def bfs(self, start_vertex):
        queue = deque()
        self.visited[start_vertex] = True
        queue.append(start_vertex)

        while queue:
            current_vertex = queue.popleft()
            print(current_vertex, end=&quot; &quot;)

            for node in self.adj_list[current_vertex]:
                if not self.visited[node]:
                    self.visited[node] = True
                    queue.append(node)
</code></pre>

<ol>
<li>Bubble Sort<ul>
<li><strong>QUADRATIC time complexity</strong> of $O(n^2)$</li>
<li><strong>CONSTANT space complexity</strong> of $O(1)$</li>
<li>compares pairs of adjacent elements and swaps them if they are not in order</li>
<li>pros<ul>
<li>relatively fast for small datasets</li>
<li>lower CONSTANT space complexity since collection sorted in place</li>
</ul>
</li>
<li>cons<ul>
<li>extremely slow for medium and large datasets</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func bubbleSort(arr []int) { // slices are reference types in Go so changes made to the slice within the function are reflected outside the function
    n := len(arr)
    for i := 0; i &lt; n-1; i++ {
        for j := 0; j &lt; n-i-1; j++ {
            if arr[j] &gt; arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - i - 1):
            if arr[j] &gt; arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
</code></pre>

<ol>
<li>Selection Sort<ul>
<li><strong>QUADRATIC time complexity</strong> of $O(n^2)$</li>
<li><strong>CONSTANT space complexity</strong> of $O(1)$</li>
<li>iterates across each element in a collection and compares against and stores the minimum value, swapping variables after each iteration</li>
<li>pros<ul>
<li>relatively fast for small and medium datasets</li>
<li>lower CONSTANT space complexity since collection sorted in place</li>
</ul>
</li>
<li>cons<ul>
<li>slower for large datasets</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func selectionSort(arr []int) { // slices are reference types in Go so changes made to the slice within the function are reflected outside the function
    n := len(arr)
    for i := 0; i &lt; n-1; i++ {
        minIndex := i 
        for j := i + 1; j &lt; n; j++ {
            if arr[j] &lt; arr[minIndex] {
                minIndex = j
            }
        }
        arr[i], arr[minIndex] = arr[minIndex], arr[i]
    }
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        min_index = i
        for j in range(i + 1, n):
            if arr[j] &lt; arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
</code></pre>

<ol>
<li>Insertion Sort<ul>
<li><strong>QUADRATIC time complexity</strong> of $O(n^2)$</li>
<li><strong>CONSTANT space complexity</strong> of $O(1)$</li>
<li>compares all elements to the left of a given element, then shift elements to the right to make room to insert a value</li>
<li>pros<ul>
<li>fast for small and medium datasets</li>
<li>fewer steps than BUBBLE SORT</li>
<li>best case LINEAR time complexity is $O(n)$ compared to SELECTION SORT'S $O(n^2)$</li>
<li>lower CONSTANT space complexity since collection sorted in place</li>
</ul>
</li>
<li>cons<ul>
<li>slower for large datasets</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func insertionSort(arr []int) { // slices are reference types in Go so changes made to the slice within the function are reflected outside the function
    n := len(arr)
    for i := 1; i &lt; n; i++ {
        key := arr[i]
        j := i - 1
        for j &gt;= 0 &amp;&amp; arr[j] &gt; key {
            arr[j+1] = arr[j]
            j = j - 1
        }
        arr[j+1] = key
    }
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def insertion_sort(arr):
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        while j &gt;= 0 and arr[j] &gt; key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
</code></pre>

<ol>
<li>Merge Sort<ul>
<li><strong>QUASILINEAR time complexity</strong> of $O(n log n)$</li>
<li><strong>LINEAR space complexity</strong> of $O(n)$</li>
<li>recursively split collection in half, sort each half, then recombine the two halves</li>
<li>pros<ul>
<li>faster than all sorting algorithms with QUADRATIC time complexity <em>(bubble sort, selection sort, insertion sort)</em></li>
</ul>
</li>
<li>cons<ul>
<li>higher LINEAR space complexity since new subarrays are created to store elements for each level of recursion</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func mergeSort(arr []int) []int { 
    if len(arr) &lt;= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := make([]int, 0)
    for len(left) &gt; 0 || len(right) &gt; 0 {
        if len(left) == 0 {
            return append(result, right...)
        }
        if len(right) == 0 {
            return append(result, left...)
        }
        if left[0] &lt;= right[0] {
            result = append(result, left[0])
            left = left[1:]
        } else {
            result = append(result, right[0])
            right = right[1:]
        }
    }
    return result
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def merge_sort(arr):
    if len(arr) &lt;= 1:
        return arr
    mid = len(arr) * 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    while len(left) &gt; 0 or len(right) &gt; 0:
        if len(left) == 0:
            return result + right
        if len(right) == 0:
            return result + left
        if left[0] &lt;= right[0]:
            result.append(left[0])
            left = left[1:]
        else:
            result.append(right[0])
            right = right[1:]
    return result
</code></pre>

<ol>
<li>Quick Sort<ul>
<li><strong>QUASILINEAR time complexity</strong> of $O(n log n)$ in best case and average case</li>
<li><strong>QUADRATIC time complexity</strong> of $O(n^2)$ in worst case </li>
<li><strong>LOGARITHMIC space complexity</strong> of $O(log n)$</li>
<li>moves smaller elements in a collection to left side of a pivot element, then recursively divide the collection into 2 partitions</li>
<li>pros<ul>
<li>faster than all sorting algorithms with QUADRATIC time complexity <em>(bubble sort, selection sort, insertion sort)</em> in best and average cases</li>
<li>lower LOGARITHMIC space complexity than MERGE SORT'S LINEAR space complexity since collection sorted in place</li>
</ul>
</li>
<li>cons<ul>
<li>higher LOGARITHMIC space complexity since quick sort relies on recursion </li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func quickSort(arr []int) { // slices are reference types in Go so changes made to the slice within the function are reflected outside the function
    if len(arr) &lt;= 1 {
        return
    }
    pivotIndex := partition(arr)
    quickSort(arr[:pivotIndex])
    quickSort(arr[pivotIndex+1:])
}

func partition(arr []int) int {
    pivot := arr[len(arr)-1]
    i := -1
    for j := 0; j &lt; len(arr)-1; j++ {
        if arr[j] &lt; pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[len(arr)-1] = arr[len(arr)-1], arr[i+1]
    return i + 1
}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def quick_sort(arr):
    if len(arr) &lt;= 1:
        return arr
    pivot_index = partition(arr)
    return quick_sort(arr[:pivot_index]) + [arr[pivot_index]] + quick_sort(arr[pivot_index + 1:])

def partition(arr):
    pivot = arr[-1]
    i = -1
    for j in range(len(arr) - 1):
        if arr[j] &lt; pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[-1] = arr[-1], arr[i + 1]
    return i + 1
</code></pre>

<h3>Leetcode Algorithms</h3>
<p>The below algorithms are often used within Leetcode problems.</p>
<ol>
<li>Sliding Window <ul>
<li>Create a fixed-size window that moves through an array and performs a given operation</li>
<li>Used in problems involving<ul>
<li>substring searches </li>
<li>subarray slice searches</li>
</ul>
</li>
<li>Example questions <ul>
<li><a href="https://leetcode.com/problems/maximum-subarray/">Leetcode Problem #53: Maximum Subarray</a></li>
<li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">Leetcode Problem #3: Longest Substring Without Repeating Characters</a></li>
<li><a href="https://leetcode.com/problems/longest-consecutive-sequence/description/">Leetcode Problem #128: Longest Consecutive Sequence</a></li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func findMaxSum(arr []int, k int) int {

    windowSum := 0
    maxSum := 0

    n := len(arr)
    if n &lt; k {
        return -1 // out of range index error
    }

    for i := 0; i &lt; k; i++ {
        windowSum += arr[i]
    }
    maxSum = windowSum

    for i := k; i &lt; n; i++ {
        windowSum += arr[i] - arr[i-k]
        if windowSum &gt; maxSum {
            maxSum = windowSum
        }
    }

    return maxSum

}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def find_max_sum(arr, k):

    n = len(arr)
    if n &lt; k:
        return -1  # out of range index error

    window_sum = sum(arr[:k])
    max_sum = window_sum

    for i in range(k, n):
        window_sum += arr[i] - arr[i - k]
        if window_sum &gt; max_sum:
            max_sum = window_sum

    return max_sum
</code></pre>

<ol>
<li>Two Pointer<ul>
<li>Two pointers traverse an array simultaneously <em>(from different ends or with a stipulated distance between them)</em></li>
<li>Just a glorified way of saying two values are being stored for a given solution</li>
<li>Used in problems involving<ul>
<li>finding pairs in a sorted array </li>
<li>merging two sorted arrays</li>
</ul>
</li>
<li>Example questions<ul>
<li><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">Leetcode Problem #167: Two Sum II - Input array is sorted</a></li>
<li><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">Leetcode Problem #19: Remove Nth Node From End of List</a></li>
<li><a href="https://leetcode.com/problems/container-with-most-water/">Leetcode Problem #11: Container With Most Water</a></li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func findPairSum(arr []int, target int) []int {

    left := 0 // left pointer index
    right := len(arr) - 1 // right pointer index

    for left &lt; right {
        sum := arr[left] + arr[right]
        if sum == target {
            return []int{arr[left], arr[right]}
        } else if sum &lt; target {
            left++
        } else {
            right--
        }
    }

    return nil // nothing found

}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def find_pair_sum(arr, target):

    left = 0
    right = len(arr) - 1

    while left &lt; right:

        current_sum = arr[left] + arr[right]

        if current_sum == target:
            return [arr[left], arr[right]]

        elif current_sum &lt; target:
            left += 1

        else:
            right -= 1

    return None
</code></pre>

<ol>
<li>Three Pointer<ul>
<li>Extension of two pointer algorithm</li>
<li>Three pointers traverse an array simultaneously <em>(from different ends or with a stipulated distance between them)</em></li>
<li>Just a glorified way of saying three values are being stored for a given solution</li>
<li>Used in problems involving<ul>
<li>finding triplets satisfying a predicate</li>
<li>merging three or more sorted arrays</li>
<li>partitioning </li>
</ul>
</li>
<li>Example questions<ul>
<li><a href="https://leetcode.com/problems/3sum/">Leetcode Problem #15: 3Sum</a></li>
<li><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/">Leetcode Problem #21: Merge Two Sorted Lists</a></li>
<li><a href="https://leetcode.com/problems/merge-k-sorted-lists/">Leetcode Problem #23: Merge k Sorted Lists</a></li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="codehilite"><code class="language-go">// ----- Go implementation -----

func findTriplet(arr []int, target int) []int {

    n := len(arr)

    for i := 0; i &lt; n-2; i++ {

        left := i + 1 // left pointer
        right := n - 1 // right pointer

        for left &lt; right {
            sum := arr[i] + arr[left] + arr[right]
            if sum == target {
                return []int{arr[i], arr[left], arr[right]}
            } else if sum &lt; target {
                left++
            } else {
                right--
            }
        }

    }

    return nil // nothing found

}
</code></pre>

<pre class="codehilite"><code class="language-py"># ----- Python implementation -----

def find_triplet(arr, target):

    n = len(arr)

    for i in range(n - 2):

        left = i + 1
        right = n - 1

        while left &lt; right:

            current_sum = arr[i] + arr[left] + arr[right]

            if current_sum == target:
                return [arr[i], arr[left], arr[right]]

            elif current_sum &lt; target:
                left += 1

            else:
                right -= 1

    return None
</code></pre>

<h2>More on</h2>
<ul>
<li><a href="https://frontendmasters.com/courses/algorithms/">primeagen's last algorithms course</a></li>
<li><a href="https://youtube.com/playlist?list=PLZPZq0r_RZON1eaqfafTnEexRzuHbfZX8&amp;si=Fdvpj73H-3FqQpBs">brocode playlist</a></li>
<li><a href="https://youtu.be/8hly31xKli0?si=aEbuILtMyqXl5PPu">freecodecamp</a></li>
<li><a href="https://cs50.harvard.edu/x/2024/weeks/5/">cs50 week 5 data structures</a></li>
<li><a href="https://youtu.be/5NgNicANyqM?si=qYD6DDvV5Fe3n-AA">cs50 ai with python</a></li>
<li><a href="https://visualgo.net/en/sorting">sorting algorithms explained</a></li>
<li><a href="https://www.toptal.com/developers/sorting-algorithms">sorting algorithms visualised</a></li>
<li><a href="https://www.bigocheatsheet.com/">big o notation cheatsheet</a></li>
<li><a href="https://learnxinyminutes.com/docs/asymptotic-notation/">learn asymptotic notation in y minutes</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
