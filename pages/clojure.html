<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Clojure - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Clojure</h2>

        <dl>
          <dt>File size</dt>
          <dd>19.1KB</dd>

          <dt>Lines of code</dt>
          <dd>381</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Clojure</code></h1>
<p>A Lisp dialect with a stronger emphasis on functional programming than Common Lisp.</p>
<h2>Comments</h2>
<pre class="codehilite"><code class="language-clj">; ---------- COMMENT -----------
    ; single-line comments begin with a semicolon
    ; there is no built-in implementation for multi-line comments
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-clj">; ---------- PRINT ----------
    ; println =&gt; prints strings to stdout and appends a newline to the output
    ; prn =&gt; prints a more readable representation of data structures to the stdout and appends a newline to the output

(println &quot;Hello world!&quot;) ; prints &quot;Hello world!&quot; to the console with a newline
(prn {:cereal-chicken 2.50 :thai-fish 3.00 :egg 1.25}) ; prints the array map in a human-readable format to the console with a newline
</code></pre>

<h2>Quickstart</h2>
<pre class="codehilite"><code class="language-clj">; ----------- QUICKSTART -----------
    ; clojure is comprised of forms (list of whitespace delimited things surrounded by () parantheses, similar to expressions)
    ; clojure assumes the first thing is a function or macro call, and the remaining things are arguments
    ; clojure types are immutable, so remember to reassign returned values (functional programming!)
    ; ns =&gt; first call in a clojure file to set the namespace

(ns parklane-cai-fan) ; sets everything in the file to be within the parklane-cai-fan namespace
</code></pre>

<h2>Variables</h2>
<pre class="codehilite"><code class="language-clj">; --------- VARIABLE ----------
    ; def =&gt; creates a global variable and assigns a corresponding value
    ; let =&gt; creates a local variable lexically scoped to the current scope of () brackets and assigns a corresponding value, and has an implicit return of the last expression

(def an-int 1) ; global-binding of a variable (global variable)
(def a-float 2.2) ; global-binding of a variable (global variable)
(def a-string &quot;cereal chicken&quot;) ; global-binding of a variable (global variable)
(def a-bool true) ; global-binding of a variable (global variable)

(let [a 1 b 2]
  (&gt; a b)) ; this creates local bindings, then evaluates to false from the last expression
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-clj">; ---------- TYPE -----------
    ; integer 
    ; float =&gt; floating point numbers
    ; string =&gt; double quotation marks
    ; boolean =&gt; true, false
    ; nil =&gt; special value to represent the absence of data
    ; keyword =&gt; strings with efficiency bonuses, declared with : colon in front of keyword

1 ; integer
1.23 ; float
&quot;watermelon&quot; ; string
false ; boolean
nil ; special value nil
:a ; keyword

; USEFUL TYPE FUNCTIONS
    ; quote =&gt; prevents literal data from being evaluated, has a shorthand '
    ; ' =&gt; prevents literal data from being evaluated, the shorthand for quote
    ; eval =&gt; evaluates a literal list

(quote (+ 1 2)) ; this literal list of data won't be evaluated and will evaluate to value of (+ 1 2)
'(+ 1 2) ; this literal list of data won't be evaluated, evaluates to value of (+ 1 2)
(eval '(+ 3 4)) ; this forces an evaluation on a quoted list, thus evaluating this to the value of 7
</code></pre>

<h2>Operators</h2>
<pre class="codehilite"><code class="language-clj">; ---------- OPERATOR ----------

; ARITHMETIC OPERATORS
    ; + =&gt; addition
    ; - =&gt; subtraction
    ; * =&gt; multiplication
    ; / =&gt; division
    ; mod =&gt; modulo

; LOGICAL OPERATORS
    ; and
    ; or
    ; not

; COMPARISON OPERATORS
    ; = =&gt; partial equality check for value
    ; not= =&gt; partial inequality check for value
    ; == =&gt; complete equality check for type and value
    ; not== =&gt; complete inequality check for type and value
    ; &lt; &gt; &lt;= &gt;= for other comparison checks

(+ 1 1) ; evaluates to 2
(- 2 1) ; evaluates to 1
(* 1 2) ; evaluates to 2
(/ 2 1) ; evaluates to 2
(mod 5 2) ; evaluates to 1

(not true) ; evaluates to false
(false and true) ; evaluates to false
(false or true) ; evaluates to true

(= 1 1) ; evaluates to true
(= 2 1) ; evaluates to false
(= 1 &quot;1&quot;) ; evaluates to true
(== 1 &quot;1&quot;) ; evaluates to false
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-clj">; ---------- CONTROL STRUCTURE ----------

; CONDITIONAL CHECKS
    ; if =&gt; operates as you'd expect, called as a function like everything else in clojure
        ; general syntax is (if {CONDITIONAL CHECK} {THEN EXPRESSION} {ELSE EXPRESSION})
    ; cond =&gt; evaluates each specified predicate in order and evaluates to the value of the first true condition, equivalent to an if elseif else chain in other languages
        ; :else =&gt; added as the final else case in a cond chain
    ; case =&gt; equivalent to match-case chain in other languages
        ; :else =&gt; added as the final default case in a case chain

(def x 10)
(if (&gt; x 5)
  &quot;Greater than 5&quot;
  &quot;Less than or equal to 5&quot;) ; this evaluates to &quot;Greater than 5&quot;

(def y 10)
(cond
  (&gt; y 15) &quot;Greater than 15&quot;
  (&gt; y 10) &quot;Greater than 10&quot;
  :else &quot;10 or less&quot;) ; this evaluates to &quot;10 or less&quot;

(def day-of-week 3)
(case day-of-week
  1 &quot;Sunday&quot;
  2 &quot;Monday&quot;
  3 &quot;Tuesday&quot;
  :else &quot;Unknown day&quot;) ; this evaluates to &quot;Tuesday&quot;

; LOOPS
    ; for most iterative solutions, clojure's functional programming constructs are encouraged instead of loops (map, reduce, filter)
    ; loop =&gt; creates and defines the lexical scope of a loop, used alongside recur
    ; recur =&gt; indicates to initiate another iteration of the current loop with recursion
    ; doseq =&gt; creates a loop that iterates over a specified structure, achieved without explicit recursion

(defn countdown-recur [n]
  (loop [i n]
    (if (&lt;= i 0)
      &quot;Blast off!&quot;
      (do
        (println i)
        (recur (dec i)))))) ; function definition for a function that contains a recursive loop which counts down from n to 0, then prints blast off, here recur is used to decrement i by 1 and initiate another iteration of the loop

(defn countdown-iter [n]
  (doseq [i (range n 0 -1)]
    (println i))
  (println &quot;Blast off!&quot;)) ; function defintion for a function that achieves the same thing as the above function, but does it using doseq to create a loop that does not rely on explicit recursion but instead iterates over a vector created using the range function
</code></pre>

<h2>Data structures</h2>
<pre class="codehilite"><code class="language-clj">; ---------- DATA STRUCTURE -----------
    ; collection =&gt; groups of data (lists, vectors)
    ; sequence =&gt; abstract descriptions of lists of data (lists)

; LIST
    ; linked-list data structure
    ; declared with () brackets, must be quoted as a literal with ' to prevent clojure from thinking its a function
    ; list =&gt; creates a list literal, an alternative to declaring a list literal with '
    ; range =&gt; creates a list of range 0 to a specified length, no specification results in an infinite series
    ; take =&gt; retrieve a slice of a list based on length from the front
    ; cons =&gt; insert an item to the start of a list
    ; conj =&gt; inserts an item to the start of a list (the most efficient method of insertion for a list)
    ; concat =&gt; concatenates collections (both lists and vectors) together and returns them as a list
    ; map =&gt; apply a specified function on every item within the list
    ; filter =&gt; apply a specified function on every item within the list and keep those that meet the specified function predicate
    ; reduce =&gt; aggregate multiple items within a list to a single result by applying the specified function to each item and accumulating the result, can take an initial argument value also

(list 1 2 3) ; creates a list literal of value (1 2 3), the equivalent of '(1 2 3)
(range) ; creates an infinite series of value (0 1 2 3 4 ...)
(range 4) ; creates a list of value (0 1 2 3) with length 4
(take 4 (range)) ; retrieves a slice of length 4 from an infinite list, evaluating to (0 1 2 3)
(cons 4 '(1 2 3)) ; this evaluates to (4 1 2 3)
(conj '(1 2 3) 4) ; this evaluates to (4 1 2 3) also by inserting the element at the start of the list
(concat '(1 2) '(3 4)) ; this evaluates to (1 2 3 4)
(concat [1 2] '(3 4)) ; this also evaluates to (1 2 3 4)
(map inc '(1 2 3)) ; this evaluates to (2 3 4)
(filter even? '(1 2 3)) ; this evaluates to (2)
(reduce + '(1 2 3 4)) ; this evaluates to 10
(reduce conj [] '(3 2 1)) ; this evaluates to [3 2 1]

; VECTOR
    ; array-backed vector
    ; declared with [] square brackets
    ; cons =&gt; insert an item to the start of a vector
    ; conj =&gt; appends an item to the end of a vector (the most efficient method of insertion for a vector)
    ; concat =&gt; concatenates collections (both lists and vectors) together and returns them as a list
    ; map =&gt; apply a specified function on every item within the vector
    ; filter =&gt; apply a specified function on every item within the vector and keep those that meet the specified function predicate
    ; reduce =&gt; aggregate multiple items within a vector to a single result by applying the specified function to each item and accumulating the result, can take an initial argument value also

[1 2 3] ; creates a vector literal of value [1 2 3]
(cons 4 [1 2 3]) ; this evaluates to (4 1 2 3)
(conj [1 2 3] 4) ; this evaluates to [1 2 3 4] by appending the element to the end of the vector
(concat [1 2] [3 4]) ; this evaluates to (1 2 3 4)
(concat [1 2] '(3 4)) ; this also evaluates to (1 2 3 4)
(map inc [1 2 3]) ; this evaluates to (2 3 4)
(filter even? [1 2 3]) ; this evaluates to (2)
(reduce + [1 2 3 4]) ; this evaluates to 10
(reduce conj [] [3 2 1]) ; this evaluates to [3 2 1]

; ARRAY MAP
    ; declared with {} curly braces
    ; assoc =&gt; adds new key-value pairs to an array map and returns the new array map
    ; dissoc =&gt; removes key-value pairs from an array map and returns the new array map
    ; retains key-value pair order, slower lookups than hash maps
    ; keys can be any hashable type, but keywords are used as keys by convention
    ; array maps are automatically converted to hash maps when their size gets big enough
    ; retrieve a value from its key by calling the array map as a function, retrieving an absent key returns nil

{:a 1 :b 2 :c 3} ; an array map literal
(def watermelon-array-map {&quot;a&quot; 4 &quot;cd&quot; 10 &quot;ef&quot; 100}) ; creates an array map and assigns it to a variable
(watermelon-array-map &quot;cd&quot;) ; evaluates to the integer value 10
(def new-watermelon-array-map (assoc watermelon-array-map &quot;watermelon-pie&quot; 2000)) ; adds a new key-value pair to watermelon-array-map, then assigns the new array map value to the variable new-watermelon-array-map since clojure types are immutable
(def edited-watermelon-array-map (dissoc new-watermelon-array-map &quot;a&quot; &quot;cd&quot;)) ; removes the key-value pairs of key &quot;a&quot; and &quot;cd&quot; from the new-watermelon-array-map and returns the new array map, then assigns that value to the variable edited-watermelon-array-map since clojure types are immutable

; HASH MAP
    ; hash-map =&gt; creates a hash map literal
    ; assoc =&gt; adds new key-value pairs to a hash map and returns the new hash map
    ; dissoc =&gt; removes key-value pairs from a hash map and returns the new hash map
    ; does not retain key-value pair order, faster lookups than array maps
    ; keys can be any hashable type, but keywords are used as keys by convention
    ; retrieve a value from its key by calling the hash map as a function, retrieving an absent key returns nil

(hash-map :a 1 :b 2 :c 4) ; a hash map literal
(def apple-hash-map (hash-map :z 100.00 :in 6 :kl 2)) ; creates a hash map and assigns it to a variable
(apple-hash-map :z) ; evaluates to the float value of 100.00
(def new-apple-hash-map (assoc apple-hash-map :apple-pie 10)) ; adds a new key-value pair to apple-hash-map, then assigns the new hash map value to the variable new-apple-hash-map since clojure types are immutable
(def edited-apple-hash-map (dissoc new-apple-hash-map :z :kl)) ; removes the key-value pairs of key :z and :kl from new-apple-hash-map and returns the new hash map, then assigns that value to the variable edited-apple-hash-map since clojure types are immutable

; SET
    ; declared with #{} 
    ; set =&gt; creates a set, alongside [] square brackets
    ; conj =&gt; appends a specified member to the set
    ; disj =&gt; removes a member from a set by value
    ; test for set members by calling the set as a function
    ; similar to sets in other languages, with a range of functions for operation (see clojure.sets namespace)

#{1 2 3} ; creates a set literal
(set [1 2 3 4]) ; also creates a set literal which evaluates to the value #{1 2 3 4}
(conj #{1 2 3} 4) ; this evaluates to #{1 2 3 4}
(disj #{1 2 3} 1) ; this evaluates to #{2 3}
(#{1 2 3} 1) ; this evaluates to 1, which evaluates to boolean true
(#{1 2 3} 4) ; this evaluates to nil, which evaluates to boolean false
</code></pre>

<h2>Functions</h2>
<pre class="codehilite"><code class="language-clj">; ---------- FUNCTION -----------
    ; functions have implicit return on their last statement
    ; functions can take multiple kinds of arguments and evaluate differently, just specify them with separate [] square brackets and () brackets
    ; fn =&gt; creates a new anonymous function, where [] square brackets list function arguments
        ; anonymous functions are called with (()) double brackets
    ; def =&gt; assigns an anonymous function to a variable to create a named function
    ; defn =&gt; creates a named function, where [] square brackets list function arguments
    ; &amp; =&gt; recieves extra arguments and packs them in a list, can be mixed with normal arguments

; ANONYMOUS FUNCTIONS

(fn [] &quot;Hello World&quot;) ; evaluates to fn 
((fn [] &quot;Shit ass&quot;)) ; calls the anonymous function, evaluating to the string &quot;Shit ass&quot;
(def hello-world-ass (fn [] &quot;Hello World Ass&quot;)) ; creates the anonymous function which returns the string &quot;Hello World Ass&quot; then assigns it to the variable hello-world-ass to make it a named function
(hello-world-ass) ; this calls the named function, evaluating to the string &quot;Hello World Ass&quot;

; NAMED FUNCTIONS

(defn watermelon [] &quot;watermelon&quot;) ; creates a named function watermelon which evaluates to the string value &quot;watermelon&quot;
(watermelon) ; calls the specified function, evaluating to the string value &quot;watermelon&quot;

(defn hello [name]
  (str &quot;Hello &quot; name)) ; another function definition
(hello &quot;Steve&quot;) ; calls the specified function, evaluating to string value &quot;Hello Steve&quot;

; MULTI-VARIADIC FUNCTIONS

(defn hello-flexible
  ([] &quot;Hello World&quot;)
  ([name] (str &quot;Hello &quot; name))) ; a multi-variadic function definition that can take different arguments and evaluates differently based on arguments provided
(hello-flexible &quot;Jake&quot;) ; this will evaluate to &quot;Hello Jake&quot;
(hello-flexible) ; this will evaluate &quot;Hello World&quot;

; VARIABLE NUMBER OF FUNCTION ARGUMENTS

(defn count-args [&amp; achoo]
  (str &quot;You passed &quot; (count achoo) &quot; arguments: &quot; achoo)) ; function definition for a function that accepts multiple arguments under the argument name achoo
(count-args 1 2 3) ; this evaluates to the string value of &quot;You passed 3 args: (1 2 3)&quot;

(defn hello-count [name &amp; orange]
  (str &quot;Hello &quot; name &quot;, you passed &quot; (count orange) &quot; extra arguments&quot;)) ; function definition for a function that mixes a variable number of arguments with other named arguments
(hello-count &quot;Finn&quot; 1 2 3) ; this evaluates to the string value of &quot;Hello Finn, you passed 3 extra args&quot;
</code></pre>

<h2>Modules</h2>
<pre class="codehilite"><code class="language-clj">; ----------- MODULE -----------
    ; use =&gt; brings all functions from the specified module into the current global scope, does not requires namespace qualification
    ; require =&gt; imports a module and its functions but requires namespace qualification when calling module functions
    ; ns =&gt; namespaces can be used to require a module as well, doing so means we don't need to quote the module 

(use 'clojure.set) ; brings all set functions within the global scope
(intersection #{1 2 3} #{2 3 4}) ; we can now call set functions, this evaluates to #{2 3}

(require 'clojure.string) ; imports the clojure string module within the global scope but namespace qualfiication required when calling string functions
(clojure.string/blank? &quot;&quot;) ; we can now call string functions but must reference the clojure.string namespace, this evaluates to true

(ns test
  (:require
    [clojure.string :as str]
    [clojure.set :as set])) ; this has the same effect as above and gives the modules shorter names, note there is no need to quote ' the module here
</code></pre>

<h2>More on</h2>
<ul>
<li>-&gt;</li>
<li>-&gt;&gt;</li>
<li>as-&gt; </li>
<li><a href="https://clojure.org/reference/refs">clojure STM</a></li>
<li><a href="https://clojure.org/reference/libs">clojure java standard library</a></li>
<li><a href="https://learnxinyminutes.com/docs/clojure-macros/">learn clojure macros in y minutes</a></li>
<li><a href="https://4clojure.oxal.org/">clojure exercises</a></li>
<li><a href="https://clojuredocs.org/quickref">clojure quick reference</a></li>
<li><a href="https://learnxinyminutes.com/docs/clojure/">learn clojure in y minutes</a></li>
<li><a href="https://clojure-doc.org/">clojure documentation</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
