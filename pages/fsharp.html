<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: F# - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>F#</h2>

        <dl>
          <dt>File size</dt>
          <dd>12.7KB</dd>

          <dt>Lines of code</dt>
          <dd>314</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>F#</code></h1>
<h2>Quickstart</h2>
<ul>
<li>functional</li>
<li>supports object-oriented patterns</li>
<li>foss</li>
<li>runs on linux, osx, windows</li>
</ul>
<h2>Comments</h2>
<pre class="codehilite"><code class="language-fs">// single line comment

(* multi
line
comment, 
similar
to 
OCaml *)
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-fs">// ---------- PRINT ----------
    // printf and printfn can be used to directly print string literals

printf &quot;hello world\n&quot; // printf prints without the newline
printfn &quot;hello world&quot; // printfn prints with a newline character

// ---------- FORMATTED STRING ----------
    // $ and {} used for string interpolation
    // both printf and printfn can print formatted strings with format specifiers using the syntax of {PRINT FUNCTION} {STRING WITH FORMAT SPECIFIFERS} {VARIABLES}
        // %s =&gt; string
        // %d =&gt; decimal
        // %i =&gt; integer
        // %x =&gt; hexadecimal
        // %f =&gt; floating point number
        // %e =&gt; exponential
        // %g =&gt; general format (automatically chooses between %f and %e)
        // %b =&gt; boolean
        // %c =&gt; character
        // %A =&gt; prints values using F#'s default formatting
        // %Ns =&gt; specifies a minimum field width of N characters for strings
        // %Nd =&gt; specifies a minimum field width of N characters for decimals
        // %Ni =&gt; specifies a minimum field width of N characters for integers
        // %N.Mf =&gt; specifies a minimum field width of N characters and M decimal places for floating point numbers

let dish = &quot;cereal chicken&quot;
let cost = 2.50
let finSentence = $&quot;This {dish} costs {cost}&quot;
printfn &quot;%s&quot; finSentence // printing of a string variable using string interpolation
</code></pre>

<h2>Variables</h2>
<pre class="codehilite"><code class="language-fs">// ---------- VARIABLE ----------
    // let defines an immutable variables 
    // type declaration is not required

let anInt = 5
let myFloat = 3.14
let myString = &quot;smacks&quot;

// NOTE

= // both the assignment operator AND equality check operator (for equality checks similar to == or === in other languages)
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-fs">// ---------- TYPE ----------
    // expressions and values are immutable by default
    // int =&gt; 32-bit signed int (42)
    // int64 =&gt; 64-bit signed int (10000)
    // float =&gt; 64-bit floating point number (3.42)
    // char =&gt; single unicode character, single-quoted ('a')
    // string =&gt; sequence of characters, double-quoted (&quot;watermelon&quot;)
    // bool =&gt; boolean value (true, false)
</code></pre>

<h2>Data structures</h2>
<pre class="codehilite"><code class="language-fs">// ---------- LIST ----------
    // lists are immutable, so any functions or operators that are called on the list return a copy or must be reassigned
    // ordered collections of elements of the same type
    // lists are wrapped with [] square brackets, and ; semicolon delimited (instead of the usual commas)

let aList = [2; 3; 4; 5]

// LIST METHODS
    // see below for other list functions

let addedToList = 1 :: aList // :: adds an element to the front of the list, so this evaluates to [1; 2; 3; 4; 5]
let concatTwoLists = [0; 1] @ addedToList // @ concatenates two lists together, so this evaluates to [0; 1; 1; 2; 3; 4; 5]
let aListOfRange = [1..10] // .. defines an inclusive range within the list, so this evaluates to [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
let aListFromSeqExp = [for i in 1..10 -&gt; i * i] // lists can be defined with sequence expressions as well, as seen here this creates a list of squares of integers 1 to 10, which evaluates to [1; 4; 9; 16; 25; 36; 49; 64; 81; 100]
let aListFromListComprehension = [for i in 1..10 do yield i * i] // basically the same as above but achieved via list comprehension

// --------- ARRAY ----------
    // arrays are mutable and considered more efficient
    // ordered collection of elements of the same type
    // arrays are wrapped with [||] square brackets with bars and ; semicolon delimited

let anArray = [|&quot;a&quot;; &quot;b&quot;|]

// ---------- SEQUENCE ----------
    // infinite sequence of elements
    // basically an enumerator
    // sequences are wrapped with {} curly braces and ; semicolon delimited and accompanied with seq
    // yield is used to generate sequence values where required

let aSequence = seq {yield &quot;a&quot;; yield &quot;b&quot;}

// ---------- TUPLE ----------
    // collecton of elements of any data type
    // tuples are anonymous by default
    // , comma delimited
    // can be unpacked with pattern matching similar to Rust

let aTuple = 1,2
let anotherTuple &quot;a&quot;, 2, true

let x,y = aTuple // this unpacks the tuple and sets the value of x = 1, y = 2
</code></pre>

<h2>Functions</h2>
<pre class="codehilite"><code class="language-fs">// ---------- FUNCTION ----------
    // let defines a function, which is defined similar to a variable (since we're in functional land where every statement is an expression that evaluates to a value including functions)
    // no brackets and implicit return of last expression similar to Haskell
    // functions are first class entitites and can be chained to create powerful constructs
    // let {FUNCTION NAME} {FUNCTION PARAMETERS} = {FUNCTION PROCEDURES which are implicitly returned}
    // multiline functions can be defined with indents
    // () brackets can be used to define function precedence
    // |&gt; pipe operator also available to pipe the output of one operation to another, this is very common in F#
    // anonymous functions (lambdas) can be defined with the fun keyword
    // modules group functions together (indentation necessary for each nested module)

let square x = x * x // note that parameter and return values are effectively non-distinguishable
square 3 // evaluates to the value of 9

let add x y = x + y // implicit return of the x + y calculated value
add 2 3 // runs the function, evaluates to the value of 5

// MULTILINE FUNCTION
    // mainly used for greater readibility

let evens list = 
    let isEven x = x % 2 = 0 // defining the sub function isEven within the multiline function evens so that it can only be referenced within the evens function, also the first = is an assignment of an expression, the second = is an equality check 
    List.filter isEven list // built-in function List.filter then called on each value of the list parameter received by evens function based on the conditional check laid out in the defined sub function isEven

evens [1; 2; 3; 4; 5] // this runs the above function as expected

// FUNCTION PRECEDENCE
    // () define function precedence, and help readibility

let sumOfSquaresTo100 = List.sum ( List.map square [1..100] ) // here, the brackets specify the contents of List.map is to be called on the in t list defined for range 1-100, mapping the square function on each value, the returned value then being passed to List.sum 

// PIPING 
    // |&gt; lets you pipe

let sumOfSquaresTo100WithPipes = [1..100] |&gt; List.map square |&gt; List.sum // this does the same thing as above

// ANONYMOUS FUNCTIONS
    // fun defines a lambda function for a one-time use function

let sumOfSquaresTo100ButLambda = [1..100] |&gt; List.map (fun x -&gt; x * x) |&gt; List.sum // this does the same as the above code except it defines its own anonymous function using the fun keyword

// MODULES
    // module and indentation groups functions together
    // note there is no let when defining a module, just module

module SimpleMathThingies = 

    let add x y = x + y

    let subtract x y = x - y

    let multiply x y = x * y

    let divide x y = x / y

    let modulo x y = x % y

    let square x = x * x
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-fs">// ---------- PATTERN MATCHING ----------
    // match with | -&gt; allows for supercharged case switch statement, just like Rust
    // _ is the catch-all operator also similar to Rust
    // everything is still an expression, so everything evaluates to a value and is defined with let, even pattern matches
    // nested definition of expression!
    // pattern matching works for lists and other data structures as well

let simplePatternMatch = 
    let x = &quot;a&quot;
    match x with 
        | &quot;a&quot; -&gt; printfn &quot;x is a&quot;
        | &quot;b&quot; -&gt; printfn &quot;x is b&quot;
        | _ -&gt; printfn &quot;catch all operator hit&quot; // F# does not allow nulls by default, an Option type must be used for pattern matching, although None is a valid value

// ---------- IF ELIF ELSE THEN ----------
    // F# also has the standard conditional checks, which work as expected
    // you can assign boolean expressions to variables and functions

let test x y =
    if x = y then &quot;they are equals&quot;
    elif x &lt; y then &quot;x is less than y&quot;
    else &quot;x is greater than y&quot;
</code></pre>

<h2>Loops</h2>
<pre class="codehilite"><code class="language-fs">// ---------- LOOP ----------
    // for in do allows you to iterate over a collection of elements
    // indentation matters
    // loops can be used to iterate over different patterns as well

let list1 = [1; 5; 100; 450; 788]
for i in list1 do
    printfn &quot;%d&quot; i

let seq1 = seq {for i in 1..10 -&gt; (i, i*i)}
for (a, asqr) in seq1 do
    printfn &quot;%d squared is %d&quot; a asqr
</code></pre>

<h2>Helpful functions</h2>
<pre class="codehilite"><code class="language-fs">// ----------- USEFUL ----------
    // note that these work for arrays as well, simply replace the List with Array
    // so Array.map, Array.filter and Array.iter are all valid

yield // yield allows for lazy evaluation of variables within loop expressions, often used in F# sequences to generate values only when they are required and called
yield! // yield! adds a whole subsequence to a sequence, allowing for concise expressions like yield! [5..10]
List.map // applies a function to each element in the list and returns a copy of the new list
List.iter // applies a function to each element in the list, and used for its side effects, like printing out each element of the list
List.filter // filters elements of a list based on a specified predicate (conditional check)
List.fold // applies a binary function to elements of the list from an initial defined accumalator value
List.reduce // similar to .fold but without an explicit defined accumulator
List.length // returns length of list
List.head // returns first list element of index 0
List.tail // returns last list element of index List.length-1
List.append // concatenates two lists together
List.concat // concatenates a list of lists into a single list, basically flattening it
List.rev // reverses order of elements in the list
List.sort // sorts the elements of the list by value
List.max // returns the element of max value in the list
List.min // returns the element of min value in the list

// read F# documentation for many others
</code></pre>

<h2>More on</h2>
<ul>
<li>ref</li>
<li>map</li>
<li>set</li>
<li>type</li>
<li>union types</li>
<li>active patterns (if, elif, else, then)</li>
<li>rec</li>
<li>async</li>
<li>.NET compatibility</li>
<li>OOP extensibility</li>
<li><a href="https://try.fsharp.org/">try fsharp</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
