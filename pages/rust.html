<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Rust - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Rust</h2>

        <dl>
          <dt>File size</dt>
          <dd>20.6KB</dd>

          <dt>Lines of code</dt>
          <dd>499</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Rust</code></h1>
<p>Stack Overflow's favourite programming language.</p>
<h2>Comments</h2>
<pre class="codehilite"><code class="language-rs">// ---------- COMMENT ----------

// this is a single-line comment

/*
this is
a multi-line
comment
*/
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-rs">// ---------- PRINT ----------
    // print! =&gt; prints a string to the stdout and does not include a newline
    // println! =&gt; prints a string to the stdout and appends a newline to the output
    // eprint! =&gt; prints a string to the stderr and does not include a newline
    // eprintln! =&gt; prints a string to the stderr and appends a newline to the output
    // {} =&gt; allow for string interpolation with values embedded in a formatted string

let message:&amp;str = &quot;yes ok thank you&quot;;
print!(&quot;watermelon and this does not include a newline by default and we must specify it explicitly\n&quot;);
println!(&quot;this does include a newline automatically so there is no issue&quot;);
println!(&quot;{}&quot;, message);

let error_message:&amp;str = &quot;help me this is an error message&quot;;
eprint!(&quot;this is an error message which does not include a newline by default and we have to specify it explicitly\n&quot;);
eprintln!(&quot;this error message does include a newline automatically so there is no issue&quot;);
eprintln!(&quot;{}&quot;, error_message);
</code></pre>

<h2>Quickstart</h2>
<pre class="codehilite"><code class="language-rs">// ---------- QUICKSTART ----------
    // statically-typed compiled language developed by Mozilla research used for systems programming and web development
    // compile time vs runtime
        // compile time =&gt; source file is currently compiling, syntax errors, type errors, compiler crashes can occur, binary executable created if compilation succesful
        // runtime =&gt; executable binary and program logic is run, logical errors, memory errors, file path errors can occur, whatever the programmer intended for runs if no runtime errors

// NAMESPACES
    // :: =&gt; specifies the relationship between rust crates, modules and symbols within a given namespace
    // use =&gt; bring names from other namespaces into local scope
    // {} =&gt; a glob that allows us to import multiple names into a namespace easily
    // * =&gt; wildcard operator that imports every name from a namespace

let least:i16 = std::cmp::min(3,8); // std is a crate, cmp is a module, min is a function

use std::cmp::min;
let least = min(7,1); // this assigns i32 value of 1 to the variable least by bringing the function min into local scope

use std::cmp::min;
use std::cmp::max;
use std::cmp::{min, max}; // this is the equivalent of the two lines above

use std::{cmp::min, cmp::max}; // this is also valid rust code

use std::cmp::*; // this brings min, max and many other names from the std::cmp namespace into local scope

// BLOCKS AND SCOPE
    // all rust code is an expression that evaluates to a value indicated by the omission of a semicolon (expression tail), allowing for implicit return of values within functions
    // expressions can have multiple declaration and assignment statements within them, enclosed by {} curly braces

let x = {
    let y = 1;
    let z = 20;
    y + z // y + z is the expression tail, which evaluates to the int32 integer value of 21, assigned to x
};
</code></pre>

<h2>Usage</h2>
<pre class="codehilite"><code class="language-sh"># ---------- USAGE ----------
    # rustc =&gt; compiles the individual source file and creates a binary executable under the same name
    # cargo new =&gt; creates a new rust project under the specified name, source code to be written in src/main.rs 
    # cargo build =&gt; compiles the rust project, creating a binary executable under the same name in target/debug
    # cargo run =&gt; compiles and runs the rust project immediately
    # cargo check =&gt; checks whether rust can compile the source file without errors

$ rustc main.rs # rust compiler compiles an executable file
$ ./main # run the created executable

$ cargo new exampleProject # creates a new rust project called exampleProject
$ cargo build # compiles the project

$ cd exampleProject/target/debug
$ ./exampleProject # runs the compiled executable

$ cd ../../ 
$ cargo run # recompiles and runs the executable binary file
$ cargo check # checks for any issues with the source file without compiling
</code></pre>

<h2>Operators</h2>
<pre class="codehilite"><code class="language-rs">// ---------- OPERATOR ----------

// ARITHMETIC OPERATORS
    // + =&gt; addition
    // - =&gt; subtraction
    // * =&gt; multiplication
    // / =&gt; division
    // % =&gt; modulo operator

// LOGICAL OPERATORS
    // &amp;&amp; =&gt; logical and
    // || =&gt; logical or
    // ! =&gt; logical not

// COMPARISON OPERATORS
    // == =&gt; partial equality check for value
    // != =&gt; partial inequality check for value
    // eq =&gt; complete equality check for value and type
    // ne =&gt; complete inequality check for value and type
    // &gt; &lt; &gt;= &lt;= are also comparison operators
</code></pre>

<h2>Variables and Constants</h2>
<pre class="codehilite"><code class="language-rs">// ---------- VARIABLE ----------
    // variables in rust are immutable by default
    // let =&gt; declares and initialies a variable whose value and type are immutable at runtime
    // : =&gt; explicitly specify a variable's type
    // mut =&gt; specifies a variable can be mutable and that its value can be reassigned later at runtime

// ---------- CONSTANT ----------
    // const =&gt; declares and initializes a constant whose value and type are immutable at compile time
    // constant names are capitalised by convention

let x; // variable declaration and 
x = 100; // assignment can occur on two different lines
let y:i32 = 10; // variables are immutable by default at runtime

let mut z:i32 = 45; // mut creates a mutable variable
z = 100; // this mutable variable can then have its value reassigned
println!(&quot;y is {}&quot;, y);

const SECONDS_IN_MINUTES:u32 = 60; // const creates a constant, whose value is immutable at compile time
println!(&quot;{}&quot;, SECONDS_IN_MINUTES);
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-rs">// ---------- TYPE ----------
    // i8, i16, i32, i64, i128 =&gt; signed integer (positive and negative) with size of integer specified in number of bits
    // u8, u16, u32, u64, u128 =&gt; unsigned integer (positive) with size of integer specified in number of bits
    // f32, f64 =&gt; single-precision and double-precision floating point numbers
    // bool =&gt; true, false
    // char =&gt; character declared with '' single quotation marks
    // &amp;str =&gt; immutable string literal, stored on the stack with &quot;&quot; double quotation marks
    // String =&gt; mutable string vector, stored as a Vec&lt;u8&gt; on the heap with &quot;&quot; double quotation marks
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-rs">// ---------- CONTROL STRUCTURE ----------

// ---------- CONDITIONALS ----------

// IF ELSE IF ELSE

let number:i16 = 42;
if number &lt; 0 {
    println!(&quot;number is negative&quot;);
} else if number == 0 {
    println!(&quot;number is zero&quot;);
} else {
    println!(&quot;number is positive&quot;);
}

// MATCH EXPRESSION
    // rust's powerful pattern-matching construct similar to switch case in other languages
    // match and =&gt; define a match expression, where every match expression evaluates to a single value since matches are exhaustive and each match-arm (=&gt;) points to an expression
    // _ =&gt; match-all pattern which acts as the default case for match expressions, required in every match expression to cover every possible match-arm since matches are exhaustive

fn im_feeling_lucky(feeling_lucky:bool) -&gt; i32 {
    match feeling_lucky {
        true =&gt; 100,
        false =&gt; 0,
    }
} // a match expression within a function

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
} // create the enum Coin

fn value_in_cents(coin:Coin) {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
} // match expressions can be used alongside enums to leverage on powerful pattern-matching capabilities

let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}

// UNDERSCORE
    // _ =&gt; catch-all pattern that specifies a value to be discarded and can be used for destructuring, also a match-all pattern in match expressions
    // prefixing a variable with _ will indicate to the compiler to ignore it even if its unused

let _ = get_thing(); // calls the function get_thing but throws away the returned value
let _unused = 42; // the rust compiler will not warn about this variable even if its unused
let (_, right) = slice.split_at(middle); // throw away the left side of the destructured tuple and only return the right

// ---------- LOOPS ----------
    // continue =&gt; skips to the next iteration of the loop
    // break =&gt; exits the loop 

// WHILE LOOPS

while 1 == 1 {
    println!(&quot;this operates as you'd expect, but this is an infinite loop my guy&quot;);
}

// FOR IN LOOPS
    // for in =&gt; allows for iteration over a specified iterable collection of data, including ranges

let an_array:[i32;3] = [1,2,3];
for i:i32 in an_array { 
    print!(&quot;{}&quot;, i);
} // this prints 123 to the stdout

for i in 0u32..10 {
    print!(&quot;{}&quot;, i); 
} // this prints 0123456789 to the stdout

// LOOP
    // loop =&gt; shorthand to create an infinite loop

loop {
    println!(&quot;alahoo&quot;); 
}
</code></pre>

<h2>Data structures</h2>
<pre class="codehilite"><code class="language-rs">// ---------- DATA STRUCTURE ----------

// ARRAY
    // fixed-length ordered sequence of elements of the same type
    // declared with [] square brackets and size and data type specified

let int_array:[i32; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
println!(&quot;{}&quot;, int_array[7]); // prints 8 to the stdout

// VECTOR
    // dynamic length ordered sequence of elements of the same type
    // vec![] =&gt; declares and creates a vector with size and data type specified

let mut int_vector:Vec&lt;i32&gt; = vec![1,2,3,4,5,59,132];
vector.push(5); // appends the i32 integer of value 5 to the vector int_vector

// TUPLE
    // fixed-length ordered sequence of elements of different types
    // declared with () brackets and size and data type of each element specified

let mixed_tuple:(i32, bool, char) = (1, true, 'A');
println!(&quot;{}&quot;, mixed_tuple.1); // prints true to the stdout

// STRUCT
    // collections of data and functions in rust where each new struct is its own data type, similar to objects in javascript or tables in lua
    // struct =&gt; declares and creates a new struct with struct data and functions within {} curly braces
    // impl =&gt; implements methods, associated functions and traits on a specified struct
        // &amp;self always fed as the first parameter to a struct method to reference the given instance of a struct, with methods called using . dot notation
    // associated functions are functions that don't take &amp;self as a parameter and thus don't require an instance of a struct to be called, but are still associated with the struct
        // associated functions called using the {STRUCT NAME}::{ASSOCIATED FUNCTION NAME}

struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
} // declares and creates a struct

let user1 = User {
    email: String::from(&quot;hotman@hotmail.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
} // initialization of a struct literal with its values assigned

struct Vec2 { 
    x:f64,
    y:f64,
} // declares and creates another struct

impl Vec2 { 
    fn is_strictly_positive(&amp;self) -&gt; bool {
        self.x &gt; 0
    }
} // implements the method is_strictly_positive on the struct Vec2

let v1 = Vec2 { x:1.0, y:3.0 }; // initialization of a struct literal
let v2 = Vec2 { y:2.0, x:4.0 }; // initialization of another struct literal

println!(&quot;{}&quot;, v1.is_strictly_positive()); // specified method is called using . dot notation on an instance of the struct, a struct literal

impl Rectangle {
    fn square(size: u32) -&gt; Rectangle { // notice the return type is specified as the struct Rectangle, which is considered its own type
        Rectangle { width: size, height: size } // omission of semicolon for implicit return
    }
} // here, the associated function acts as a constructor that returns the struct Rectangle

let square1 = Rectangle::square(3); // calls the associated function

// TRAITS
    // specifies attributes and methods a type must have without defining them, similar to interfaces in Java
    // trait =&gt; declares and creates a trait with a specified name to be implemented on a struct
    // impl for =&gt; implement a specified trait on a struct
    // rust's orphan rules
        // can implement one of your traits on foreign and primitive types
        // can implement other rust-defined traits on one of our types
        // cannot implement a foreign trait on a foreign type

struct Number { 
    odd: bool;
    value: i32;
} // declare and create a struct

trait Signed {
    fn isStrictlyNegative(&amp;self) -&gt; bool; 
} // all this does is specify that the type must have a method called isStrictlyNegative that returns a boolean

impl Signed for Number { 
    fn isStrictlyNegative(&amp;self) -&gt; (bool) {
        self.value &lt; 0
    }
} // this implements the trait Signed on the struct Number and we see the implementation of the method within the struct defintiion

let n = Number { odd:false, value:-44 }; // struct literal initialization
println!(&quot;{}&quot;, n.isStrictlyNegative()); // calling the method on the instance of the struct

// ENUMS
    // enums allow for powerful state-modelling in rust to make invalid states unrepresentable, especially powerful since enums are their own type in rust
    // enum =&gt; declares and creates an enum and its many possible states
    // :: =&gt; namespace operator specifies the relationship between an enum and an enum member
    // instance of an enum is created using let {ENUM_INSTANCE_NAME} = {ENUM NAME}::{ENUM VARIANT NAME}

enum IP_address_type {
    V4(u8,u8,u8,u8), // V4 variant is able to store a value of (127,0,0,1)
    V6(String), // V6 variant is able to store a String of value &quot;::1&quot;
} // declares and creates an enum IP_address_type and its respective variants, V4 and V6, where an ip address can only ever be V4 or V6

let four = IP_address_type::V4; // creates an instance of an enum
let five = IP_address_type::V4(127,0,0,1); // we can also specify the value of the enum member upon initialization
</code></pre>

<h2>Functions</h2>
<pre class="codehilite"><code class="language-rs">// ---------- FUNCTION ----------
    // rust functions have implicit return of the value the last expression evaluates to, specified by omitting the ; semicolon
    // fn =&gt; declares and creates a function with their parameter and return type specified
    // -&gt; =&gt; specifies the relationship between the function name and return type and function body
    // return =&gt; specifies the return expression but not madantory due to implicit return

fn a_fair_dice_roll() -&gt; i32 {
    return 4;
}

fn unfair_dice_roll() -&gt; i32 {
    10 // this is valid since 10 is implicitly returned
}
</code></pre>

<h2>Ownership</h2>
<pre class="codehilite"><code class="language-rs">// ---------- OWNERSHIP ----------
    // variables, constants and references have a fixed lifetime specified by the lexical scope of the {} curly braces they are enclosed within
    // rust ownership hinges on the concept that it automatically returns memory once the variable that owns said value in memory goes out of scope

// STACK VS HEAP
    // both the stack and heap are part of computer memory for program usage at runtime
    // stack
        // blazingly fast, last-in first-out structure with operations like pushing and popping of data
        // stack only ever has to refer to the top of the stack for storage and retrieval
        // stack data is of a fixed-size at compile time
    // heap
        // less fast, values stored at different memory addresses in the heap allocated based on the amount of space required for each value
        // values retrieved via a pointer that stores the memory address of a given value
        // heap data is of an unknown size at compile time

// OWNERSHIP RULES
    // each value belongs to a variable (its owner)
    // there can only be one owner at a time
    // when the owner goes out of scope, the value will be dropped

// here is an example of ownership rules in action
// variable s is not valid here, it has not been declared yet
{
    let s:String = &quot;hello&quot;; // variable s is valid from this point forward till the end of the local lexical scope (curly braces), s is a string vector and is heap-allocated
}
// the lexical scope is now over and the variable s is no longer valid, rust returns the space the variable s took up with its value in heap memory

// REFERENCES
    // references are immutable by default
    // &amp; =&gt; specifies a given variable is a reference, allowing us to refer to a value without taking ownership of it
    // having a reference as a function parameter is called borrowing

fn main() {
    let s1 = String::from(&quot;hello&quot;); // string vector of dynamic length, heap-allocated created
    let len = calculate_length(&amp;s1); // pass the heap-allocated string vector s1 by reference to the function calculate_length(), to prevent the string s1 from being moved after the function runs
    println!(&quot;length of {} is {}&quot;, s1, le);
}

fn calculate_length(s:&amp;String) -&gt; usize { // this function recieves a parameter of type reference to a string vector type by borrowing it, x is also brought into local scope as a function parameter
    s.len() // s is within lexical scope here
}
// s goes out of scope here, but since it does not have ownership of what it refers to, nothing happens
</code></pre>

<h2>More on</h2>
<ul>
<li>enum functions</li>
<li>enum methods</li>
<li>Option type</li>
<li>copy</li>
<li>clone</li>
<li>mutable references</li>
<li>slices as references</li>
<li>smart pointers</li>
<li>struct update syntax</li>
<li>tuple structs</li>
<li>lifetimes</li>
<li>macros</li>
<li>if let</li>
<li>result</li>
<li>option</li>
<li>packages</li>
<li>generics</li>
<li>error handling</li>
<li>concurrency</li>
<li>modules</li>
<li><a href="https://www.rust-lang.org/tools/install">install rust</a></li>
<li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021">rust playground</a></li>
<li><a href="https://learnxinyminutes.com/docs/rust/">learn rust in y minutes</a></li>
<li><a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">rust in 30 minutes</a></li>
<li><a href="https://doc.rust-lang.org/stable/book/">rust lang book</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">rust by example</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
