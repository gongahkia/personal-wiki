<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Onyx - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Onyx</h2>

        <dl>
          <dt>File size</dt>
          <dd>7.5KB</dd>

          <dt>Lines of code</dt>
          <dd>326</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Onyx</code></h1>
<p>Modern systems programming language focused on simplicity and performance.</p>
<h2>Comments</h2>
<pre class="codehilite"><code class="language-onyx">// ---------- COMMENT ----------

// this is a single-line comment

/* 
this is a
multi-line
comment
*/
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-onyx">// ---------- PRINT ----------
    // print() =&gt; prints values to stdout without newline
    // println() =&gt; prints values to stdout with newline
    // printf() =&gt; formatted printing similar to C

println(&quot;Hello, Onyx!&quot;)
print(&quot;No newline here&quot;)
printf(&quot;Formatted: %d\n&quot;, 42)
</code></pre>

<h2>Quickstart</h2>
<pre class="codehilite"><code class="language-onyx">// ---------- QUICKSTART ----------
    // Onyx is a systems language with modern syntax
    // statically typed with type inference
    // memory safe with optional manual memory management
    // : =&gt; type annotation
    // := =&gt; type inference and assignment
    // = =&gt; assignment to existing variable

main :: () {
    message := &quot;Hello, World!&quot;  // type inferred as string
    number: i32 = 42           // explicit type annotation
    println(message)
}
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-onyx">// ---------- TYPE ----------
    // i8, i16, i32, i64 =&gt; signed integers
    // u8, u16, u32, u64 =&gt; unsigned integers
    // f32, f64 =&gt; floating-point numbers
    // bool =&gt; true, false
    // char =&gt; Unicode character
    // str =&gt; string slice
    // string =&gt; owned string
    // void =&gt; absence of value

age: i32 = 25
height: f64 = 5.9
is_active: bool = true
initial: char = 'A'
name: str = &quot;Alice&quot;
owned_name: string = &quot;Bob&quot;
</code></pre>

<h2>Operators</h2>
<pre class="codehilite"><code class="language-onyx">// ---------- OPERATOR ----------

// ARITHMETIC OPERATORS
    // + =&gt; addition
    // - =&gt; subtraction
    // * =&gt; multiplication
    // / =&gt; division
    // % =&gt; modulo

// COMPARISON OPERATORS
    // == =&gt; equality
    // != =&gt; inequality
    //  = =&gt; comparison operators

// LOGICAL OPERATORS
    // &amp;&amp; =&gt; logical and
    // || =&gt; logical or
    // ! =&gt; logical not

// BITWISE OPERATORS
    // &amp; =&gt; bitwise and
    // | =&gt; bitwise or
    // ^ =&gt; bitwise xor
    // ~ =&gt; bitwise not
    // &gt; =&gt; left and right shift
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-onyx">// ---------- CONTROL STRUCTURE ----------

// CONDITIONALS

// IF ELSE IF ELSE
x := 10
if x &gt; 10 {
    println(&quot;greater than 10&quot;)
} else if x == 10 {
    println(&quot;equals 10&quot;)
} else {
    println(&quot;less than 10&quot;)
}

// SWITCH CASE DEFAULT
day := &quot;Monday&quot;
switch day {
    case &quot;Monday&quot; {
        println(&quot;Start of work week&quot;)
    }
    case &quot;Friday&quot; {
        println(&quot;TGIF!&quot;)
    }
    default {
        println(&quot;Another day&quot;)
    }
}

// LOOPS

// FOR LOOPS
for i in 0..5 {
    println(i)
}

for item in  {[3][4][1][2]
    println(item)
}

// WHILE LOOPS
counter := 0
while counter  fixed-size arrays of N elements of type T
    // []T =&gt; dynamic arrays (slices)

numbers: i32 =[5][4][9][1][2][3]
dynamic_numbers: []i32 = make([]i32, 0, 10)

// STRINGS
message: str = &quot;Hello&quot;
owned_message: string = &quot;World&quot;

// STRUCTS
    // struct =&gt; custom data types with named fields

Person :: struct {
    name: str
    age: i32
    is_active: bool
}

person: Person = Person{
    name = &quot;Alice&quot;
    age = 30
    is_active = true
}

// ENUMS
    // enum =&gt; enumerated types

Status :: enum {
    Pending
    Active
    Inactive
}

current_status: Status = Status.Active

// UNIONS
    // union =&gt; tagged unions for type-safe variants

Result :: union {
    Success: i32
    Error: str
}

result: Result = Result{Success = 42}

// MAPS
    // map[K]V =&gt; hash maps with key type K and value type V

scores: map[str]i32 = make(map[str]i32)
scores[&quot;Alice&quot;] = 95
scores[&quot;Bob&quot;] = 87

// POINTERS
    // ^T =&gt; pointer to type T
    // &amp; =&gt; address-of operator
    // * =&gt; dereference operator

value: i32 = 42
ptr: ^i32 = &amp;value
dereferenced: i32 = *ptr
</code></pre>

<h2>Functions</h2>
<pre class="codehilite"><code class="language-onyx">// ---------- FUNCTION ----------
    // function_name :: (parameters) -&gt; return_type { body }
    // :: =&gt; function declaration operator
    // -&gt; =&gt; return type separator

// BASIC FUNCTIONS
add :: (a: i32, b: i32) -&gt; i32 {
    return a + b
}

// FUNCTIONS WITH MULTIPLE RETURNS
divide :: (a: i32, b: i32) -&gt; (i32, bool) {
    if b == 0 {
        return 0, false
    }
    return a / b, true
}

result, success := divide(10, 2)

// PROCEDURES (NO RETURN VALUE)
greet :: (name: str) {
    printf(&quot;Hello, %s!\n&quot;, name)
}

// FUNCTION POINTERS
operation :: (a: i32, b: i32) -&gt; i32

multiply :: (a: i32, b: i32) -&gt; i32 {
    return a * b
}

operation = multiply
result := operation(5, 3)

// GENERIC FUNCTIONS
    // $T =&gt; generic type parameter

max :: ($T: type, a: T, b: T) -&gt; T {
    if a &gt; b {
        return a
    }
    return b
}

max_int := max(i32, 10, 20)
max_float := max(f64, 3.14, 2.71)

// CLOSURES
    // functions can capture variables from their environment

make_counter :: () -&gt; () -&gt; i32 {
    count := 0
    return () -&gt; i32 {
        count += 1
        return count
    }
}

counter := make_counter()
println(counter())  // prints 1
println(counter())  // prints 2
</code></pre>

<h2>More on</h2>
<ul>
<li>memory management</li>
<li>error handling</li>
<li>generics</li>
<li>metaprogramming</li>
<li>package system</li>
<li>foreign function interface</li>
<li>concurrency</li>
<li><a href="https://onyxlang.io/docs">onyx documentation</a></li>
<li><a href="https://onyxlang.io/guide">onyx language guide</a></li>
<li><a href="https://github.com/onyx-lang/onyx">onyx github</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>Â© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
