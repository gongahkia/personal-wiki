<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Reason - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Reason</h2>

        <dl>
          <dt>File size</dt>
          <dd>9.6KB</dd>

          <dt>Lines of code</dt>
          <dd>249</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Reason</code></h1>
<p>Syntax and tooling extension on top of OCaml for reliable, maintainable software development with seamless JavaScript interoperability.</p>
<h2>Comments</h2>
<pre class="codehilite"><code class="language-re">// ----- COMMENT -----

// this is a single-line comment

/* this is a 
multi-line 
comment */
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-re">// ----- PRINTING -----
    // Js.log() =&gt; receives a string argument that is then printed to the stdout and includes a newline automatically
    // note that there is no built-in implementation to display a string to the stdout without including a newline

Js.log(&quot;this includes a newline by default&quot;); 
</code></pre>

<h2>Quickstart</h2>
<pre class="codehilite"><code class="language-re">// ----- QUICKSTART -----
    // semicolon-delimited functional language
    // strongly, statically-typed with type inference for convenience
    // high performance optimisation with strict type safety
    // compiles to native bytecode or transpiles to JavaScript
    // let =&gt; declares an immutable variable binding, note that Reason variables are immutable by default similar to Rust
    // : =&gt; specifies the datatype of a given variable, providing type annotations for safety and expressiveness
    // := =&gt; reassigns a new value to an existing mutable reference variable created with ref()
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-re">// ----- TYPE -----
    // int =&gt; stores an integer number value
    // float =&gt; stores a floating-point number value
    // string =&gt; stores a string value declared within &quot;&quot; double quotation marks, note that characters are handled as single-character long strings
    // bool =&gt; true, false
    // Option =&gt; specifies that a given value could either be of the specified datatype (and thereby Some) or the special value None
    // Some =&gt; represents the presence of a value
    // None =&gt; represents the absence of a value, the equivalent of void and null in other programming languages
    // ref() =&gt; creates a mutable reference variable whose datatype is also specified within the () round brackets, and whose value can then be reassigned with :=
</code></pre>

<h2>Operators</h2>
<pre class="codehilite"><code class="language-re">// ----- OPERATOR -----

// --- ARITHMETIC OPERATORS ---

+ // addition
- // subtraction
* // multiplication
/ // division
mod // modulo

// --- COMPARISON OPERATORS ---

== // thorough physical equality check for whether two objects have the same memory address
= // partial equality check for value but not type or memory address
!= // partial inequality check for value but not type or memory address
&gt; // comparison operator
&lt; // comparison operator
&gt;= // comparison operator
&lt;= // comparison operator

// --- LOGICAL OPERATORS ---

&amp;&amp; // logical and
|| // logical or
not() // logical not
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-re">// ----- CONTROL STRUCTURE -----

// --- CONDITIONALS ---

// IF ELSE IF ELSE
    // observe that as a functional language, the results of a conditional construct as below can be direcly assigned to a variable

let categorizeNumber = (n) =&gt; {
    if (n &lt; 0) {
        &quot;negative&quot;;
    } else if (n == 0) {
        &quot;zero&quot;;
    } else if (n &gt; 0 &amp;&amp; n &lt; 10) {
        &quot;positive and less than 10&quot;;
    } else {
        &quot;positive and 10 or greater&quot;;
    }
};

// SWITCH | =&gt; _
    // provides an advanced degree of pattern-matching, the equivalent of match case in Rust and select case in many other programming languages
    // | =&gt; delimits each specified case and their corresponding execution code from the other cases
    // _ =&gt; specifies the default fall-through case which executes if all other predicate case conditions fail to be met
    // note that =&gt; specifies the relationship between a given predicate case condition and the execution code to be run if that case is met

let describeNumber = (x) =&gt; {
    switch (x) {
        | 0 =&gt; &quot;zero&quot;
        | 1 =&gt; &quot;one&quot;
        | _ =&gt; &quot;many&quot;
    }
};

// --- LOOPS ---

// WHILE 
    // operates similarly to while loops in most other programming languages

let total = ref(0); 
let i = ref(1); 
while (!=(!i, 11)) { 
    total := !total + !i; 
    i := !i + 1;
    Js.log(total);
};

// FOR IN
    // allows for iteration and traversal over an iterable data structure
    // operates similarly to for in loops in Python and foreach loops in PHP

for (i in 0 to 5) {
    Js.log(i);
};
</code></pre>

<h2>Data structures</h2>
<pre class="codehilite"><code class="language-re">// ----- DATA STRUCTURE -----
    // list =&gt; fixed-size immutable singly-linked list traversed via recursion and enabling pattern-matching, declared within [] square brackets
    // array =&gt; fixed-size mutable ordered collection of elements of the same datatype, the equivalent of lists in Python
    // tuple =&gt; fixed-size immutable ordered collection of elements of multiple datatypes that affords powerful tuple destructuring, the equivalent of tuples in Python
    // record =&gt; immutable user-defined collection of specified named fields and their corresponding datatypes, the equivalent of structs in Rust and Typescript, affording the modelling of representative data via type aliases
    // variant =&gt; enumerated sun type that could be one of several user-defined types affording powerful pattern-matching, the equivalent of enums in Rust and Typescript

let anExampleList = [1, 2, 3, 4];

let anExampleArray = [|1, 2, 3, 4|];

let anExampleTuple = (1, &quot;Hello&quot;, true);
let (x, y, z) = anExampleTuple; // tuple destructuring

type anExampleRecordOfAPerson = {
    name: string,
    age: int,
};

type threeDimensionalCoordinate = {
    X: int,
    Y: int,
    Z: int,
};

type anExampleVariant =
    | Circle(float)
    | Rectangle(float, float);

let area = (s) =&gt; {
    switch (s) {
        | Circle(radius) =&gt; 3.14 *. radius *. radius
        | Rectangle(width, height) =&gt; width *. height
    }
};
</code></pre>

<h2>Functions</h2>
<pre class="codehilite"><code class="language-re">// ----- FUNCTION -----
    // functions are first-class citizens, allowing for the creation of user-defined higher-order functions
    // while the syntax for creation of named and anonymous functions appear to be exactly the same as below, their use cases distinguish them from each other
    // note that Reason inherits from functional programming paradigms, featuring implicit return of the last expression within the function
    // let &lt;functionName&gt; = (&lt;functionParameter(s)&gt;) =&gt; &lt;functionDefinitionBody&gt; =&gt; definition and declaration of a named function, which are then called by their function name
    // let &lt;anonymousFunctionVariableIdentifier&gt; = (&lt;functionParameter(s)&gt;) =&gt; &lt;functionDefinitionBody&gt; =&gt; definition of an anonymous function, which is then assigned to a named variable identifier
        // also observe that anonymous functions can also be called directly in the same line as their definition

let add = (x, y) =&gt; x + y; // definition of a named function
let result1 = add(2, 3); // calling a named function
let result2 = add(3, 4); // calling a named function again
let result3 = add(4, 5); // calling a named function the last time

let subtract = (x, y) =&gt; x - y; // definition of an anonymous function
let result4 = subtract(5, 3); // calling an anonymous function
let resultDirect = ((x, y) =&gt; x * y)(4, 5); // anonymous function is declared and called in the same line

let applyFunction = (f, x) =&gt; f(x); // definition of a higher-order function
applyFunction((x) =&gt; x * x, 5); // calling a higher-order function
</code></pre>

<h2>More on</h2>
<ul>
<li><a href="https://reasonml.github.io/docs/en/installation">install reason</a></li>
<li><a href="https://reasonml.github.io/">reasonml.github.io</a></li>
<li><a href="https://reasonml.github.io/docs/en/what-and-why">reason documentation</a></li>
<li><a href="https://learnxinyminutes.com/docs/reason/">learn reason in y minutes</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>Â© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
