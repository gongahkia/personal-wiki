<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Lisp - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Lisp</h2>

        <dl>
          <dt>File size</dt>
          <dd>16.6KB</dd>

          <dt>Lines of code</dt>
          <dd>414</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Lisp</code></h1>
<p>The programmable programming language.</p>
<h2>Quickstart</h2>
<pre class="codehilite"><code class="language-lisp">;;; ----------- QUICKSTART ----------
    ; everything in Common Lisp is comprised of atoms or s-expressions
    ; functional expression-based programming language, so all expressions evaluate to a value
    ; mutation and side-effects are avoided as far as possible, where possible, rely on function returns to return a copy of data instead of modifying existing data

;; ATOM
    ; symbols or numbers
        ; symbol =&gt; general concept representing a name or identifier (variable names, function names, entity names)
        ; number =&gt; integer, floating-point

;; S-EXPRESSION
    ; function or operator and its arguments enclosed in () parantheses
    ; arguments can be atoms or lists
        ; list =&gt; collection of s-expressions enclosed in () parentheses, that contain atoms or other lists
</code></pre>

<h2>Comments</h2>
<pre class="codehilite"><code class="language-lisp">;;; ----------- COMMENT ----------

;; SINGLE-LINE COMMENTS
    ; 4 semicolons for file-level comments
    ; 3 semicolons for section-level descriptions
    ; 2 semicolons for definitions within code
    ; 1 semicolon for definitions outside code

;; MULTI-LINE COMMENTS
    ;; delimited by #| and |#
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-lisp">;;; ---------- PRINTING ----------
    ; format =&gt; prints formatted text to stdout, t is included for true
    ; print =&gt; prints text to stdout as a string literal with &quot;&quot; double quotation marks
    ; princ =&gt; prints text to stdout without double quotation marks

(format t &quot;Hello, World!&quot;) ; prints &quot;Hello, World!&quot; to the stdout
(print &quot;Hello&quot;) ; prints &quot;Hello&quot; to the stdout
(princ &quot;Hello&quot;) ; prints Hello to the stdout
</code></pre>

<h2>Variables and Constants</h2>
<pre class="codehilite"><code class="language-lisp">;;; ---------- VARIABLE ----------
    ; a variable is an instance of a symbol that is associated with a value stored in memory (value assignment for a variable)
    ; let =&gt; creates a local variable within the given () lexical scope, and returns the last value specified in the let scope
    ; defvar =&gt; creates a global variable whose value does not change upon re-evaluation, global variable names are ** (earmuff) asterisk delimited
    ; defparameter =&gt; creates a global variable whose value does change upon re-evaluation, global variable names are ** (earmuff) asterisk delimited

(let ((me &quot;dance with you&quot;)) me) ; creates the local variable me and assigns the string value of &quot;dance with you&quot; to it, then evaluates to &quot;dance with you&quot;

(defparameter *a_var* 5) ; assigns the global variable *a_var* the number value of 5
*a_var* ; evaluates to 5

;;; ---------- CONSTANT ----------
    ; a constant stores a piece of immutable data
    ; defconstant =&gt; creates a constant

(defconstant PI 3.141592) ; creates the constant PI which stores the number value of 3.141592, the value is immutable and cannot be changed
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-lisp">;;; ---------- TYPE -----------

;; PRIMITIVE DATATYPE
    ; all these below values can be assigned to variables
    ; symbol =&gt; uppercased automatically upon evaluation
        ; intern =&gt; intern operator creates a symbol from a string
    ; number =&gt; integer, binary, octal, hexadecimal, single, double, ratio, complex numbers
        ; quote / ' =&gt; quote operator creates literal data without evaluating it (it has the ' shorthand)
    ; boolean =&gt; any non-nil value is t (true) including expressions, nil (false) and () empty list evaluates to nil
    ; char =&gt; char literals declared with #\
    ; string =&gt; fixed-length char array, declared with &quot;&quot; double quotation marks

'foo ; evaluates to FOO, symbol literal
(intern &quot;abc&quot;) ; create the symbol |abc| from a string
(intern &quot;EFG&quot;) ; create the symbol EFG from a string

9999 ; number integer
#b111 ; number binary
#o111 ; number octal
#x111 ; number hexadecimal
3.14159s0 ; number single
3.14159d0 ; number double
1/2 ; number ratio
#C(1 2) ; complex number

(quote (+ 1 2)) ; quote creates literal data, and does not evaluate this function (+ 1 2)
'(+ 1 2) ; ' is the shorthand for quote, and it does the same thing, creating a literal data

t ; evaluates to t (true)
nil ; evaluates to nil (false)
() ; evaluates to nil (false)

#\A ; char literal 

&quot;Hello, world!&quot; ; string
</code></pre>

<h2>Operators</h2>
<pre class="codehilite"><code class="language-lisp">;;; ---------- OPERATOR -----------

;; ARITHMETIC OPERATORS
    ; + =&gt; addition
    ; - =&gt; subtraction
    ; * =&gt; multiplication
    ; / =&gt; division
    ; expt =&gt; exponentiation
    ; mod =&gt; modulo
    ; #C =&gt; creates a complex number

(+ 1 1) ; evaluates to 2
(- 8 1) ; evaluates to 7
(* 10 2) ; evaluates to 20
(expt 2 3) ; evaluates to 8
(mod 5 2) ; evaluates to 1
(/ 35 5) ; evaluates to 7
(/ 1 3) ; evaluates to 1/3
(+ #C(1 2) #C(6 -4)) ; evaluates to #C(7 -2)

;; COMPARISON OPERATORS
    ; = =&gt; complete equality check for numbers
    ; /= =&gt; complete inequality check for numbers
    ; &lt; &gt; &lt;= &gt;= are also comparison operators for numbers
    ; equal =&gt; complete equality check for structure (value) for lists, strings, bit-vectors
    ; eql =&gt; stricter than equal, complete equality check for object identity (whether two arguments refer to the same object in memory)

(= 3 3.0) ; evaluates to t
(= 2 1) ; evaluates to nil
(/= 2 1) ; evaluates to t
(&lt; 1 2) ; evalutes to t
(&gt; 3 1) ; evaluates to t
(&lt;= 1 1) ; evaluates to t
(&gt;= 2 1) ; evaluates to t

(equal (list 3) (list 3)) ; this evaluates to t since equal checks for structural equality and compares the value of the contents of the lists instead of their place in memory
(equal (list 'a 'b) (list 'b 'a)) ; evaluates to nil

(eql 3 3) ; evaluates to t
(eql 3 3.0) ; evaluates to nil
(eql (list 3) (list 3)) ; this evaluates to nil since not same object in memory despite having structural equality

;; LOGICAL OPERATORS
    ; and 
    ; or
    ; not

(and t t) ; evaluates to t
(and t nil) ; evaluates to nil
(or t nil) ; evaluates to t
(or nil nil) ; evaluates to nil
(not t) ; evaluates to nil
(not nil) ; evaluates to t
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-lisp">;;; ---------- CONTROL STRUCTURE ----------

;; CONDITIONALS
    ; as established previously, only nil is false (and () empty list which evaluates to nil), everything else is true (t)
    ; conditional syntax =&gt; (if {TEST EXPRESSION} {IF TEST EXPRESSION TRUE} {ELSE EXPRESSION})
    ; cond =&gt; chains a series of conditional checks to arrive at a final result
    ; typecase =&gt; switch case statement but for type of value

(if t 
    &quot;this is true&quot; 
    &quot;this is false&quot;) ; evaluates to &quot;this is true&quot;

(member 'Groucho '(Harpo Groucho Zeppo)) ; evaluates to '(GROUCHO ZEPPO)
(if (member 'Groucho '(Harpo Groucho Zeppo)) 
    'yep 
    'nope) ; evaluates to 'YEP since all non-nil values including '(GROUCHO ZEPPO) are t

(cond ((&gt; 2 2) (error &quot;wrong!&quot;)) 
      ((&lt; 2 2) (error &quot;wrong again!&quot;)) 
      (t 'ok)) ; evaluates to 'OK symbol since the first 2 checks were incorrect

(typecase 1 
    (string :string) 
    (integer :int)) ; evaluates to :int since 1 is of type integer

;; LOOPS
    ; loop =&gt; creates a loop iteratively that can be augmented with different keywords (:for :from :to :then :finally :across :collect)
    ; there is no while loop implementation by default

;; ITERATION

(defun fact (n)
  (loop :for result = 1 :then (* result i)
     :for i :from 2 :to n
     :finally (return result)))

(fact 5) ; evaluates to 120

(loop :for x :across &quot;abcd&quot; :collect x) ; evaluates to (#\a #\b #\c #\d)

(dolist (i '(1 2 3 4))
  (format t &quot;~A&quot; i)) ; evaluates to 1234

;; RECURSION
    ; recursion allows us to achieve the same effect as an iterative loop without actually using a loop

(defun fact (n)
  (if (&lt; n 2)
      1
    (* n (fact(- n 1))))) ; function defintion for a recursive function

(fact 5) ; similarly evaluates to 120
</code></pre>

<h2>Data structures</h2>
<pre class="codehilite"><code class="language-lisp">;;; ---------- DATA STRUCTURE -----------

;; STRUCT
    ; defstruct =&gt; creates a struct
    ; defparameter =&gt; used to assign struct field values

(defstruct dog name breed age) ; defining dog struct
(defparameter *rover* 
    (make-dog : name &quot;rover&quot;
              : breed &quot;collie&quot;
              : age 5)) ; assigning struct field values

*rover* ; evaluates to #S(DOG :NAME &quot;rover&quot; :BREED &quot;collie&quot; :AGE 5)
(dog-name *rover*) ; evaluates to &quot;rover&quot;

;; PAIR
    ; cons =&gt; creates a pair
    ; car =&gt; returns the head of a pair
    ; cdr =&gt; returns the tail of a pair

(cons 'SUBJECT 'VERB) ; evaluates to '(SUBJECT . VERB)
(car (cons 'SUBJECT 'VERB)) ; evaluates to SUBJECT
(cdr (cons 'SUBJECT 'VERB)) ; evaluates to VERB

;; LIST
    ; every list is a linked-list comprised of cons pairs, the final element ending in a nil or '() to mark the end of the list
    ; list =&gt; convenient constructor to create a list 
    ; append =&gt; join two lists
    ; concatenate =&gt; join two lists when used alongside 'list
    ; mapcar =&gt; equivalent of .map
    ; remove-if-not =&gt; equivalent of .reduce
    ; every =&gt; checks if every list element fulfills a predicate
    ; some =&gt; checks if at least one list element fulfills a predicate
    ; butlast =&gt; returns a list but removes the last element

(cons 1 (cons 2 (cons 3 nil))) ; evaluates to '(1 2 3)
(list 1 2 3) ; evaluates to '(1 2 3)

(cons 4 '(1 2 3)) ; this syntax therefore is the equivalent of inserting an element at the front of a list, and evaluates to '(4 1 2 3)
(append '(1 2) '(3 4)) ; evaluates to '(1 2 3 4)
(concatenate 'list (1 2) '(3 4)) ; evaluates to '(1 2 3 4)
(mapcar #'1+ '(1 2 3)) ; evaluates to '(2 3 4)
(mapcar #'+ '(1 2 3) '(10 20 30)) ; evaluates to '(11 22 33)
(remove-if-not #'evenp '(1 2 3 4)) ; evaluates to '(2 4)
(every #'evenp '(1 2 3 4)) ; evaluates to () which is nil
(some #'oddp '(1 2 3 4)) ; evaluates to t
(butlast '(subject verb object)); evaluates to (SUBJECT VERB)

;; VECTOR
    ; vector literals are fixed-length arrays
    ; #() =&gt; declares a vector literal
    ; concatenate =&gt; joins two vectors

#(1 2 3) ; evaluates to #(1 2 3)
(concatenate 'vector #(1 2 3) #(4 5 6)) ; evaluates to #(1 2 3 4 5 6)

;; SET
    ; sets are just lists that you call set functions on
    ; operates the same as you'd expect in other languages like Python
    ; set-difference =&gt; returns the difference between two lists
    ; intersection =&gt; returns the similar elements between two lists
    ; union =&gt; returns two lists and removes duplicates
    ; adjoin =&gt; adds a specified element to the front of the list if element not already present and returns that list

(set-difference '(1 2 3 4) '(4 5 6 7)) ; evaluates to (3 2 1)
(intersection '(1 2 3 4) '(4 5 6 7)) ; evaluates to 4
(union '(1 2 3 4) '(4 5 6 7)) ; evaluates to (3 2 1 4 5 6 7)
(adjoin 4 '(1 2 3 4)) ; evaluates to (1 2 3 4)

;; HASH TABLE
    ; equivalent of dictionary 
    ; make-hash-table =&gt; creates a hash table, used alongside defparameter
    ; setf =&gt; sets a hash value
    ; gethash =&gt; retrieves a value at a specified hash and returns both the stored value and a boolean (t, nil) depending on whether a value can be found, used for assignment and simple retrieval

(defparameter *m* (make-hash-table)) ; creates a global hash table *m*
(setf (gethash 'a *m*) 1) ; sets a number value of 1 to the hash 'a
(gethash 'a *m*) ; retrieves the value stored at the hash 'a in the global hash table *m*, evaluating to 1, T
</code></pre>

<h2>Functions</h2>
<pre class="codehilite"><code class="language-lisp">;;; ---------- FUNCTION -----------
    ; functions always return the evaluated value of the last expression
    ; function call syntax where f is function name and x y z are arguments is (f x y z)
    ; defun =&gt; creates a function, () is a list accepting arguments to the function
    ; &amp;optional =&gt; specifies optional arguments to a function

;; FUNCTION CREATION

(defun hello-world () &quot;Hello World&quot;) ; creates the function hello-world that evaluates to the string &quot;Hello World&quot;
(hello-world) ; evaluates to &quot;Hello World&quot;

(defun hello (name) (format nil &quot;Hello, ~A&quot; name)) ; creates the function hello that accepts the argument name
(hello &quot;Steve&quot;) ; evaluates to &quot;Hello, Steve&quot;

;; OPTIONAL ARGUMENTS

(defun hello (name &amp;optional from)
  (if from
      (format t &quot;Hello, ~A, from ~A&quot; name from)
      (format t &quot;Hello, ~A&quot; name))) ; optional function arguments (from) default to nil
(hello &quot;Jim&quot; &quot;Alpacas&quot;) ; evaluates to &quot;Hello, Jim, from Alpacas&quot;

(defun hello (name &amp;optional (from &quot;The world&quot;))
   (format nil &quot;Hello, ~A, from ~A&quot; name from)) ; default values (from's default value is the string &quot;The World&quot;) can also be specified 
(hello &quot;Steve&quot;) ; default value invoked, evaluates to &quot;Hello, Steve, from The world&quot;
(hello &quot;Steve&quot; &quot;the alpacas&quot;) ; default value not invoked, evaluates to &quot;Hello, Steve, from the alpacas&quot;

;; ANONYMOUS FUNCTIONS
    ; lambda =&gt; creates an anonymous function
    ; funcall =&gt; calls an anonymous function with specified known arguments
    ; apply =&gt; calls an anonymous function when arguments are not known

(lambda () &quot;Hello World&quot;) ; creation of anonymous function evaluates to #&lt;FUNCTION (LAMBDA ()) {1004E7818B}&gt;
(funcall (lambda () &quot;Hello World&quot;)) ; =&gt; evaluates to &quot;Hello World&quot;
(apply (lambda () &quot;Hello World&quot;) nil) ; evaluates to &quot;Hello World&quot;
</code></pre>

<h2>Macros</h2>
<pre class="codehilite"><code class="language-lisp">;;; ---------- MACRO ----------
    ; macros let us extend the syntax of our language (imagine writing and calling your own functions, except that works for any other part of the language)
    ; macros are incredibly complex and a lot of detail has been omitted here

(defmacro while (condition &amp;body body) ; this macro implements a while loop in common lisp
  `(loop while ,condition
         do
         (progn
            ,@body)))
</code></pre>

<h2>More on</h2>
<ul>
<li>format</li>
<li>array</li>
<li>adjustable vector</li>
<li>values</li>
<li>&amp;key</li>
<li>classes and objects</li>
<li>macros</li>
<li><a href="https://lisp-lang.org/">lisp-lang.org</a></li>
<li><a href="https://gigamonkeys.com/book/">practical common lisp</a></li>
<li><a href="http://weitz.de/cl-recipes/">lisp recipes</a></li>
<li><a href="https://github.com/CodyReichert/awesome-cl">awesome common lisp</a></li>
<li><a href="https://learnxinyminutes.com/docs/common-lisp/">learn common lisp in y minutes</a></li>
<li><a href="https://learnxinyminutes.com/docs/elisp/">learn emacs elisp in y minutes</a></li>
<li><a href="https://learnxinyminutes.com/docs/lfe/">learn lisp flavoured erlang in y minutes</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
