<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Lisp - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Lisp</h2>

        <dl>
          <dt>File size</dt>
          <dd>51.5KB</dd>

          <dt>Lines of code</dt>
          <dd>414</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Lisp</code></h1>
<p>The programmable programming language.</p>
<h2>Quickstart</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">;;; ----------- QUICKSTART ----------</span>
<span class="w">    </span><span class="c1">; everything in Common Lisp is comprised of atoms or s-expressions</span>
<span class="w">    </span><span class="c1">; functional expression-based programming language, so all expressions evaluate to a value</span>
<span class="w">    </span><span class="c1">; mutation and side-effects are avoided as far as possible, where possible, rely on function returns to return a copy of data instead of modifying existing data</span>

<span class="c1">;; ATOM</span>
<span class="w">    </span><span class="c1">; symbols or numbers</span>
<span class="w">        </span><span class="c1">; symbol =&gt; general concept representing a name or identifier (variable names, function names, entity names)</span>
<span class="w">        </span><span class="c1">; number =&gt; integer, floating-point</span>

<span class="c1">;; S-EXPRESSION</span>
<span class="w">    </span><span class="c1">; function or operator and its arguments enclosed in () parantheses</span>
<span class="w">    </span><span class="c1">; arguments can be atoms or lists</span>
<span class="w">        </span><span class="c1">; list =&gt; collection of s-expressions enclosed in () parentheses, that contain atoms or other lists</span>
</code></pre></div>

<h2>Comments</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">;;; ----------- COMMENT ----------</span>

<span class="c1">;; SINGLE-LINE COMMENTS</span>
<span class="w">    </span><span class="c1">; 4 semicolons for file-level comments</span>
<span class="w">    </span><span class="c1">; 3 semicolons for section-level descriptions</span>
<span class="w">    </span><span class="c1">; 2 semicolons for definitions within code</span>
<span class="w">    </span><span class="c1">; 1 semicolon for definitions outside code</span>

<span class="c1">;; MULTI-LINE COMMENTS</span>
<span class="w">    </span><span class="c1">;; delimited by #| and |#</span>
</code></pre></div>

<h2>Printing</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">;;; ---------- PRINTING ----------</span>
<span class="w">    </span><span class="c1">; format =&gt; prints formatted text to stdout, t is included for true</span>
<span class="w">    </span><span class="c1">; print =&gt; prints text to stdout as a string literal with &quot;&quot; double quotation marks</span>
<span class="w">    </span><span class="c1">; princ =&gt; prints text to stdout without double quotation marks</span>

<span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Hello, World!&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; prints &quot;Hello, World!&quot; to the stdout</span>
<span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; prints &quot;Hello&quot; to the stdout</span>
<span class="p">(</span><span class="nb">princ</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; prints Hello to the stdout</span>
</code></pre></div>

<h2>Variables and Constants</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">;;; ---------- VARIABLE ----------</span>
<span class="w">    </span><span class="c1">; a variable is an instance of a symbol that is associated with a value stored in memory (value assignment for a variable)</span>
<span class="w">    </span><span class="c1">; let =&gt; creates a local variable within the given () lexical scope, and returns the last value specified in the let scope</span>
<span class="w">    </span><span class="c1">; defvar =&gt; creates a global variable whose value does not change upon re-evaluation, global variable names are ** (earmuff) asterisk delimited</span>
<span class="w">    </span><span class="c1">; defparameter =&gt; creates a global variable whose value does change upon re-evaluation, global variable names are ** (earmuff) asterisk delimited</span>

<span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">me</span><span class="w"> </span><span class="s">&quot;dance with you&quot;</span><span class="p">))</span><span class="w"> </span><span class="nv">me</span><span class="p">)</span><span class="w"> </span><span class="c1">; creates the local variable me and assigns the string value of &quot;dance with you&quot; to it, then evaluates to &quot;dance with you&quot;</span>

<span class="p">(</span><span class="nb">defparameter</span><span class="w"> </span><span class="vg">*a_var*</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; assigns the global variable *a_var* the number value of 5</span>
<span class="vg">*a_var*</span><span class="w"> </span><span class="c1">; evaluates to 5</span>

<span class="c1">;;; ---------- CONSTANT ----------</span>
<span class="w">    </span><span class="c1">; a constant stores a piece of immutable data</span>
<span class="w">    </span><span class="c1">; defconstant =&gt; creates a constant</span>

<span class="p">(</span><span class="nb">defconstant</span><span class="w"> </span><span class="nv">PI</span><span class="w"> </span><span class="mf">3.141592</span><span class="p">)</span><span class="w"> </span><span class="c1">; creates the constant PI which stores the number value of 3.141592, the value is immutable and cannot be changed</span>
</code></pre></div>

<h2>Types</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">;;; ---------- TYPE -----------</span>

<span class="c1">;; PRIMITIVE DATATYPE</span>
<span class="w">    </span><span class="c1">; all these below values can be assigned to variables</span>
<span class="w">    </span><span class="c1">; symbol =&gt; uppercased automatically upon evaluation</span>
<span class="w">        </span><span class="c1">; intern =&gt; intern operator creates a symbol from a string</span>
<span class="w">    </span><span class="c1">; number =&gt; integer, binary, octal, hexadecimal, single, double, ratio, complex numbers</span>
<span class="w">        </span><span class="c1">; quote / &#39; =&gt; quote operator creates literal data without evaluating it (it has the &#39; shorthand)</span>
<span class="w">    </span><span class="c1">; boolean =&gt; any non-nil value is t (true) including expressions, nil (false) and () empty list evaluates to nil</span>
<span class="w">    </span><span class="c1">; char =&gt; char literals declared with #\</span>
<span class="w">    </span><span class="c1">; string =&gt; fixed-length char array, declared with &quot;&quot; double quotation marks</span>

<span class="ss">&#39;foo</span><span class="w"> </span><span class="c1">; evaluates to FOO, symbol literal</span>
<span class="p">(</span><span class="nb">intern</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; create the symbol |abc| from a string</span>
<span class="p">(</span><span class="nb">intern</span><span class="w"> </span><span class="s">&quot;EFG&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; create the symbol EFG from a string</span>

<span class="mi">9999</span><span class="w"> </span><span class="c1">; number integer</span>
<span class="mb">#b111</span><span class="w"> </span><span class="c1">; number binary</span>
<span class="mo">#o111</span><span class="w"> </span><span class="c1">; number octal</span>
<span class="mh">#x111</span><span class="w"> </span><span class="c1">; number hexadecimal</span>
<span class="mf">3.14159s0</span><span class="w"> </span><span class="c1">; number single</span>
<span class="mf">3.14159d0</span><span class="w"> </span><span class="c1">; number double</span>
<span class="m">1/2</span><span class="w"> </span><span class="c1">; number ratio</span>
<span class="m">#C</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; complex number</span>

<span class="p">(</span><span class="k">quote</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="c1">; quote creates literal data, and does not evaluate this function (+ 1 2)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; &#39; is the shorthand for quote, and it does the same thing, creating a literal data</span>

<span class="no">t</span><span class="w"> </span><span class="c1">; evaluates to t (true)</span>
<span class="no">nil</span><span class="w"> </span><span class="c1">; evaluates to nil (false)</span>
<span class="p">()</span><span class="w"> </span><span class="c1">; evaluates to nil (false)</span>

<span class="sc">#\A</span><span class="w"> </span><span class="c1">; char literal </span>

<span class="s">&quot;Hello, world!&quot;</span><span class="w"> </span><span class="c1">; string</span>
</code></pre></div>

<h2>Operators</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">;;; ---------- OPERATOR -----------</span>

<span class="c1">;; ARITHMETIC OPERATORS</span>
<span class="w">    </span><span class="c1">; + =&gt; addition</span>
<span class="w">    </span><span class="c1">; - =&gt; subtraction</span>
<span class="w">    </span><span class="c1">; * =&gt; multiplication</span>
<span class="w">    </span><span class="c1">; / =&gt; division</span>
<span class="w">    </span><span class="c1">; expt =&gt; exponentiation</span>
<span class="w">    </span><span class="c1">; mod =&gt; modulo</span>
<span class="w">    </span><span class="c1">; #C =&gt; creates a complex number</span>

<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to 2</span>
<span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to 7</span>
<span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to 20</span>
<span class="p">(</span><span class="nb">expt</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to 8</span>
<span class="p">(</span><span class="nb">mod</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to 1</span>
<span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">35</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to 7</span>
<span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to 1/3</span>
<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="m">#C</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="m">#C</span><span class="p">(</span><span class="mi">6</span><span class="w"> </span><span class="mi">-4</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to #C(7 -2)</span>

<span class="c1">;; COMPARISON OPERATORS</span>
<span class="w">    </span><span class="c1">; = =&gt; complete equality check for numbers</span>
<span class="w">    </span><span class="c1">; /= =&gt; complete inequality check for numbers</span>
<span class="w">    </span><span class="c1">; &lt; &gt; &lt;= &gt;= are also comparison operators for numbers</span>
<span class="w">    </span><span class="c1">; equal =&gt; complete equality check for structure (value) for lists, strings, bit-vectors</span>
<span class="w">    </span><span class="c1">; eql =&gt; stricter than equal, complete equality check for object identity (whether two arguments refer to the same object in memory)</span>

<span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mf">3.0</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to t</span>
<span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to nil</span>
<span class="p">(</span><span class="nb">/=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to t</span>
<span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; evalutes to t</span>
<span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to t</span>
<span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to t</span>
<span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to t</span>

<span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; this evaluates to t since equal checks for structural equality and compares the value of the contents of the lists instead of their place in memory</span>
<span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;a</span><span class="w"> </span><span class="ss">&#39;b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;b</span><span class="w"> </span><span class="ss">&#39;a</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to nil</span>

<span class="p">(</span><span class="nb">eql</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to t</span>
<span class="p">(</span><span class="nb">eql</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mf">3.0</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to nil</span>
<span class="p">(</span><span class="nb">eql</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; this evaluates to nil since not same object in memory despite having structural equality</span>

<span class="c1">;; LOGICAL OPERATORS</span>
<span class="w">    </span><span class="c1">; and </span>
<span class="w">    </span><span class="c1">; or</span>
<span class="w">    </span><span class="c1">; not</span>

<span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to t</span>
<span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to nil</span>
<span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to t</span>
<span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to nil</span>
<span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to nil</span>
<span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to t</span>
</code></pre></div>

<h2>Control structures</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">;;; ---------- CONTROL STRUCTURE ----------</span>

<span class="c1">;; CONDITIONALS</span>
<span class="w">    </span><span class="c1">; as established previously, only nil is false (and () empty list which evaluates to nil), everything else is true (t)</span>
<span class="w">    </span><span class="c1">; conditional syntax =&gt; (if {TEST EXPRESSION} {IF TEST EXPRESSION TRUE} {ELSE EXPRESSION})</span>
<span class="w">    </span><span class="c1">; cond =&gt; chains a series of conditional checks to arrive at a final result</span>
<span class="w">    </span><span class="c1">; typecase =&gt; switch case statement but for type of value</span>

<span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="no">t</span><span class="w"> </span>
<span class="w">    </span><span class="s">&quot;this is true&quot;</span><span class="w"> </span>
<span class="w">    </span><span class="s">&quot;this is false&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to &quot;this is true&quot;</span>

<span class="p">(</span><span class="nb">member</span><span class="w"> </span><span class="ss">&#39;Groucho</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">Harpo</span><span class="w"> </span><span class="nv">Groucho</span><span class="w"> </span><span class="nv">Zeppo</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to &#39;(GROUCHO ZEPPO)</span>
<span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">member</span><span class="w"> </span><span class="ss">&#39;Groucho</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">Harpo</span><span class="w"> </span><span class="nv">Groucho</span><span class="w"> </span><span class="nv">Zeppo</span><span class="p">))</span><span class="w"> </span>
<span class="w">    </span><span class="ss">&#39;yep</span><span class="w"> </span>
<span class="w">    </span><span class="ss">&#39;nope</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to &#39;YEP since all non-nil values including &#39;(GROUCHO ZEPPO) are t</span>

<span class="p">(</span><span class="nb">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;wrong!&quot;</span><span class="p">))</span><span class="w"> </span>
<span class="w">      </span><span class="p">((</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;wrong again!&quot;</span><span class="p">))</span><span class="w"> </span>
<span class="w">      </span><span class="p">(</span><span class="no">t</span><span class="w"> </span><span class="ss">&#39;ok</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to &#39;OK symbol since the first 2 checks were incorrect</span>

<span class="p">(</span><span class="nb">typecase</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nb">string</span><span class="w"> </span><span class="ss">:string</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nc">integer</span><span class="w"> </span><span class="ss">:int</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to :int since 1 is of type integer</span>

<span class="c1">;; LOOPS</span>
<span class="w">    </span><span class="c1">; loop =&gt; creates a loop iteratively that can be augmented with different keywords (:for :from :to :then :finally :across :collect)</span>
<span class="w">    </span><span class="c1">; there is no while loop implementation by default</span>

<span class="c1">;; ITERATION</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">fact</span><span class="w"> </span><span class="p">(</span><span class="nv">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="ss">:for</span><span class="w"> </span><span class="nv">result</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:then</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">result</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span>
<span class="w">     </span><span class="ss">:for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="ss">:from</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:to</span><span class="w"> </span><span class="nv">n</span>
<span class="w">     </span><span class="ss">:finally</span><span class="w"> </span><span class="p">(</span><span class="nb">return</span><span class="w"> </span><span class="nv">result</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">fact</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to 120</span>

<span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="ss">:for</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="ss">:across</span><span class="w"> </span><span class="s">&quot;abcd&quot;</span><span class="w"> </span><span class="ss">:collect</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to (#\a #\b #\c #\d)</span>

<span class="p">(</span><span class="nb">dolist</span><span class="w"> </span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;~A&quot;</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to 1234</span>

<span class="c1">;; RECURSION</span>
<span class="w">    </span><span class="c1">; recursion allows us to achieve the same effect as an iterative loop without actually using a loop</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">fact</span><span class="w"> </span><span class="p">(</span><span class="nv">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">      </span><span class="mi">1</span>
<span class="w">    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="p">(</span><span class="nv">fact</span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)))))</span><span class="w"> </span><span class="c1">; function defintion for a recursive function</span>

<span class="p">(</span><span class="nv">fact</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; similarly evaluates to 120</span>
</code></pre></div>

<h2>Data structures</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">;;; ---------- DATA STRUCTURE -----------</span>

<span class="c1">;; STRUCT</span>
<span class="w">    </span><span class="c1">; defstruct =&gt; creates a struct</span>
<span class="w">    </span><span class="c1">; defparameter =&gt; used to assign struct field values</span>

<span class="p">(</span><span class="nb">defstruct</span><span class="w"> </span><span class="nv">dog</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">breed</span><span class="w"> </span><span class="nv">age</span><span class="p">)</span><span class="w"> </span><span class="c1">; defining dog struct</span>
<span class="p">(</span><span class="nb">defparameter</span><span class="w"> </span><span class="vg">*rover*</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nv">make-dog</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="s">&quot;rover&quot;</span>
<span class="w">              </span><span class="err">:</span><span class="w"> </span><span class="nv">breed</span><span class="w"> </span><span class="s">&quot;collie&quot;</span>
<span class="w">              </span><span class="err">:</span><span class="w"> </span><span class="nv">age</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="c1">; assigning struct field values</span>

<span class="vg">*rover*</span><span class="w"> </span><span class="c1">; evaluates to #S(DOG :NAME &quot;rover&quot; :BREED &quot;collie&quot; :AGE 5)</span>
<span class="p">(</span><span class="nv">dog-name</span><span class="w"> </span><span class="vg">*rover*</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to &quot;rover&quot;</span>

<span class="c1">;; PAIR</span>
<span class="w">    </span><span class="c1">; cons =&gt; creates a pair</span>
<span class="w">    </span><span class="c1">; car =&gt; returns the head of a pair</span>
<span class="w">    </span><span class="c1">; cdr =&gt; returns the tail of a pair</span>

<span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="ss">&#39;SUBJECT</span><span class="w"> </span><span class="ss">&#39;VERB</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to &#39;(SUBJECT . VERB)</span>
<span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="ss">&#39;SUBJECT</span><span class="w"> </span><span class="ss">&#39;VERB</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to SUBJECT</span>
<span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="ss">&#39;SUBJECT</span><span class="w"> </span><span class="ss">&#39;VERB</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to VERB</span>

<span class="c1">;; LIST</span>
<span class="w">    </span><span class="c1">; every list is a linked-list comprised of cons pairs, the final element ending in a nil or &#39;() to mark the end of the list</span>
<span class="w">    </span><span class="c1">; list =&gt; convenient constructor to create a list </span>
<span class="w">    </span><span class="c1">; append =&gt; join two lists</span>
<span class="w">    </span><span class="c1">; concatenate =&gt; join two lists when used alongside &#39;list</span>
<span class="w">    </span><span class="c1">; mapcar =&gt; equivalent of .map</span>
<span class="w">    </span><span class="c1">; remove-if-not =&gt; equivalent of .reduce</span>
<span class="w">    </span><span class="c1">; every =&gt; checks if every list element fulfills a predicate</span>
<span class="w">    </span><span class="c1">; some =&gt; checks if at least one list element fulfills a predicate</span>
<span class="w">    </span><span class="c1">; butlast =&gt; returns a list but removes the last element</span>

<span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">nil</span><span class="p">)))</span><span class="w"> </span><span class="c1">; evaluates to &#39;(1 2 3)</span>
<span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to &#39;(1 2 3)</span>

<span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; this syntax therefore is the equivalent of inserting an element at the front of a list, and evaluates to &#39;(4 1 2 3)</span>
<span class="p">(</span><span class="nb">append</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to &#39;(1 2 3 4)</span>
<span class="p">(</span><span class="nb">concatenate</span><span class="w"> </span><span class="ss">&#39;list</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to &#39;(1 2 3 4)</span>
<span class="p">(</span><span class="nb">mapcar</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">1+</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to &#39;(2 3 4)</span>
<span class="p">(</span><span class="nb">mapcar</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">+</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">30</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to &#39;(11 22 33)</span>
<span class="p">(</span><span class="nb">remove-if-not</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">evenp</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to &#39;(2 4)</span>
<span class="p">(</span><span class="nb">every</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">evenp</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to () which is nil</span>
<span class="p">(</span><span class="nb">some</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">oddp</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to t</span>
<span class="p">(</span><span class="nb">butlast</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">subject</span><span class="w"> </span><span class="nv">verb</span><span class="w"> </span><span class="nv">object</span><span class="p">))</span><span class="c1">; evaluates to (SUBJECT VERB)</span>

<span class="c1">;; VECTOR</span>
<span class="w">    </span><span class="c1">; vector literals are fixed-length arrays</span>
<span class="w">    </span><span class="c1">; #() =&gt; declares a vector literal</span>
<span class="w">    </span><span class="c1">; concatenate =&gt; joins two vectors</span>

<span class="o">#(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to #(1 2 3)</span>
<span class="p">(</span><span class="nb">concatenate</span><span class="w"> </span><span class="ss">&#39;vector</span><span class="w"> </span><span class="o">#(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">#(</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to #(1 2 3 4 5 6)</span>

<span class="c1">;; SET</span>
<span class="w">    </span><span class="c1">; sets are just lists that you call set functions on</span>
<span class="w">    </span><span class="c1">; operates the same as you&#39;d expect in other languages like Python</span>
<span class="w">    </span><span class="c1">; set-difference =&gt; returns the difference between two lists</span>
<span class="w">    </span><span class="c1">; intersection =&gt; returns the similar elements between two lists</span>
<span class="w">    </span><span class="c1">; union =&gt; returns two lists and removes duplicates</span>
<span class="w">    </span><span class="c1">; adjoin =&gt; adds a specified element to the front of the list if element not already present and returns that list</span>

<span class="p">(</span><span class="nb">set-difference</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to (3 2 1)</span>
<span class="p">(</span><span class="nb">intersection</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to 4</span>
<span class="p">(</span><span class="nb">union</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to (3 2 1 4 5 6 7)</span>
<span class="p">(</span><span class="nb">adjoin</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; evaluates to (1 2 3 4)</span>

<span class="c1">;; HASH TABLE</span>
<span class="w">    </span><span class="c1">; equivalent of dictionary </span>
<span class="w">    </span><span class="c1">; make-hash-table =&gt; creates a hash table, used alongside defparameter</span>
<span class="w">    </span><span class="c1">; setf =&gt; sets a hash value</span>
<span class="w">    </span><span class="c1">; gethash =&gt; retrieves a value at a specified hash and returns both the stored value and a boolean (t, nil) depending on whether a value can be found, used for assignment and simple retrieval</span>

<span class="p">(</span><span class="nb">defparameter</span><span class="w"> </span><span class="vg">*m*</span><span class="w"> </span><span class="p">(</span><span class="nb">make-hash-table</span><span class="p">))</span><span class="w"> </span><span class="c1">; creates a global hash table *m*</span>
<span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="p">(</span><span class="nb">gethash</span><span class="w"> </span><span class="ss">&#39;a</span><span class="w"> </span><span class="vg">*m*</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; sets a number value of 1 to the hash &#39;a</span>
<span class="p">(</span><span class="nb">gethash</span><span class="w"> </span><span class="ss">&#39;a</span><span class="w"> </span><span class="vg">*m*</span><span class="p">)</span><span class="w"> </span><span class="c1">; retrieves the value stored at the hash &#39;a in the global hash table *m*, evaluating to 1, T</span>
</code></pre></div>

<h2>Functions</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">;;; ---------- FUNCTION -----------</span>
<span class="w">    </span><span class="c1">; functions always return the evaluated value of the last expression</span>
<span class="w">    </span><span class="c1">; function call syntax where f is function name and x y z are arguments is (f x y z)</span>
<span class="w">    </span><span class="c1">; defun =&gt; creates a function, () is a list accepting arguments to the function</span>
<span class="w">    </span><span class="c1">; &amp;optional =&gt; specifies optional arguments to a function</span>

<span class="c1">;; FUNCTION CREATION</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">hello-world</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; creates the function hello-world that evaluates to the string &quot;Hello World&quot;</span>
<span class="p">(</span><span class="nv">hello-world</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to &quot;Hello World&quot;</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">hello</span><span class="w"> </span><span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="s">&quot;Hello, ~A&quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span><span class="w"> </span><span class="c1">; creates the function hello that accepts the argument name</span>
<span class="p">(</span><span class="nv">hello</span><span class="w"> </span><span class="s">&quot;Steve&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to &quot;Hello, Steve&quot;</span>

<span class="c1">;; OPTIONAL ARGUMENTS</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">hello</span><span class="w"> </span><span class="p">(</span><span class="nv">name</span><span class="w"> </span><span class="k">&amp;optional</span><span class="w"> </span><span class="nv">from</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">from</span>
<span class="w">      </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Hello, ~A, from ~A&quot;</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">from</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;Hello, ~A&quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">)))</span><span class="w"> </span><span class="c1">; optional function arguments (from) default to nil</span>
<span class="p">(</span><span class="nv">hello</span><span class="w"> </span><span class="s">&quot;Jim&quot;</span><span class="w"> </span><span class="s">&quot;Alpacas&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to &quot;Hello, Jim, from Alpacas&quot;</span>

<span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">hello</span><span class="w"> </span><span class="p">(</span><span class="nv">name</span><span class="w"> </span><span class="k">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nv">from</span><span class="w"> </span><span class="s">&quot;The world&quot;</span><span class="p">))</span>
<span class="w">   </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="s">&quot;Hello, ~A, from ~A&quot;</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">from</span><span class="p">))</span><span class="w"> </span><span class="c1">; default values (from&#39;s default value is the string &quot;The World&quot;) can also be specified </span>
<span class="p">(</span><span class="nv">hello</span><span class="w"> </span><span class="s">&quot;Steve&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; default value invoked, evaluates to &quot;Hello, Steve, from The world&quot;</span>
<span class="p">(</span><span class="nv">hello</span><span class="w"> </span><span class="s">&quot;Steve&quot;</span><span class="w"> </span><span class="s">&quot;the alpacas&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; default value not invoked, evaluates to &quot;Hello, Steve, from the alpacas&quot;</span>

<span class="c1">;; ANONYMOUS FUNCTIONS</span>
<span class="w">    </span><span class="c1">; lambda =&gt; creates an anonymous function</span>
<span class="w">    </span><span class="c1">; funcall =&gt; calls an anonymous function with specified known arguments</span>
<span class="w">    </span><span class="c1">; apply =&gt; calls an anonymous function when arguments are not known</span>

<span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; creation of anonymous function evaluates to #&lt;FUNCTION (LAMBDA ()) {1004E7818B}&gt;</span>
<span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">))</span><span class="w"> </span><span class="c1">; =&gt; evaluates to &quot;Hello World&quot;</span>
<span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span><span class="w"> </span><span class="no">nil</span><span class="p">)</span><span class="w"> </span><span class="c1">; evaluates to &quot;Hello World&quot;</span>
</code></pre></div>

<h2>Macros</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">;;; ---------- MACRO ----------</span>
<span class="w">    </span><span class="c1">; macros let us extend the syntax of our language (imagine writing and calling your own functions, except that works for any other part of the language)</span>
<span class="w">    </span><span class="c1">; macros are incredibly complex and a lot of detail has been omitted here</span>

<span class="p">(</span><span class="nb">defmacro</span><span class="w"> </span><span class="nv">while</span><span class="w"> </span><span class="p">(</span><span class="kt">condition</span><span class="w"> </span><span class="k">&amp;body</span><span class="w"> </span><span class="nv">body</span><span class="p">)</span><span class="w"> </span><span class="c1">; this macro implements a while loop in common lisp</span>
<span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="nv">while</span><span class="w"> </span><span class="o">,</span><span class="kt">condition</span>
<span class="w">         </span><span class="nb">do</span>
<span class="w">         </span><span class="p">(</span><span class="k">progn</span>
<span class="w">            </span><span class="o">,@</span><span class="nv">body</span><span class="p">)))</span>
</code></pre></div>

<h2>More on</h2>
<ul>
<li>format</li>
<li>array</li>
<li>adjustable vector</li>
<li>values</li>
<li>&amp;key</li>
<li>classes and objects</li>
<li>macros</li>
<li><a href="https://lisp-lang.org/">lisp-lang.org</a></li>
<li><a href="https://gigamonkeys.com/book/">practical common lisp</a></li>
<li><a href="http://weitz.de/cl-recipes/">lisp recipes</a></li>
<li><a href="https://github.com/CodyReichert/awesome-cl">awesome common lisp</a></li>
<li><a href="https://learnxinyminutes.com/docs/common-lisp/">learn common lisp in y minutes</a></li>
<li><a href="https://learnxinyminutes.com/docs/elisp/">learn emacs elisp in y minutes</a></li>
<li><a href="https://learnxinyminutes.com/docs/lfe/">learn lisp flavoured erlang in y minutes</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
