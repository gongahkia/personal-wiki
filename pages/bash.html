<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Bash - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Bash</h2>

        <dl>
          <dt>File size</dt>
          <dd>11.0KB</dd>

          <dt>Lines of code</dt>
          <dd>317</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Bash</code></h1>
<p>Shell scripting language to pimp out your Arch-Neovim-Tmux development setup.</p>
<h2>Comments</h2>
<pre class="codehilite"><code class="language-bash"># ---------- COMMENT ----------

# this is a single-line comment

:'
this is a 
multi-line
comment
'
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-bash"># ---------- PRINT ----------
    # echo =&gt; prints a string and appends a newline to the output by default
        # -n =&gt; flag specifies not to include a newline in the output

echo &quot;i want to play dead space and this includes a newline automatically&quot;
echo -n &quot;this does not include a newline by default and we must explicitly specify it\n&quot;
</code></pre>

<h2>Quickstart</h2>
<pre class="codehilite"><code class="language-bash"># ---------- QUICKSTART ----------
    # running a bash file requires us to first convert it to an executable using =&gt; chmod +x {FILENAME}, then run it using =&gt; ./{FILENAME}
    # within the cli, the one input source is stdin and the two outputs sourced are stdout and stderr comprising the three streams
        # stdin =&gt; 0, standard input, where user input taken in using read goes
        # stdout =&gt; 1, standard output to the console in response to a command by the programmer running succesfully
        # stderr =&gt; 2, standard error to the console when a command by the programmer results in an error
    # Bash is powerful because most unix-compatible cli commands are valid commands that can be used within a Bash script
</code></pre>

<h2>Variables</h2>
<pre class="codehilite"><code class="language-bash"># ---------- VARIABLE ----------
    # $ =&gt; inserted in front of variable names whenever a variable is called similar to PHP
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-bash"># ---------- TYPE ----------
    # String =&gt; strings and chars, declared with &quot;&quot; double quotation marks
    # Number =&gt; integers and floats, though numbers are treated as Strings by default
    # Boolean =&gt; Bash has no default true or false values, instead the success and failure of commands model boolean values
</code></pre>

<h2>Operators</h2>
<pre class="codehilite"><code class="language-bash"># ---------- OPERATOR ----------

# ARITHMETIC OPERATORS
    # + =&gt; addition
    # - =&gt; subtraction
    # * =&gt; multiplication
    # / =&gt; division
    # % =&gt; modulo operator

# LOGICAL OPERATORS
    # &amp;&amp; =&gt; logical and
    # || =&gt; logical or
    # ! =&gt; logical not

# COMPARISON OPERATORS
    # == =&gt; partial equality check for string values, not type
    # != =&gt; partial inequality check for string values, not type
    # -eq =&gt; partial equality check for numeric values, not type
    # -ne =&gt; partial inequality check for numeric values, not type
    # &gt; &lt; &gt;= &lt;= are also valid comparison operators
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-bash"># ---------- CONTROL STRUCTURE ----------

# ---------- CONDITIONALS ----------

# IF ELIF ELSE
    # predicate is surrounded by [] square brackets

peepee = 10
if [$peepee -eq 10]; then
    echo &quot;peepee is equal to 10!&quot;
elif [$peepee -ne 10]; then
    echo &quot;peepee is not equal to 10!&quot;
else
    echo &quot;logically speaking this should not be possible&quot;
fi

# CASE IN *
    # case in =&gt; declares a case block similar to switch case statements in other languages
    # ) =&gt; appends every case statement's specified value
    # ;; =&gt; append every case statement's logic, acting as the equivalent of a break statement to ensure logic breaks out after a given case is hit
    # * =&gt; specifies the default case should all other conditions fall through

car = 10
case $car in
    &quot;BMW&quot; )
        echo &quot;your kar is a BMW&quot;;;
    &quot;Toyota&quot; )
        echo &quot;aigh bet&quot;;;
    &quot;Honda&quot; )
        echo &quot;your car is a Hoonda&quot;;;
    &quot;Toyota&quot; )
        echo &quot;car ni na&quot;;;
    * )
        echo &quot;this is the default case&quot;;;
esac

# ---------- LOOPS ----------
    # break =&gt; breaks out of the current loop
    # condition =&gt; skips to the next iteration of the given loop

# WHILE DO LOOPS
    # loop condition specified within [] square brackets

number = 1
while [ $number -lt 10 ]
do
    echo &quot;$number&quot;
    number = $((number+1))
done

# UNTIL LOOPS
    # loop condition specified within [] square brackets
    # equivalent of a while false loop in Bash

number = 1
until [ $number -ge 10 ]
do
    echo $number
    number $((number+1))
done

# FOR LOOPS
    # allows for rudimentary for loops with an explicit start, step and end

for (( i=0; i&lt;5; i++ )) 
do
    echo $i
done

# FOR IN LOOPS
    # allows for iteration over a specified range
    # .. =&gt; allows for creation of implicit ranges with the syntax =&gt; {START..END..STEP}

for i in 1 2 3 4 5
do
    echo $i
done # prints 1\n2\n3\n4\n5\n to the stdout

for i in {0..20..2}
do
    echo $i
done # prints 0\n2\n4\n6\n8\n10\n12\n14\n16\n18\n20\n
</code></pre>

<h2>Data structures</h2>
<pre class="codehilite"><code class="language-bash"># ---------- DATA STRUCTURE ----------

# ARRAY
    # dynamically-sized ordered sequence of space-delimited elements of the same type declared with () brackets
    # [] =&gt; access elements within the array via their index and assigning new elements to the array using square bracket notation
    # @ =&gt; used as an index to access all elements within the array
    # # =&gt; returns the length of the array
    # unset =&gt; removes an element from the array

cars = (&quot;BMW&quot; &quot;Toyota&quot; &quot;Honda&quot;)
echo &quot;${cars[1]}&quot; # prints out Toyota, the element of index 1
cars[3] = &quot;Tesla&quot; # adds the element of value &quot;Tesla&quot; to the cars array at index 3
echo &quot;${cars[@]}&quot; # prints out all the elements within the array
echo &quot;${#cars[@]}&quot; # prints out the length of the array, 3
unset cars[1] # removes the element Toyota of index 1

# ASSOCIATIVE ARRAY
    # dynamically-sized unordered sequence of key-value pairs of different types similar to associative arrays in PHP or tables in Lua
    # declare -A =&gt; used to specify a declaration and creation of an associative array at a given name
    # [] =&gt; used to assign and retrieve key-value pairs from the asssociative array

declare -A my_assoc_array
my_assoc_array[&quot;name&quot;]=&quot;John&quot;
my_assoc_array[&quot;age&quot;]=25
echo &quot;${my_assoc_array[&quot;name&quot;]}&quot;
</code></pre>

<h2>Functions</h2>
<pre class="codehilite"><code class="language-bash"># ---------- FUNCTION ----------
    # bash functions don't list function parameters within the bracket after the function name, but within the function logic
    # $ =&gt; accompanied with a number starting from 1 to indicate the function parameters
    # function =&gt; declares and creates a new function of a specified name

function test_function() 
{
    echo -n &quot;this is a new function&quot;
}

function test_function()
{
    echo -n &quot;hello $1, $2, $3, $4&quot; # function takes in 4 arguments and prints them sequentially to the stdout
}
</code></pre>

<h2>Bash tooling</h2>
<pre class="codehilite"><code class="language-bash"># ---------- TOOLING ----------
    # cat =&gt; returns all text within a specified file
        # &gt; =&gt; writes the specified output to a given file
        # &gt;&gt; =&gt; appends the specified output to a given file
    # mkdir =&gt; creates a folder within the local directory
        # -p =&gt; prevents an error if the Bash executable runs more than once
        # -d =&gt; checks for the existence of a file directory at the specified name
    # touch =&gt; creates a file within the local directory
        # -f =&gt; checks for the existence of a file at the specified name
    # curl =&gt; client url that makes a call request from a local client device to the server
        # -O =&gt; specifies the downloaded file should inherit the name assigned to it by the remote server
        # -o =&gt; specifies the downloaded file should be saved under a specified name as provided by the programmer
        # -I =&gt; retrieves downloaded file metadata
    # grep =&gt; powerful search construct within files that supports regular expressions in the syntax grep {SEARCH PARAMETERS} {FILENAME}
        # -i =&gt; removes case sensitivity
        # -n =&gt; adds line numbers to each returned matched pattern
        # -c =&gt; return matched pattern and the number of matches found
        # -v =&gt; return number of lines within the specified file that don't have the pattern

echo &quot;directory name: &quot;
read directory_name
if [ -d &quot;$directory_name&quot; ]
then
    mkdir -p $directory_name
fi

echo &quot;file name: &quot;
read file_name
if [ -f &quot;$file_name&quot; ]
then 
    touch $file_name
fi

url = &quot;https://proof.ovh.net/files/1Mb.dat&quot;
curl ${url}

echo &quot;filename: &quot;
read file_name
if [ -f &quot;$file_name&quot; ]
then
    echo &quot;search parameters: &quot;
    read search_param
    grep -i -n -c -v $search_param $file_name
else
    echo &quot;$file_name does not exist&quot;
fi
</code></pre>

<h2>More on</h2>
<ul>
<li>select in</li>
<li>^</li>
<li>^^</li>
<li>export</li>
<li>IFS</li>
<li>user input</li>
<li>file IO</li>
<li>heredoc delimiter</li>
<li>string concatenation</li>
<li>sed</li>
<li><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html">bash documentation</a></li>
<li><a href="https://learnxinyminutes.com/docs/bash/">learn bash in y minutes</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
