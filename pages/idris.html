<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Idris - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Idris</h2>

        <dl>
          <dt>File size</dt>
          <dd>8.3KB</dd>

          <dt>Lines of code</dt>
          <dd>330</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Idris</code></h1>
<p>Dependently typed functional programming language with theorem proving capabilities.</p>
<h2>Comments</h2>
<pre class="codehilite"><code class="language-idris">-- ---------- COMMENT ----------

-- this is a single-line comment

{- this is a
   multi-line
   comment -}
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-idris">-- ---------- PRINT ----------
    -- putStrLn =&gt; prints a string to stdout with newline
    -- putStr =&gt; prints a string to stdout without newline
    -- print =&gt; prints any showable value
    -- printLn =&gt; prints any showable value with newline

putStrLn &quot;Hello, Idris!&quot;
putStr &quot;No newline here&quot;
print 42
printLn[1][2][3]
</code></pre>

<h2>Quickstart</h2>
<pre class="codehilite"><code class="language-idris">-- ---------- QUICKSTART ----------
    -- Idris is a purely functional language with dependent types
    -- types can depend on values, enabling very precise specifications
    -- : =&gt; type annotation operator
    -- = =&gt; definition operator
    -- totality checking ensures all functions terminate
    -- pattern matching and type inference are core features

module Main

-- Function with dependent type
vect : (n : Nat) -&gt; Type
vect n = Vect n Int

-- Simple function definition
double : Int -&gt; Int
double x = x * 2

main : IO ()
main = putStrLn &quot;Hello, World!&quot;
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-idris">-- ---------- TYPE ----------
    -- Int =&gt; fixed-precision integers
    -- Integer =&gt; arbitrary-precision integers  
    -- Double =&gt; double-precision floating point
    -- Char =&gt; Unicode characters, enclosed in single quotes
    -- String =&gt; strings, enclosed in double quotes
    -- Bool =&gt; True, False
    -- Unit =&gt; () the unit type
    -- Nat =&gt; natural numbers (0, 1, 2, ...)
    -- Type =&gt; type of types
    -- Vect n a =&gt; vectors of length n containing elements of type a

age : Int
age = 25

name : String  
name = &quot;Alice&quot;

flag : Bool
flag = True

letter : Char
letter = 'x'

nothing : Unit
nothing = ()

count : Nat
count = 3

numbers : Vect 3 Int
numbers =[2][3][1]
</code></pre>

<h2>Operators</h2>
<pre class="codehilite"><code class="language-idris">-- ---------- OPERATOR ----------

-- ARITHMETIC OPERATORS
    -- + =&gt; addition
    -- - =&gt; subtraction
    -- * =&gt; multiplication
    -- / =&gt; division (for Double)
    -- div =&gt; integer division
    -- mod =&gt; modulo

-- COMPARISON OPERATORS
    -- == =&gt; equality
    -- /= =&gt; inequality  
    --  = =&gt; comparison operators

-- LOGICAL OPERATORS
    -- &amp;&amp; =&gt; logical and
    -- || =&gt; logical or
    -- not =&gt; logical negation

-- LIST OPERATORS
    -- :: =&gt; cons (prepend to list)
    -- ++ =&gt; list concatenation
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-idris">-- ---------- CONTROL STRUCTURE ----------

-- CONDITIONALS

-- IF THEN ELSE
result : Int
result = if 5 &gt; 3 then 1 else 0

-- PATTERN MATCHING
    -- pattern matching on constructors and values
    -- case expressions for multi-way branching

listLength : List a -&gt; Nat
listLength [] = 0
listLength (x :: xs) = 1 + listLength xs

describe : Int -&gt; String
describe x = case x of
    0 =&gt; &quot;zero&quot;
    1 =&gt; &quot;one&quot;  
    n =&gt; &quot;many: &quot; ++ show n

-- GUARDS
    -- | =&gt; guard syntax for conditional patterns

classify : Int -&gt; String
classify n | n  0 = &quot;positive&quot;

-- LOOPS
    -- functional programming uses recursion instead of loops
    -- higher-order functions like map, filter, fold

-- RECURSION
factorial : Nat -&gt; Nat
factorial Z = 1
factorial (S k) = (S k) * factorial k

-- MAP FILTER FOLD
doubled : List Int
doubled = map (*2)[3][4][1][2]

evens : List Int  
evens = filter even[4][5][6][1][2][3]

sum : List Int -&gt; Int
sum = foldl (+) 0
</code></pre>

<h2>Data structures</h2>
<pre class="codehilite"><code class="language-idris">-- ---------- DATA STRUCTURE ----------

-- LISTS
    -- List a =&gt; homogeneous lists
    -- [] =&gt; empty list
    -- :: =&gt; cons operator

myList : List Int
myList = [1, 2, 3,4]

-- VECTORS
    -- Vect n a =&gt; length-indexed vectors
    -- statically track length in type

myVector : Vect 3 String
myVector = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

-- MAYBE
    -- Maybe a =&gt; optional values
    -- Nothing or Just a

safeDivide : Double -&gt; Double -&gt; Maybe Double
safeDivide x 0 = Nothing
safeDivide x y = Just (x / y)

-- EITHER  
    -- Either a b =&gt; sum type for error handling
    -- Left a or Right b

parseNumber : String -&gt; Either String Int
parseNumber s = case cast s of
    Nothing =&gt; Left &quot;Not a number&quot;
    Just n =&gt; Right n

-- PAIRS
    -- (a, b) =&gt; product types

point : (Int, Int)
point = (10, 20)

-- RECORDS
    -- record syntax for product types with named fields

record Person where
    constructor MkPerson
    name : String
    age : Nat

alice : Person
alice = MkPerson &quot;Alice&quot; 30

-- CUSTOM DATA TYPES
    -- data =&gt; defines algebraic data types

data Tree a = Leaf a | Node (Tree a) (Tree a)

exampleTree : Tree Int
exampleTree = Node (Leaf 1) (Leaf 2)
</code></pre>

<h2>Functions</h2>
<pre class="codehilite"><code class="language-idris">-- ---------- FUNCTION ----------
    -- function_name : Type -&gt; Type -&gt; ... -&gt; ReturnType
    -- function_name arg1 arg2 ... = expression
    -- functions are curried by default
    -- partial application is natural

-- SIMPLE FUNCTIONS
add : Int -&gt; Int -&gt; Int
add x y = x + y

square : Int -&gt; Int
square x = x * x

-- HIGHER-ORDER FUNCTIONS
apply : (a -&gt; b) -&gt; a -&gt; b
apply f x = f x

compose : (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
compose f g x = f (g x)

-- LAMBDA FUNCTIONS
    -- \arg =&gt; expression

increment : Int -&gt; Int
increment = \x =&gt; x + 1

-- DEPENDENT FUNCTIONS
    -- functions where types depend on values

replicate : (n : Nat) -&gt; a -&gt; Vect n a
replicate Z x = []
replicate (S k) x = x :: replicate k x

-- PROOFS AS FUNCTIONS
    -- types as propositions, functions as proofs

plusCommutes : (n : Nat) -&gt; (m : Nat) -&gt; n + m = m + n
plusCommutes Z m = Refl
plusCommutes (S k) m = rewrite plusCommutes k m in Refl
</code></pre>

<h2>More on</h2>
<ul>
<li>dependent types</li>
<li>theorem proving</li>
<li>totality checking</li>
<li>elaborator reflection</li>
<li>interfaces</li>
<li>modules</li>
<li>effects</li>
<li><a href="https://docs.idris-lang.org/">idris documentation</a></li>
<li><a href="https://learnxinyminutes.com/docs/idris/">learn idris in y minutes</a></li>
<li><a href="https://www.manning.com/books/type-driven-development-with-idris">type-driven development with idris</a></li>
<li><a href="https://docs.idris-lang.org/en/latest/tutorial/index.html">idris tutorial</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>Â© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
