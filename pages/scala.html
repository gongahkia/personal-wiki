<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Scala - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Scala</h2>

        <dl>
          <dt>File size</dt>
          <dd>15.5KB</dd>

          <dt>Lines of code</dt>
          <dd>356</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Scala</code></h1>
<p>Hybrid functional and object-oriented programming language that compiles to Java bytecode.</p>
<h2>REPL</h2>
<p>Scala features a REPL analogous to a commandline interpreter. Any Scala expression received will be evaluated and printed to the stdout.</p>
<pre class="codehilite"><code class="language-sh"># ----- Scala REPL -----

$ scala # initialises a Scala REPL as below
scala&gt;

scala&gt; 2 + 2 # each typed expression is automatically saved as a new numbered value
res0: Int = 4

scala&gt; res0 + 2 # previously declared values can be called
res1: Int = 6

scala&gt; :type (true, 2.0) # checking type of a literal without evaluating an expression
(Boolean, Double)

scala&gt; :save /sites/repl-test.scala # saves a Scala REPL session

scala&gt; :load /sites/repl-test.scala # load a Scala file into the REPL to automatically evaluate it
Loading /sites/repl-test.scala...
res2: Int = 4
res3: Int = 6

scala&gt; :h? # browse REPL history to see past expressions entered
1 2 + 2
2 res0 + 2
3 :save /sites/repl-test.scala
4 :load /sites/repl-test.scala
5 :h?
</code></pre>

<h2>Comments</h2>
<pre class="codehilite"><code class="language-scala">// ----- COMMENT -----

// this is a single-line comment

/* 
this is a 
multi-line
comment
*/
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-scala">// ----- PRINT -----
    // print() =&gt; print text to the stdout without a newline
    // println() =&gt; print text to the stdout with a newline

print(&quot;there's no newline and we must explicitly specify it\n&quot;)
println(&quot;this includes a newline automatically&quot;)
</code></pre>

<h2>Imports</h2>
<pre class="codehilite"><code class="language-scala">// ----- IMPORT -----
    // a Scala file can contain multiple classes and objects
    // import =&gt; specifies packages, sub packages and classes to bring into the local scope of the current Scala file
    // {} =&gt; group multiple import items together
    // =&gt; =&gt; rename an import item within the local scope for easier reference
        // _ =&gt; can be combined with above to exclude specific import items from being imported

import scala.collection.immutable.List
import scala.collection.immutable._ // this is a sub package
import scala.collection.immutable.{List, Map} // import multiple classes at once
import scala.collection.immutable.{List =&gt; ImmutableList} // rename the import from List to ImmutableList
import scala.collection.immutable.{Map =&gt; _, Set =&gt; _, _} // import all classes except the specified Map and Set
</code></pre>

<h2>Input and Output</h2>
<pre class="codehilite"><code class="language-scala">// ----- INPUT AND OUTPUT -----
    // scala.io.Source =&gt; package containing read and write methods, has to be imported
        // .fromFile() =&gt; opens file at specified file path
        // .getLines() =&gt; retrieves all the lines within a file and stores them within an iterable structure that can be iterated over with a loop
    // PrintWriter() =&gt; initialses a new PrintWriter write object on the file at the specified file path
        // util.Properties =&gt; package containing further formatting options for writing to the specified file
        // .write() =&gt; writes the designated text as a string to the file
        // .close() =&gt; closes the PrintWriter object

// --- INPUT ---
    // performs read actions

import scala.io.Source // required import
for(line &lt;- Source.fromFile(&quot;myfile.txt&quot;).getLines())
    println(line)

// --- OUTPUT ---
    // performs write actions

val writer = new PrintWriter(&quot;myfile.txt&quot;)
writer.write(&quot;Writing line for line&quot; + util.Properties.lineSeparator)
writer.write(&quot;Another line here&quot; + util.Properties.lineSeparator)
writer.close()
</code></pre>

<h2>Quickstart</h2>
<pre class="codehilite"><code class="language-scala">// ----- QUICKSTART -----
    // Scala is statically typed but affords type inference (Scala compiler determines the type of a given variable if not explicitly defined)
    // a Scala program's entry point is defined within an object's main method
    // scalac =&gt; CLI command to compile the .scala file
    // val =&gt; declares an immutable value that cannot be reassigned
    // var =&gt; declares a mutable value that can be reassigned
    // : =&gt; declares the type of a variable

object Application { // object declaration
    def main(args: Array[String]): Unit = { // main method
        val x:Int = 10 
        x = 20 // this causes an error
        var y:Int = 10
        var z:Double = 1.0
        y = 20 // this is okay
        z = 2.5 // this is also okay
    }
}
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-scala">// ----- TYPE -----
    // Scala features a rich type system consisting of both primitive and complex types

// --- PRIMITIVE TYPE --- 
    // Byte =&gt; 8-bit signed integer
    // Short =&gt; 16-bit signed integer
    // Int =&gt; 32-bit signed integer
    // Long =&gt; 64-bit signed integer
    // Float =&gt; 32-bit single-precision floating point number
    // Double =&gt; 64-bit double-precision floating point number
    // Char =&gt; 16-bit Unicode character declared with '' single quotes
    // Boolean =&gt; true or false
    // Unit =&gt; represents the absence of a value with only one instance (), equivalent to void in Java

// --- REFERENCE TYPE ---
    // String =&gt; sequence of Char primitives, immutable and backed by the Java String class, declared with &quot;&quot; double quotes
    // Option =&gt; datatype representing either an optional value or None
    // Tuple =&gt; data structure storing a fixed number of items of different types, declared with () round brackets
    // List =&gt; immutable linked list
    // Seq =&gt; ordered sequence of elements
    // Set =&gt; unordered sequence of unique elements
    // Map =&gt; collection of key-value pairs

// --- ANY ---
    // Any =&gt; root type of all datatypes in Scala, allowing for Scala's type inference
    // AnyVal =&gt; parent type of all primitive types
    // AnyRef =&gt; parent type of all reference types
</code></pre>

<h2>Operators</h2>
<pre class="codehilite"><code class="language-scala">// ----- OPERATOR -----

// ARITHMETIC OPERATORS
    // + =&gt; addition
    // - =&gt; subtraction
    // * =&gt; multiplication
    // / =&gt; divison
    // % =&gt; modulo

// LOGICAL OPERATORS
    // &amp;&amp; =&gt; logical and
    // || =&gt; logical or
    // ! =&gt; logical not

// COMPARISON OPERATORS
    // == =&gt; complete equality check for value and type
    // != =&gt; complete inequality check for value and type
    // .isInstanceOf[] =&gt; mostly used to check if object is of a specific type
    // &gt;, &lt;, &gt;=, &lt;= are comparison operators and operate as you'd expect

// ASSIGNMENT OPERATORS
    // = =&gt; simple assignment
    // += =&gt; increment by specified value and reassign
    // -= =&gt; decrement by specified value and reassign
    // *= =&gt; multiply by specified value and reassign
    // /= =&gt; divide by specified value and reassign
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-scala">// ----- CONTROL STRUCTURE -----

// ----- CONDITIONAL -----
    // conditionals can be specified for later evaluation within function calls and assignment statements
    // conditionals, like many other things in Scala, can also flexibly be written in a single line
        // if 
        // else
        // else if

val x:Int = 10
if (x == 1) println(&quot;this won't run&quot;)
if (x == 10) println(&quot;this will run&quot;)
if (x == 11) println(&quot;meanwhile this won't run&quot;) else if (x == 12) println(&quot;this also won't run&quot;) else println(&quot;but this will&quot;)
println(if (x == 10) &quot;yeah&quot; else &quot;nope&quot;) // conditionals can be nested within other functions
val text = if (x == 10) &quot;yeah&quot; else &quot;nope&quot; // as well as assignment

// ----- LOOP -----
    // Scala does not feature 'conventional' for loops, but rather employs special keywords like to and by to generate similar structures
        // to =&gt; creates an iterable structure, equivalent of range in Python
        // by =&gt; specifies the step within the given iterable structure being created
    // .foreach() =&gt; equivalent of map() as a signature of functional programming, applies the given function call on a given iterable structure
        // this can be called without dots and brackets also, Scala is generally quite lenient with the function call syntax
    // while loop
        // while =&gt; specifies the predicate condition upon which the while loop runs a check on every iteration
    // do while loop
        // do =&gt; specify the action to be executed every loop iteration
        // while =&gt; specifies the predicate condition upon which the while loop runs a check on every iteration

val r = 1 to 5 // creates an iterable structure with Int's from 1 to 5 and assigns it to r
r.foreach(println) // prints &quot;1\n2\n3\n4\n5\n&quot; to the stdout
(5 to 1 by -1) foreach (println) // initialises an iterable structure literal and iterates over it and prints out each item accordingly

var i = 0
while (i &lt; 10) { // classic while loop
    println(&quot;i &quot; + i)
    i += 1 
}

i = 0
do {
    println(&quot;i is still less than 10&quot;) // classic do while loop
    i += 1
} while (i &lt; 10)
</code></pre>

<h2>Data structures</h2>
<pre class="codehilite"><code class="language-scala">// ----- DATA STRUCTURE -----
    // () =&gt; declares a tuple with its specified element datatypes
    // Option[] =&gt; declares an option type that could either be the specified datatype or None
    // List[] =&gt; declared a linked list with elements of the specified type
    // Set[] =&gt; declares a set with elements of the specified type
    // Map[] =&gt; declares a Map with key-value pairs of the specified types
        // -&gt; =&gt; specifies the relationship between a key-value pair

val tuple: (Int, String, Boolean) = (1, &quot;Scala&quot;, true)
val someValue: Option[Int] = Some(5)
val noValue: Option[Int] = None
val list: List[Int] = List(1, 2, 3)
val set: Set[String] = Set(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)
val map: Map[String, Int] = Map(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 2, &quot;c&quot; -&gt; 3)
</code></pre>

<h2>Functions</h2>
<pre class="codehilite"><code class="language-scala">// ----- FUNCTION -----
    // Scala features implicit return of the last expression within a function block, so there is no return keyword
        // the {} surrounding the function body can be omitted if the entire function body is a single expression that evaluates to the function's return value
    // def =&gt; defines a function similar to Python
    // : =&gt; specifies the datatype of a function's arguments and return values
    // = =&gt; used to assign default values to certain function arguments

def sumOfSquares(x: Int, y: Int): Int = {
    val x2 = x * x
    val y2 = y * y
    x2 + y2 // this last expression is implicitly returned
}

def sumOfSquaresShort(x: Int, y: Int): Int = x * x + y * y // this one-line function evaluates to the single return expression
def addWithDefault(x: Int, y: Int = 5) = x + y // default argument provided to this function

// --- ANONYMOUS FUNCTION ---
    // a hallmark of functional programming languages, where anonymous functions can be assigned to variables
    // =&gt; =&gt; defines an anonymous function and the relationship between the anonymous function's parameters and its return value
        // def and function name are completly omitted in anonymous function declarations

(x: Int) =&gt; x * x // this is an anonymous function
val sq: Int =&gt; Int = x =&gt; x * x // datatype of the anonymous function's parameters and return type can also be specified with this syntax which appears nearly identical to Haskell
</code></pre>

<h2>Pattern Matching</h2>
<pre class="codehilite"><code class="language-scala">// ----- PATTERN MATCHING -----
    // Scala features powerful pattern matching for multiple predicates that uniquely does not require breaks, fall-through simply does not occur
        // Scala even has regex support built in
    // match, case =&gt; creates a match-case expression that allows for pattern matching
        // =&gt; =&gt; specifies the relationship between a give case statement and the relevant execution code
        // _ =&gt; final catch-all character, equivalent of default in other languages

def matchPerson(person: Person): String = person match {
    case Person(&quot;George&quot;, number) =&gt; &quot;We found George! His number is &quot; + number
    case Person(&quot;Kate&quot;, number) =&gt; &quot;We found Kate! Her number is &quot; + number
    case Person(name, number) =&gt; &quot;We matched someone : &quot; + name + &quot;, phone : &quot; + number
}

def matchEverything(obj: Any): String = obj match { // this function's match statement takes in an object of any type
    case &quot;Hello world&quot; =&gt; &quot;Got the string Hello world&quot; // matches a value
    case x: Double =&gt; &quot;Got a Double: &quot; + x // match by type
    case x: Int if x &gt; 10000 =&gt; &quot;Got a pretty big number!&quot; // matches a condition
    case Person(name, number) =&gt; s&quot;Got contact info for $name!&quot; // match the class of a case
    case email(name, domain) =&gt; s&quot;Got email address $name@$domain&quot; // match a regular expression
    case (a: Int, b: Double, c: String) =&gt; s&quot;Got a tuple: $a, $b, $c&quot; // multiple matching within a tuple
    case List(1, b, c) =&gt; s&quot;Got a list with three elements and starts with 1: 1, $b, $c&quot; // match a data structure
    case List(List((1, 2, &quot;YAY&quot;))) =&gt; &quot;Got a list of list of tuple&quot; // nested patterns
    case _ =&gt; &quot;Got unknown object&quot; // match any uncaught case
}
</code></pre>

<h2>More on</h2>
<ul>
<li>Intersection types</li>
<li>Union types</li>
<li>Implicit</li>
<li>Object Oriented Programming</li>
<li>Combinators</li>
<li><a href="https://learnxinyminutes.com/docs/scala/">learn scala in y minutes</a></li>
<li><a href="https://www.scala-lang.org/">scala official documentation</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
