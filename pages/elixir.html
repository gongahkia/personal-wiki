<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: Elixir - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>Elixir</h2>

        <dl>
          <dt>File size</dt>
          <dd>13.0KB</dd>

          <dt>Lines of code</dt>
          <dd>315</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>Elixir</code></h1>
<p>Modern functional language to build high-traffic websites, systems and web apps.</p>
<h2>Comments</h2>
<pre class="codehilite"><code class="language-ex"># ---------- COMMENT ----------

# this is a single-line comment

# there is no built-in
# implementation for 
# multi-line comments
</code></pre>

<h2>Printing</h2>
<pre class="codehilite"><code class="language-ex"># ---------- PRINT ----------
    # printing to the stdout is handled with the IO module
    # IO.write =&gt; prints a string to the stdout and does not include a newline
    # IO.puts =&gt; prints a string to the stdout and appends a newline to the output

IO.write(&quot;this does not include a newline by default and we must explicitly specify it\n&quot;)
IO.puts(&quot;this comes with a newline by default&quot;)
</code></pre>

<h2>Quickstart</h2>
<pre class="codehilite"><code class="language-ex"># ---------- QUICKSTART ----------
    # elixir compiles to beam bytecode to run on the erlang virtual machine
    # functional language, so every expression must evaluate to a single value
    # = =&gt; not the assignment operator but the pattern-matching operator, allowing for powerful matching constructs like in other functional languages where the LHS pattern is matched against the RHS 

[head | tail] = [1,2,3] # here, the = is not an assignment operator but applies the pattern-matching construct
head # this evaluates to the integer value 1
tail # this evaluates to the remaining integer list values [2,3]
</code></pre>

<h2>Types</h2>
<pre class="codehilite"><code class="language-ex"># ---------- TYPE ----------
    # integer =&gt; signed and unsigned integer number
    # float =&gt; signed and unsigned floating-point number
    # boolean =&gt; true, false
    # atom =&gt; constants whose value is their own name, declared with a : colon
    # string =&gt; declared with &quot;&quot; double quotation marks, covers chars also
</code></pre>

<h2>Operators</h2>
<pre class="codehilite"><code class="language-ex"># ---------- OPERATOR ----------

# ARITHMETIC OPERATORS
    # + =&gt; addition
    # - =&gt; subtraction
    # * =&gt; multiplication
    # / =&gt; floor division
    # div =&gt; integer division
    # rem =&gt; equivalent of the modulo operator

# LOGICAL OPERATORS
    # and =&gt; logical and
    # or =&gt; logical or
    # not =&gt; logical not

# COMPARISON OPERATORS
    # == =&gt; partial equality check for value
    # != or /= =&gt; partial inequality check for value
    # === =&gt; complete equality check for value and type
    # !== =&gt; complete inequality check for value and type
    # &lt; &gt; &lt;= &gt;= are also comparison operators
</code></pre>

<h2>Control structures</h2>
<pre class="codehilite"><code class="language-ex"># ---------- CONTROL STRUCTURE ----------

# CONDITIONALS

# IF ELSE
    # elixir has no built-in implementation of elseif statements
    # do end =&gt; used to mark the start and end of the if else block

if false do
    &quot;watermelon&quot;
else
    &quot;shit ass&quot;
end # this evaluates to &quot;shit ass&quot;

# UNLESS ELSE
    # unless =&gt; provides for the negation of a specified condition
    # do end =&gt; used to mark the start and end of the unless else block

unless true do
  &quot;this will never be seen&quot;
else
  &quot;this will shit&quot;
end # this evaluates to &quot;this will shit&quot;

# PATTERN MATCHING
    # elixir's powerful pattern-matching construct rivals Rust in its conciseness and completeness
    # case =&gt; declares and creates a case statement, similar to switch case statements in other languages
    # do end =&gt; used to mark the start and end of a given case statement's cases, within which -&gt; speciifes the relationship between a given case condition and the internal logic to run if said condition is satisfied
    # _ =&gt; catch-all operator used as the equivalent of a default statement in other languages

case {:one, :two} do
    {:four, :five} -&gt;
        &quot;this won't match&quot;
    {:one, x} -&gt;
        &quot;this will match and bind `x` to `:two` in this clause&quot;
    _ -&gt;
        &quot;this will match any value&quot;
end # notice that pattern-matching can occur for tuples and other data structures

[head | _] = [1,2,3] # note the catch-all operator _ can be used to throw away any unwanted value, as seen here where only the head value is matched and assigned and the tail is thrown away
head # this evaluates to the integer value 1

# COND
    # cond =&gt; declares and creates a cond block, which runs mutliple conditional checks at the same time, equivalent to switch case statements in other languages and often used within elixir as a concise alternative to nesting mutliple if statements, with -&gt; specifying the relationship between a condition and the internal logic to run if a given condition evaluates to true
    # do end =&gt; used to mark the start and end of the cond block 
    # true =&gt; it is convention to set the last condition as true to act as a default statement within a cond block

cond do
  1 + 1 == 3 -&gt;
    &quot;I will never be seen&quot;
  2 * 5 == 12 -&gt;
    &quot;me neither&quot;
  1 + 2 == 3 -&gt;
    &quot;but I will&quot;
end # this evaluates to &quot;but I will&quot;

cond do
  1 + 1 == 3 -&gt;
    &quot;I will never be seen&quot;
  2 * 5 == 12 -&gt;
    &quot;me neither&quot;
  true -&gt;
    &quot;but I will&quot;
end # this evaluates to &quot;but I will&quot; as well due to the presence of the true condition which acts as a default statement

# TRY CATCH AFTER
    # try catch =&gt; declares a try catch block, similar to try except in other languages
    # after =&gt; specifies code that should execute regardless of whether a value is caught by the try catch block
    # rescue =&gt; used to handle specified errors
    # do end =&gt; used to mark the start and end of a try catch after block

try do
  throw(:hello)
catch
  message -&gt; &quot;got #{message}.&quot;
after
  IO.puts(&quot;I'm the after clause.&quot;)
end # this prints &quot;I'm the after clause&quot; to the stdout

# RANGES
    # .. =&gt; creates an inclusive range on both ends

1..10 # this evaluates to a range that stores integers from 1 to 10

# LOOPS
    # as a functional language, elixir does not have conventional imperative loops implemented, but offers higher-order functions, recursion and list comprehension that allow for the same effect in a concise manner
    # Enum module =&gt; provides Enum.each, Enum.map, Enum.reduce and other higher-order functions

# LIST COMPREHENSION
    # uses the syntax =&gt; for {PATTERN} &lt;- {ITERABLE STRUCTURE}, {FILTER CONDITIONS}, do: {EXPRESSION}
        # pattern =&gt; applies a specified pattern-matching construct against elements from the iterable structure
        # iterable structure =&gt; data structure like a range, list etc
        # filter conditions =&gt; optional conditions to further filter elements
        # expression =&gt; does something to the given element and includes it in the resulting new list

numbers = [1, 2, 3, 4, 5]
doubled_numbers = for n &lt;- numbers, do: n * 2 # this iterates over the list numbers, taking each value and multiplying it by 2, then reassigning it to a new list doubled_numbers
doubled_numbers # this evaluates to the integer list of value [2, 4, 6, 8, 10]
</code></pre>

<h2>Data structures</h2>
<pre class="codehilite"><code class="language-ex"># ---------- DATA STRUCTURE ----------

# LIST
    # every list is essentially a linked list, where the head consists of the first element of the list and the tail comprises every other element behind the head, causing head operations to be fast but tail operations to be slow
    # [] =&gt; declares and creates a dynamically-sized ordered sequence of elements of the same type
    # [ | ] =&gt; specifies pattern-matching constrct that matches the head and a tail of a list

an_int_list = [1, 2, 3, 4, 5, 6]
[a_head | a_tail] = an_int_list
a_head # this evaluates to the integer value 1
a_tail # this evaluates to the integer list value [2, 3, 4, 5, 6]

# TUPLE
    # tuples allow for faster access to elements by index but are slower for frequent modification
    # {} =&gt; declares and creates a fixed size ordered sequence of elements of different types
    # elem =&gt; retrieves a specified element from a given tuple by its index

a_mixed_tuple = {:ok, &quot;Success&quot;, 42}
first_el = elem(a_mixed_tuple, 0)
second_el = elem(a_mixed_tuple, 1)
third_el = elem(a_mixed_tuple, 2)

first_el # this evaluates to the atom value of :ok
second_el # this evaluates to the string value of &quot;Success&quot;
third_el # this evaluates to the integer value of 42

# MAPS
    # %{} =&gt; declares and creates a map which stores an unordered collection of key-value pairs, their relationship denoted by =&gt;
    # [] =&gt; key-value pairs are created and retrieved by their keys using [] square bracket notation

genders = %{&quot;david&quot; =&gt; &quot;male&quot;, &quot;gillian&quot; =&gt; &quot;female&quot;} // this declares and creates a new map genders which stores string key and string value pairs
genders[&quot;david&quot;] # this evaluates to the string value &quot;male&quot;
</code></pre>

<h2>Functions</h2>
<pre class="codehilite"><code class="language-ex"># ---------- FUNCTION ----------

# ANONYMOUS FUNCTIONS
    # fn =&gt; creates an anonymous lambda function with named parameters specified in () brackets 
    # -&gt; =&gt; specifies the function body within the function definition
    # when =&gt; specifies a predicate that acts as a function guard for function parameters
    # end =&gt; marks the end of a function definition
    # invocation of anonymous functons requires . dot notation

square = fn(x) -&gt; x * x end # declares and creates an anonymous function and assigns it to the variable square
square.(5) # invocation of the anonymous function

f = fn
    x, y when x &gt; 0 -&gt; x + y # specifies the pattern-matching construct that the anonymous function assigned to the variable x can receive before the actual function body
    x, y -&gt; x * y
end

f.(1, 3) # this evaluates to the integer value of 4

# MODULE AND NAMED FUNCTIONS
    # functions that serve the same purpose are grouped together under modules
    # defmodule =&gt; declares and creates a module block
    # def =&gt; declares and creates a public function within the module block that can be called from other modules
    # defp =&gt; declares and creates a private function within the module that can only be called within the module
    # do end =&gt; marks the start and end of a function definition and module block

defmodule PrivateMath do # declares a module called PrivateMath
    def sum(a, b) do
        do_sum(a, b)
    end # declares a public function called sum that can be called from another module

    defp do_sum(a, b) do
        a + b
    end # declares a private function called do_sum that can only be called from within the module
end
</code></pre>

<h2>More on</h2>
<ul>
<li>struct</li>
<li>exceptions</li>
<li>keyword list</li>
<li>mapset</li>
<li>hashset</li>
<li>binary</li>
<li>module visibility</li>
<li>attribute</li>
<li>|&gt;</li>
<li>concurrency</li>
<li>agent</li>
<li>Stream module</li>
<li><a href="https://learnxinyminutes.com/docs/elixir/">learn elixir in y minutes</a></li>
<li><a href="https://elixir-lang.org/docs.html">elixir documentation</a></li>
<li><a href="https://media.pragprog.com/titles/elixir/ElixirCheat.pdf">elixir cheatsheet</a></li>
<li><a href="https://medium.com/@clairedigitalogy/a-beginners-guide-to-elixir-906603251f06">build something in elixir</a></li>
<li><a href="https://learnyousomeerlang.com/">learn you some erlang for great good</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
