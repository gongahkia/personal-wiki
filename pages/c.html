<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Wiki Note: C - Gabriel Ong">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../style.css">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntl-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <link rel="preload" href="https://res.hajimehoshi.com/fonts/SuisseIntlMono-Regular-WebXL.woff2" as="font" crossorigin="anonymous">
  <style>
    .thin-space:after{content:"\2006"}
    pre {
      overflow-x: auto;
      max-width: 100%;
    }
  </style>
  <script src="../script.js" defer></script>
  <title>GABRIEL ONG</title>
  <link rel="shortcut icon" href="../asset/blob.ico" type="image/x-icon">
</head>
<body>
  <div id="click-container"></div>
  <input type="button" id="dark-mode">
  <label for="dark-mode">
    <img id="infinityButton" src="../asset/roller.png" height="24" width="24"/>
  </label>

  <main>
    <article class="overallArticleTags">

      <section class="note-header">
        <h2>C</h2>

        <dl>
          <dt>File size</dt>
          <dd>45.4KB</dd>

          <dt>Lines of code</dt>
          <dd>403</dd>
        </dl>
      </section>

      <section class="note-content">
        <h1><code>C</code></h1>
<h2>Comments</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// single-line comments</span>
<span class="cm">/* multi-line</span>
<span class="cm">comments</span>
<span class="cm">look</span>
<span class="cm">like </span>
<span class="cm">this */</span>
</code></pre></div>

<h2>Importing headers</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ---------- HEADER ----------</span>
<span class="w">    </span><span class="c1">// headers are the equivalent of Python&#39;s modules</span>
<span class="w">    </span><span class="c1">// their contents are syntatically similar to C source files but the file format ends in .h</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
</code></pre></div>

<h2>Printing</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ---------- PRINT ----------</span>
<span class="w">    </span><span class="c1">// printf is print formatted, it does not print a newline by default</span>
<span class="w">        </span><span class="c1">// %c for char</span>
<span class="w">        </span><span class="c1">// %s for strings (char[])</span>
<span class="w">        </span><span class="c1">// %d or %I for short signed</span>
<span class="w">        </span><span class="c1">// %u for short unsigned</span>
<span class="w">        </span><span class="c1">// %ld for long signed</span>
<span class="w">        </span><span class="c1">// %lu for long unsigned</span>
<span class="w">        </span><span class="c1">// %x for unsigned hexadecimal</span>
<span class="w">        </span><span class="c1">// %o for unsigned octal</span>
<span class="w">        </span><span class="c1">// %f for float</span>
<span class="w">        </span><span class="c1">// %lf for double</span>
<span class="w">        </span><span class="c1">// %p for pointer</span>
<span class="w">        </span><span class="c1">// %% to print out %</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;watermelon</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints 0</span>

<span class="c1">// ---------- RECEIVE INPUT ----------</span>
<span class="w">    </span><span class="c1">// scanf takes in an input</span>
<span class="w">    </span><span class="c1">// &amp;input specifies the memory address where we store the input value of type int</span>

<span class="kt">int</span><span class="w"> </span><span class="n">input</span><span class="p">;</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>

<span class="c1">// ---------- SPECIAL CHARACTERS ----------</span>

<span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// newline character</span>
<span class="sc">&#39;\t&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// tab character (left justifies text)</span>
<span class="sc">&#39;\v&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// vertical tab</span>
<span class="sc">&#39;\a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// alert (bell) character</span>
<span class="sc">&#39;\f&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// new page (form feed)</span>
<span class="sc">&#39;\r&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// carriage return</span>
<span class="sc">&#39;\b&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// backspace character</span>
<span class="sc">&#39;\0&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// NULL character. Usually put at end of strings in C.</span>
<span class="sc">&#39;\\&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// backslash</span>
<span class="sc">&#39;\?&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// question mark</span>
<span class="sc">&#39;\&#39;&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// single quote</span>
<span class="sc">&#39;\&quot;&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// double quote</span>
<span class="err">&#39;\</span><span class="n">xhh</span><span class="err">&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// hexadecimal number. Example: &#39;\xb&#39; = vertical tab character</span>
<span class="err">&#39;\</span><span class="mi">0</span><span class="n">oo</span><span class="err">&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// octal number. Example: &#39;\013&#39; = vertical tab character</span>
</code></pre></div>

<h2>Types</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ---------- TYPE ----------</span>
<span class="w">    </span><span class="c1">// sizeof() operator returns the size of a given data type</span>
<span class="w">    </span><span class="c1">// char =&gt; 1 byte, but can be larger, single quotation marks, also known as a character literal</span>
<span class="w">    </span><span class="c1">// char[] =&gt; C&#39;s version of strings, take 1 byte * length of array, double quotation marks</span>
<span class="w">    </span><span class="c1">// int =&gt; 4 bytes, integer types may be signed or unsigned like in Rust</span>
<span class="w">        </span><span class="c1">// short =&gt; 2 bytes</span>
<span class="w">        </span><span class="c1">// long =&gt; 4 - 8 bytes</span>
<span class="w">        </span><span class="c1">// long long =&gt; 8 bytes or more</span>
<span class="w">    </span><span class="c1">// float =&gt; 32-bit </span>
<span class="w">        </span><span class="c1">// double =&gt; larger float, 64-bit</span>
<span class="w">    </span><span class="c1">// 1 or 0 =&gt; C&#39;s version of booleans, 0 being false, 1 being true (though technically any non-0 value is true)</span>

<span class="kt">char</span><span class="w"> </span><span class="n">x_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;y&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// char literals are single quoted</span>
<span class="kt">char</span><span class="w"> </span><span class="n">x_str</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is a string&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// strings are double quoted</span>
<span class="kt">int</span><span class="w"> </span><span class="n">x_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">short</span><span class="w"> </span><span class="n">x_short</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">long</span><span class="w"> </span><span class="n">x_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x_long_long</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="kt">signed</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">z_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-5</span><span class="p">;</span>
<span class="kt">signed</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">a_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1009</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">x_float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.01</span><span class="p">;</span>
<span class="kt">double</span><span class="w"> </span><span class="n">x_double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="c1">// VARIABLES</span>
<span class="w">    </span><span class="c1">// declared once, value can be reassigned later</span>

<span class="c1">// CONST</span>
<span class="w">    </span><span class="c1">// declared once, value can only be assigned once</span>
<span class="w">    </span><span class="c1">// const stated before type of constant value</span>

<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">eg_float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.8</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">eg_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str_literal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;this is good practice&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// for string literals you don&#39;t intend to change, it is good practice to declare them as a constant and a pointer to a char (first element of the char array), which represents a char array</span>
</code></pre></div>

<h2>Data structures</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ---------- ARRAY ----------</span>
<span class="w">    </span><span class="c1">// ordered list of elements of the same data type</span>
<span class="w">    </span><span class="c1">// initialized with a fixed size and type, though array elements are mutable</span>
<span class="w">    </span><span class="c1">// character array is a string (C has no built-in string type)</span>
<span class="w">    </span><span class="c1">// arrays are curly-braced in C</span>

<span class="kt">char</span><span class="w"> </span><span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// allocates 1 * 20 = 20 bytes of space for the char array in memory</span>
<span class="kt">char</span><span class="w"> </span><span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span><span class="w"> </span><span class="c1">// allocates 4 * 20 = 80 bytes of space for the int array in memory</span>
<span class="kt">int</span><span class="w"> </span><span class="n">an_eg_int_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span><span class="w"> </span><span class="c1">// note the curly braces</span>
<span class="kt">char</span><span class="w"> </span><span class="n">an_eg_char_array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">,</span><span class="sc">&#39;c&#39;</span><span class="p">,</span><span class="sc">&#39;d&#39;</span><span class="p">,</span><span class="sc">&#39;e&#39;</span><span class="p">};</span><span class="w"> </span><span class="c1">// another valid char array, although this also evaluates to &quot;abcde&quot;</span>

<span class="c1">// ARRAY INITIALIZER</span>
<span class="w">    </span><span class="c1">// {} initializes an array with default value of 0 past the specified values</span>

<span class="kt">int</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"> </span><span class="c1">// this initializes an int array of 80 bytes with each int being 0</span>
<span class="kt">int</span><span class="w"> </span><span class="n">another_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// this initializes an int array [1,2,0,0,0,0,0,0,0,0], the remaining 8 unspecified values being 0</span>
<span class="kt">int</span><span class="w"> </span><span class="n">yet_another_array</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"> </span><span class="c1">// note that not specifying the size of the array will result in an array of [0] with length 1</span>

<span class="c1">// ARRAY INDEXING </span>

<span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// returns 0, the element at index 0 is 0</span>
<span class="n">my_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// reassigns the element at index 10 to be 2</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">my_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span><span class="w"> </span><span class="c1">// returns 2</span>
<span class="kt">char</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is a string&quot;</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span><span class="w"> </span><span class="c1">// returns 0 (as will byte 17-19) since the string only has chars initialized up to index 15</span>

<span class="c1">// MULTI-DIMENSIONAL ARRAYS</span>

<span class="kt">int</span><span class="w"> </span><span class="n">multi_array</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">}</span>
<span class="p">};</span>
<span class="n">multi_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="c1">// returns 3</span>

<span class="c1">// ---------- TYPE DEF ----------</span>
<span class="w">    </span><span class="c1">// typedef creates a type alias</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">my_type</span><span class="p">;</span><span class="w"> </span><span class="c1">// creates a type alias for int called my_type </span>
<span class="n">my_type</span><span class="w"> </span><span class="n">wow_everyone_so_creative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// declare and assigns an int value to a my_type variable</span>

<span class="c1">// ---------- STRUCT ----------</span>
<span class="w">    </span><span class="c1">// struct creates what is basically a javascript object</span>
<span class="w">    </span><span class="c1">// stores key-value pairs</span>
<span class="w">    </span><span class="c1">// note struct fields (attributes) are separated by semicolons, not commas</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// INITALIZING STRUCT FIELDS</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">my_rect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// struct fields can be intialized immediately</span>

<span class="c1">// ACCESS STRUCT FIELDS</span>
<span class="w">    </span><span class="c1">// dot notation</span>

<span class="n">my_rect</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="c1">// returns 1</span>
<span class="n">my_rect</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="c1">// returns 20</span>

<span class="c1">// typedefs can be assigned to structs for convenience (and also can be done during struct definition)</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="n">rect</span><span class="p">;</span><span class="w"> </span><span class="c1">// this is valid</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">area</span><span class="p">(</span><span class="n">rect</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">rect</span><span class="p">;</span><span class="w"> </span><span class="c1">// this is also valid</span>
</code></pre></div>

<h2>Operators</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ---------- OPERATOR ----------</span>

<span class="c1">// ARITHMETIC</span>

<span class="kt">int</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// valid shorthand for multiple declaration</span>
<span class="kt">float</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// same here as well</span>

<span class="n">i1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// addition</span>
<span class="n">i1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// subtraction</span>
<span class="n">i1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// multiplication</span>
<span class="n">i1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// division, though in this case evaluates to 0.5 is truncated towards 0</span>
<span class="mi">11</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// modulo, be careful when arguments are negative though</span>

<span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// increment by 1 operator, returns j then increments it</span>
<span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="c1">// increment by 1 operator, increments j then returns it</span>
<span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="o">--</span><span class="p">;</span><span class="w"> </span><span class="c1">// decrement by 1 operator, decrements j then returns it</span>
<span class="kt">int</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">--</span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="c1">// decrement by 1 operator, decrements j then returns it</span>

<span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i1</span><span class="o">/</span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// evaluates to 0.5f since we need to cast at least one integer to a float to get a floating-point result</span>
<span class="n">i1</span><span class="o">/</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">i2</span><span class="p">;</span><span class="w"> </span><span class="c1">// does the same for doubles</span>
<span class="n">f1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span><span class="w"> </span><span class="c1">// evaluates to 0.5 since both are floats here so fulfills the above requirement of at least one operand being a float</span>

<span class="c1">// COMPARISON </span>

<span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// complete equality in value and type, returns 0</span>
<span class="mi">3</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// complete inequality in value and type, returns 1</span>
<span class="mi">3</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// comparison operator, returns 1 </span>
<span class="mi">3</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// comparison operator, returns 0</span>
<span class="mi">2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// comparison operator, returns 1</span>
<span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// comparison operator, returns 1</span>

<span class="c1">// LOGICAL</span>

<span class="o">!</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// logical not, returns 0</span>
<span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// logical and, returns 0</span>
<span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// logical or, returns 1</span>
</code></pre></div>

<h2>Control structures</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ---------- CONTROL STRUCTURE ----------</span>

<span class="c1">// IF ELSE IF ELSE</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;x is bigger than 5</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;x is smaller than 5</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;x is 5</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// LOOPS</span>

<span class="c1">// WHILE DO WHILE</span>

<span class="kt">int</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ii</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ii</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// recall that ii++ will increment ii after it retruns it, so this prints the string &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">kk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// do while loops exist too</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">kk</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>

<span class="c1">// FOR</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">jj</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">jj</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// prints the string &quot;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;</span>

<span class="c1">// SWITCH CASE </span>
<span class="w">    </span><span class="c1">// remember to include break after each case, otherwise the logic falls through</span>
<span class="w">    </span><span class="c1">// default case exists</span>

<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>
<span class="w">        </span><span class="c1">// do something</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">        </span><span class="c1">// do something else:</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span>
<span class="w">        </span><span class="c1">// do another thing</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// accounts for the default case like the catch-all operator _ in Rust</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2>Functions</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// ---------- CALL BY VALUE vs CALL BY REFERENCE ----------</span>
<span class="w">    </span><span class="c1">// CALL BY VALUE</span>
<span class="w">        </span><span class="c1">// a copy of the actual variable&#39;s value is called, so we are calling by value (how conventional functions with return values work)</span>
<span class="w">    </span><span class="c1">// CALL BY REFERENCE</span>
<span class="w">        </span><span class="c1">// the actual memory address of the variable is called and any changes are made to the variable itself, so we are calling by reference (how conventional object methods work)</span>

<span class="c1">// ---------- FUNCTION ----------</span>
<span class="w">    </span><span class="c1">// main function</span>
<span class="w">    </span><span class="c1">// function RETURN type specified at the front, followed by the function name and its arguments with their return types</span>
<span class="w">    </span><span class="c1">// functions are call by value by default, and a copy of the actual arguments are passed to a function (ie. the original argument values are not changed when the function is called) and a value has to be returned</span>
<span class="w">    </span><span class="c1">// pointers should be used if you want to edit the actual argument value</span>
<span class="w">        </span><span class="c1">// arrays are passed in as pointers by default</span>
<span class="w">    </span><span class="c1">// RETURN_TYPE FUNCTION_NAME(FUNCTION_ARGUMENTS_AND_TYPE);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// this is every C program&#39;s entry point, all C code must run within the main function</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function_1</span><span class="p">();</span><span class="w"> </span><span class="c1">// you can declare a function ahead of time like this</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">function_2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"> </span><span class="c1">// or like this</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="p">);</span><span class="w"> </span><span class="c1">// this is also valid function declaration</span>
</code></pre></div>

<h2>Pointers</h2>
<div class="codehilite"><pre><span></span><code><span class="c1">// --------- POINTER ----------</span>
<span class="w">    </span><span class="c1">// pointer is a variable declared that stores a memory address</span>
<span class="w">        </span><span class="c1">// pointers variables are declared with * (once)</span>
<span class="w">        </span><span class="c1">// pointer declaration will also specify the type of the variable it points to</span>
<span class="w">        </span><span class="c1">// by convention, pointer variables are named p{variable name}</span>
<span class="w">    </span><span class="c1">// memory addressed of variables can be accessed and played with</span>
<span class="w">        </span><span class="c1">// memory addresses are accessed with &amp;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// stores the memory address of int variable x in pointer variable px (subsequent reference to pointer variable px can be done without the *, that&#39;s used once on declaration only)</span>

<span class="c1">// DEREFERENCE A POINTER</span>
<span class="w">    </span><span class="c1">// to access the actual value at the memory address a pointer variable is pointing to, use the derefernce operator *</span>
<span class="w">    </span><span class="c1">// it is slightly confusing and odd that the dereference and declaration operator are the same, but just go with it</span>

<span class="kt">int</span><span class="w"> </span><span class="n">value_at_px</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">;</span><span class="w"> </span><span class="c1">// evaluates to 0, the int value of variable x previously declared, and note how the * is not seen since that was only declared once on declaration</span>
<span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// changes the actual value of the variable stored at memory address stored in pointer variable px</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">px</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints 1, accessing the value stored at the memory address in the pointer variable px via the derefencing operator *</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// this will also print 1</span>

<span class="c1">// ARRAYS AND POINTERS</span>
<span class="w">    </span><span class="c1">// in memory, an array is just a special chunk of memory that is reserved upon declaration with a fixed size</span>
<span class="w">    </span><span class="c1">// when pointing to an array, pointer variable points to the memory address of the first element of the array even without the &amp; memory address accessing operator</span>
<span class="w">    </span><span class="c1">// this is as arrays are implictly type converted into a pointer (stores a memory address of the first element of the array) when they are assigned to functions or to a pointer variable</span>

<span class="kt">int</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span><span class="w"> </span><span class="c1">// declares and initializes an int array [1,2,3] of 12 bytes</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">px_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_array</span><span class="p">;</span><span class="w"> </span><span class="c1">// notice we don&#39;t need to use the &amp; mem address accesing operator due to implicit type conversion of the array into its pointer (also known as decay)</span>

<span class="c1">// STRINGS AND POINTERS</span>
<span class="w">    </span><span class="c1">// strings are char arrays, but they can also be represented as a pointer to a char (pointer to the first element of the char array as established above)</span>
<span class="w">    </span><span class="c1">// this is done by convention, and should be practised as far as possible when creating const string literals </span>

<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">my_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;This is my very own string literal&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// creates a string literal which should not be modified</span>

<span class="kt">char</span><span class="w"> </span><span class="n">foo</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// this is valid if the length of the string or its contents are meant to be changed later on in writable memory</span>
<span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// this is legal C code, char array foo variable now stores the char array &quot;aoo&quot; which is also represnted as {&#39;a&#39;,&#39;o&#39;,&#39;o&#39;}</span>

<span class="c1">// there are some exceptions to these rules, but in general they are as defined above</span>
</code></pre></div>

<h2>More on</h2>
<ul>
<li>malloc</li>
<li>calloc</li>
<li>free</li>
<li>enums</li>
<li>macros</li>
<li>function prototypes</li>
<li><a href="https://devdocs.io/c/">c documentation</a></li>
<li><a href="https://learnxinyminutes.com/docs/c/">learn c in y minutes</a></li>
<li><a href="https://learncodethehardway.org/c/">learn c the hard way</a></li>
</ul>
      </section>

    </article>

    <footer>
      <p>© 2023-<span id="current-year"></span> Gabriel Ong. All rights reserved.</p>
    </footer>
  </main>

  <div class="wrapper"></div>
</body>
</html>
