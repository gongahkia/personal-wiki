<h1><code>Raku</code></h1>
<p>Perl 6.</p>
<h2>Comments</h2>
<pre><code class="language-raku"># ----- COMMENT -----

# this is a single-line comment

#=begin comment

this is a 
multi-line
comment

#=end comment
</code></pre>
<h2>Printing</h2>
<pre><code class="language-raku"># ----- PRINTING -----
    # print =&gt; receives a string argument which is then printed to the stdout and this does not include a newline by default
    # say =&gt; receives a string argument which is then printed to the stdout including a newline at the end of the output automatically

print &quot;this does not have a newline and we must explicitly specify its inclusion as here\n&quot;;
say &quot;this does have a newline&quot;;
</code></pre>
<h2>Quickstart</h2>
<pre><code class="language-raku"># ----- QUICKSTART -----
    # Raku does not transpile to Perl, but is a distinct language with its own specifications and runtime on MoarVM (the Raku Virtual Machine)
    # Raku can therefore also run on other backends like JVM or JavaScript
    # semicolon-delimited high-level programming language
    # supports high-performance concurrency features
    # flexible powerful type system affording strong, optional and dynamic typing depending on the context and usage 
    # Raku's use cases range from casual scripting to large-scale software development
    # my =&gt; declares a lexically scoped local variable 
    # lexical scoping =&gt; the specified variable is only accessible within the block or scope in which it is declared, where for context variables in Python are lexically scoped based on indentation level
</code></pre>
<h2>Types</h2>
<pre><code class="language-raku"># ----- TYPE -----
    # Raku variables are declared with the following syntax, regardless of whether its a scalar, collection or another specialised type
        # my &lt;datatype&gt; &lt;variableName&gt; = &lt;value&gt;

# --- SCALAR TYPES ---
    # Str =&gt; stores string value declared within &quot;&quot; double quotation marks
    # Int =&gt; stores integer number values
    # Rat =&gt; stores rational number values
    # Num =&gt; stores floating-point number values
    # Complex =&gt; stores complex number values
    # Bool =&gt; True, False
    # Any =&gt; special datatype from which all other datatypes are derived, affording a degree of type inference in Raku for dynamic typing

# --- COLLECTION TYPES ---
    # @ =&gt; declares an array data structure
    # % =&gt; declares a hash data structure
    # % =&gt; declares a set data structure 
    # $ =&gt; declares a bag data structure
    # $ =&gt; declares a mix data structure 
    # @ =&gt; declares a range data structure
    # $ =&gt; declares a tuple data structure

# --- SPECIALISED TYPES ---
    # Signature =&gt; specifies the type signature of parameters fed to a routine
    # $ =&gt; declares a pair, which represents a single key-value pair (observe that a hash therefore comprises multiple pairs)
    # Capture =&gt; represents the actual arguments that are to be passed to a routine, the Capture literal declared within \( and )
    # $ =&gt; declares a junction, which represents a variable that can be one of multiple possible specified datatypes and in a state of superposition of those datatypes where each possible datatype is delimited by the | pipe-operator, the equivalent of a union type in Typescript
    # $ =&gt; declares a promise, which represents a value that will become available in the future, noting the promise literal is declared within start { and }

my Str $name = &quot;Alice&quot;;
my Int $age = 30;
my Rat $half = 0.5;
my Num $pi = 3.14;
my Complex $c = 1+2i;
my Bool $is_valid = True;
my Any $value;

my @array = (1, 2, 3, 4, 5);
my %hash = 'name' =&gt; 'Alice', 'age' =&gt; 30;
my %set = set('apple', 'banana', 'cherry');
my $bag = bag('apple' =&gt; 3, 'banana' =&gt; 2);
my $mix = mix('apple' =&gt; 1.5, 'banana' =&gt; 2.5);
my @range = 1..10;
my $tuple = (1, &quot;two&quot;, 3.0);

my Signature $sig = :(Int $x, Str $y);
my $pair = 'name' =&gt; 'Alice';
my Capture $capture = \(1, 2, 3);
my $any = 1 | 2 | 3; 
my $promise = start { sleep 2; 42 };
</code></pre>
<h2>Operators</h2>
<pre><code class="language-raku"># ----- OPERATOR -----

# --- ARITHMETIC OPERATORS ---

+ # addition
- # subtraction
* # multiplication
/ # division
% # modulo

# --- COMPARISON OPERATORS ---

== # partial equality check for value but not type
!= # partial inequality check for value but not type
&gt; # comparison operator
&lt; # comparison operator
&gt;= # comparison operator
&lt;= # comparison operator

# --- LOGICAL OPERATORS ---

&amp;&amp; # logical and
|| # logical or
! # logical not
</code></pre>
<h2>Control structures</h2>
<pre><code class="language-raku"># ----- CONTROL STRUCTURE -----

# --- CONDITIONALS ---

# IF ELSIF ELSE 

my $x = 10;
if $x &gt; 5 {
    say &quot;$x is greater than 5&quot;;
} elsif $x == 5 {
    say &quot;$x is equal to 5&quot;;
} else {
    say &quot;$x is less than 5&quot;;
}

# GIVEN WHEN DEFAULT
    # provides a basic degree of pattern-matching in Raku, the equivalent of match case or switch case constructs in most other programming languages
    # default =&gt; specifies the fall-through default case that executes if all other predicate case conditions fail

my $value = 42;
given $value {
    when 1 {
        say &quot;Value is 1&quot;;
    }
    when 42 {
        say &quot;Value is 42&quot;;
    }
    when 100 {
        say &quot;Value is 100&quot;;
    }
    default {
        say &quot;Value is something else&quot;;
    }
}

# --- LOOPS ---

# WHILE
    # operates the same as while loops in most other programming languages

my $count = 0;
while $count &lt; 5 {
    say $count;
    $count++;
}

# FOR -&gt;
    # allows for iteration and traversal over an iterable data structure in Raku
    # the equivalent of a for in loop in Python and foreach loops in PHP

for 1..5 -&gt; $i {
    say $i;
}

# REPEAT WHILE
    # the equivalent of a do while loop in most other programming languages

my $count = 0;
repeat {
    say $count;
    $count++;
} while $count &lt; 5;
</code></pre>
<h2>Data structures</h2>
<pre><code class="language-raku"># ----- DATA STRUCTURE -----
    # array =&gt; dynamically-sized mutable ordered collection of elements of multiple datatypes, declared within &lt;&gt; angle brackets
    # tuple =&gt; fixed-size immutable ordered collection of elements of multiple datatypes, declared within () round brackets
    # hash =&gt; dynamically-sized mutable unordered collection of key-value pairs of multiple datatypes, each , comma-delimited key-value pair declared with '' single quotation marks and =&gt; an arrow
    # set =&gt; fixed-size immutable unordered collection of unique elements of multiple datatypes, supporting special set-specific operations , declared within set()
    # bag =&gt; fixed-size immutable unordered collection of key-value pairs, where each key is a specified named value and each value is an integer number count, declared within bag()
    # mix =&gt; fixed-size immutable unordered collection of key-value pairs, where each key is a specified named value and each value is a fractional number count, declared within mix()
    # range =&gt; dynamically-generated iterable data structure representing a sequence of values (mostly numbers) defined by the range's start and end value, within which values are lazily evaluated with a default increment of 1 if not specified, declared with .. the range operator delimiting the range's start and end value

my @anExamplefruitArray = &lt;apple banana cherry&gt;;
my $anExampleABCTuple = (1, 2, 3);
my %anExampleCapitalsHash = 'France' =&gt; 'Paris', 'Germany' =&gt; 'Berlin';
my %anExampleZestySet = set('apple', 'banana', 'cherry');
my $anExampleVitaminBag = bag('apple' =&gt; 3, 'banana' =&gt; 2);
my $anExampleCabbageShopMix = mix('apple' =&gt; 1.5, 'banana' =&gt; 2.5);
my @anExampleNumberRange = 1..10; 
</code></pre>
<h2>Functions</h2>
<pre><code class="language-raku"># ----- FUNCTION -----
    # sub &lt;functionName&gt; ( &lt;functionParameterName(s)&gt; = &lt;optionalFunctionDefaultParameterValue(s)&gt; ) { &lt;functionDefinitionBody&gt; } =&gt; declaration and definition of a named function with an optional default parameter specification
    # sub &lt;functionName&gt; ( :&lt;functionParameterName(s)&gt; ) { &lt;functionDefinitionBody&gt; } =&gt; declaration and definition of a named function with named parameters
        # named parameters allow for arguments to be passed to a function under the specified parameter name instead of purely relying on the position of the function parameters in the function declaration and call

sub add($a, $b) { # function definition and declaration
    return $a + $b;
}
my $result = add(2, 3); # 5

sub greet($name = &quot;World&quot;) { # default parameter specified within function definition
    say &quot;Hello, $name!&quot;;
}
greet(&quot;Alice&quot;); # Hello, Alice!
greet(); # Hello, World!

sub print_info(:$name, :$age) { # named parameters within a function definition
    say &quot;Name: $name, Age: $age&quot;;
}
print_info(:name(&quot;Bob&quot;), :age(25)); # function call with named parameters
</code></pre>
<h2>More on</h2>
<ul>
<li><a href="https://docs.raku.org/language/typesystem">subset datatype</a></li>
<li><a href="https://docs.raku.org/routines">routines</a></li>
<li><a href="https://docs.raku.org/">raku documentation</a></li>
<li><a href="https://learnxinyminutes.com/docs/raku/">learn raku in y minutes</a></li>
</ul>
