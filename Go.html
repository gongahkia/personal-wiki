<h1><code>Go</code></h1>
<p>Google's programming language authored by the creator of C.</p>
<h2>Comments</h2>
<pre><code class="language-go"><span class="hljs-comment">// ---------- COMMENT ----------</span>

<span class="hljs-comment">// this is a single-line comment</span>

<span class="hljs-comment">/* 
this is a
multi-line
comment
*/</span>
</code></pre>
<h2>Printing</h2>
<pre><code class="language-go"><span class="hljs-comment">// ---------- PRINT ----------</span>
    <span class="hljs-comment">// printing requires the fmt package which provides functions for file IO</span>
    <span class="hljs-comment">// Print =&gt; prints a string to the stdout and does not include a newline at the end of the output</span>
    <span class="hljs-comment">// Println =&gt; prints a string to the stdout and appends a newline to the output</span>
    <span class="hljs-comment">// Printf =&gt; allows for printing of formatted text augmented with format specifiers for different data types and does not include a newline at the end of the output</span>
        <span class="hljs-comment">// %c =&gt; character</span>
        <span class="hljs-comment">// %s =&gt; string</span>
        <span class="hljs-comment">// %d =&gt; integer</span>
        <span class="hljs-comment">// %f =&gt; floating point</span>
        <span class="hljs-comment">// %t =&gt; boolean</span>
        <span class="hljs-comment">// %p =&gt; pointer</span>
        <span class="hljs-comment">// %T =&gt; returns the data type of the specified value </span>
    <span class="hljs-comment">// ``` =&gt; signposts the start and end of a multi-line string (does not interpret escape sequences)</span>

fmt.Print(<span class="hljs-string">&quot;apple pie but also this does not include a newline at the end and we must specify its inclusion\n&quot;</span>)
fmt.Println(<span class="hljs-string">&quot;this includes a newline at the end of the string by default&quot;</span>)
fmt.Printf(<span class="hljs-string">&quot;the value of pi is approximately %f and we need to explicitly include a newline at the end\n&quot;</span>, <span class="hljs-number">3.14159</span>)
</code></pre>
<h2>Quickstart</h2>
<pre><code class="language-go"><span class="hljs-comment">// ---------- QUICKSTART ----------</span>
    <span class="hljs-comment">// Go is not a semicolon language (semicolons are optional but the Go transpiler removes them and idiomatic Go does not use semicolons whatsoever)</span>
    <span class="hljs-comment">// every script file contains the main function within which all program code is run, acting as the entry point for the executable file</span>
    <span class="hljs-comment">// import =&gt; specifies library packages referenced within the present file, can include an alias in front of the package name as an alias for easier reference</span>
    <span class="hljs-comment">// package =&gt; required at the beginning of a script file, main is a special name declaring an executable for the main function</span>

<span class="hljs-keyword">package</span> main 

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-comment">// part of the Go standard library</span>
    <span class="hljs-string">&quot;io/ioutil&quot;</span> <span class="hljs-comment">// introduces file IO utilties</span>
    <span class="hljs-string">&quot;os&quot;</span> <span class="hljs-comment">// library to handle OS functions </span>
    <span class="hljs-string">&quot;strconv&quot;</span> <span class="hljs-comment">// string conversion library</span>
    m <span class="hljs-string">&quot;math&quot;</span> <span class="hljs-comment">// math library with the local alias m</span>
    n <span class="hljs-string">&quot;net/http&quot;</span> <span class="hljs-comment">// web server library with the local alias n</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// add your code here</span>
}
</code></pre>
<h2>Variables</h2>
<pre><code class="language-go"><span class="hljs-comment">// ---------- VARIABLE ----------</span>
    <span class="hljs-comment">// := =&gt; shorthand declaration and assignment operator</span>
    <span class="hljs-comment">// _ =&gt; catchall wildcard operator allows us to discard an unused variable, generally used within the context of functions</span>

<span class="hljs-keyword">var</span> name <span class="hljs-type">string</span> <span class="hljs-comment">// variable declaration</span>
name = John <span class="hljs-comment">// variable assignment</span>

name := <span class="hljs-string">&quot;John&quot;</span> <span class="hljs-comment">// this both declares the string variable name and assigns the string value &quot;John&quot; to the variable name, being equivalent to the above two lines of code (note that variable type does not then need to be specified)</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">giveTwoNames</span><span class="hljs-params">()</span></span> (name1, name2 <span class="hljs-type">string</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;johnny bravo&quot;</span>, <span class="hljs-string">&quot;chuck norris&quot;</span>
}
_, name2 := giveTwoNames() <span class="hljs-comment">// the _ discards the first name returned by the giveTwoNames function, assigning the string value of &quot;chuck norris&quot; to the string variable name2</span>
</code></pre>
<h2>Types</h2>
<pre><code class="language-go"><span class="hljs-comment">// ---------- TYPE ----------</span>
    <span class="hljs-comment">// int =&gt; signed integer number</span>
    <span class="hljs-comment">// uint =&gt; unsigned integer number</span>
    <span class="hljs-comment">// float32, float64 =&gt; single-precision and double-precision floating-point numbers</span>
    <span class="hljs-comment">// complex64, complex128 =&gt; complex numbers</span>
    <span class="hljs-comment">// byte (alias for uint 8) =&gt; stores any ASCII character which are normally single-byte, &#x27;&#x27; single quotation marks</span>
    <span class="hljs-comment">// rune (alias for int32) =&gt; stores any UNICODE character, allowing storage of multi-byte characters typically seen in characters from other languages, &#x27;&#x27; single quotation marks</span>
    <span class="hljs-comment">// string =&gt; &quot;&quot; double quotation marks</span>
    <span class="hljs-comment">// bool =&gt; true, false</span>
    <span class="hljs-comment">// pointer =&gt; pointer type declared with * asterisk in front of the data type of the specified variable the pointer points toward</span>
        <span class="hljs-comment">// &amp; =&gt; address-of operator, used to retrieve the memory address of a specified variable</span>
        <span class="hljs-comment">// Go has garbage collection, so there is no pointer arithmetic although pointers are still valid</span>
</code></pre>
<h2>Operators</h2>
<pre><code class="language-go"><span class="hljs-comment">// ---------- OPERATOR ----------</span>

<span class="hljs-comment">// ARITHMETIC OPERATORS</span>
    <span class="hljs-comment">// + =&gt; addition</span>
    <span class="hljs-comment">// - =&gt; subtraction</span>
    <span class="hljs-comment">// * =&gt; multiplication</span>
    <span class="hljs-comment">// / =&gt; division</span>
    <span class="hljs-comment">// % =&gt; modulo operator</span>

<span class="hljs-comment">// LOGICAL OPERATORS</span>
    <span class="hljs-comment">// &amp;&amp; =&gt; logical and</span>
    <span class="hljs-comment">// || =&gt; logical or</span>
    <span class="hljs-comment">// ! =&gt; logical not</span>

<span class="hljs-comment">// COMPARISON OPERATORS</span>
    <span class="hljs-comment">// == =&gt; complete equality check for value and type</span>
    <span class="hljs-comment">// != =&gt; complete inequality check for value and type</span>
    <span class="hljs-comment">// &gt; &lt; &gt;= &lt;= are also comparison operators</span>
</code></pre>
<h2>Control structures</h2>
<pre><code class="language-go"><span class="hljs-comment">// ---------- CONTROL STRUCTURE ----------</span>
    <span class="hljs-comment">// Go does not have brackets to segregate its predicate conditional and loop statements</span>

<span class="hljs-comment">// CONDITIONALS</span>

<span class="hljs-comment">// IF ELSE IF ELSE</span>

x := <span class="hljs-number">10</span>
<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">10</span> {
    fmt.Print(<span class="hljs-string">&quot;x is greater than 10&quot;</span>)
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">10</span> {
    fmt.Print(<span class="hljs-string">&quot;x is smaller than 10&quot;</span>)
} <span class="hljs-keyword">else</span> {
    fmt.Print(<span class="hljs-string">&quot;x is equals to 10&quot;</span>)
}

<span class="hljs-comment">// SWITCH CASE DEFAULT  </span>
    <span class="hljs-comment">// note there is no break statement required for each case statement here unlike other languages</span>
    <span class="hljs-comment">// default =&gt; specifies the default case if logic falls through every other case statement within the switch clause</span>

day := <span class="hljs-string">&quot;Monday&quot;</span>
<span class="hljs-keyword">switch</span> day {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Monday&quot;</span>:
        fmt.Print(<span class="hljs-string">&quot;it&#x27;s Monday&quot;</span>)
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Tuesday&quot;</span>:
        fmt.Print(<span class="hljs-string">&quot;it&#x27;s Tuesday&quot;</span>)
    <span class="hljs-keyword">default</span>:
        fmt.Print(<span class="hljs-string">&quot;it&#x27;s another day and this is the default case&quot;</span>)
}

<span class="hljs-comment">// LOOPS</span>
    <span class="hljs-comment">// Go has no while loop construct, but the equivalent can be implemented with for loops</span>

<span class="hljs-comment">// FOR LOOP</span>
    <span class="hljs-comment">// for =&gt; allows for creation of simple and complex iteration-based for loops based on context of usage</span>
    <span class="hljs-comment">// range =&gt; allows for iteration over an iterable data structure (array, slice, string, map, channel) and supports multiple value deconstruction</span>
    <span class="hljs-comment">// break and continue operate similarly as in other languages</span>

<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ { <span class="hljs-comment">// a basic for range-based for loop</span>
    fmt.Print(i)
}

numbers := []<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
<span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> numbers { 
    fmt.Print(index, value)
}

<span class="hljs-comment">// INFINITE FOR LOOP</span>
    <span class="hljs-comment">// specifying a for loop with no predicate or loop condition will result in an infinite loop</span>
    <span class="hljs-comment">// effectively creates a while true loop</span>

<span class="hljs-keyword">for</span> {
    fmt.Println(<span class="hljs-string">&quot;trapped in an infinite loop please help me&quot;</span>) 
}
</code></pre>
<h2>Data structures</h2>
<pre><code class="language-go"><span class="hljs-comment">// ---------- DATA STRUCTURE ----------</span>

<span class="hljs-comment">// ARRAY</span>
    <span class="hljs-comment">// declared with [] square brackets, the array size and {} curly braces</span>
    <span class="hljs-comment">// fixed-size ordered sequence of elements of the same type</span>

anArray := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>} <span class="hljs-comment">// this declares and assigns an int array of size 5 elements</span>

<span class="hljs-comment">// SLICES</span>
    <span class="hljs-comment">// declared with [] square brackets, no specified array size and {} curly braces</span>
    <span class="hljs-comment">// dynamically-sized ordered sequence of elements of the same type, a more flexible array</span>

aSlice := []<span class="hljs-type">int</span>{<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>} <span class="hljs-comment">// this declares and assigns an int slice of dynamic size</span>

<span class="hljs-comment">// MAP</span>
    <span class="hljs-comment">// map =&gt; creates and declares a map storing key-value pairs of a specified type with [] square brackets and {} curly braces</span>
    <span class="hljs-comment">// : =&gt; specified the relationship between a key-value pair</span>
    <span class="hljs-comment">// dynamically-sized unordered sequence of key-value pairs, whose type we specify during declaration and assignment</span>

aMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>{
    <span class="hljs-string">&quot;cerealChicken&quot;</span>: <span class="hljs-number">200</span>,
    <span class="hljs-string">&quot;thaiFish&quot;</span>: <span class="hljs-number">300</span>,
    <span class="hljs-string">&quot;vegetables&quot;</span>: <span class="hljs-number">150</span>,
    <span class="hljs-string">&quot;egg&quot;</span>: <span class="hljs-number">50</span>,
} <span class="hljs-comment">// this declares and assigns a string to int map of dynamic size</span>

<span class="hljs-comment">// STRUCT</span>
    <span class="hljs-comment">// type =&gt; creates a custom data type as a type definition that can be later referenced when instances of the type are created </span>
    <span class="hljs-comment">// struct =&gt; creates and declares a struct that stores multiple values of different specified types within {} curly braces</span>
    <span class="hljs-comment">// Go&#x27;s equivalent of structs in Rust, objects in Javascript, tables in Lua (Go does NOT support OOP and the closest analogue we can get are structs)</span>

<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> {
    Name <span class="hljs-type">string</span>
    Age <span class="hljs-type">int</span>
} <span class="hljs-comment">// this creates a type definition for the Person struct</span>

<span class="hljs-comment">// STRUCT METHODS</span>
    <span class="hljs-comment">// declare a specified method on a struct, where the attributes and methods of a struct instance can be called via . dot syntax</span>
    <span class="hljs-comment">// there are 2 kinds of struct methods</span>
        <span class="hljs-comment">// 1. VALUE RECEIVER METHOD =&gt; func (structAlias structName) methodName() { methodBody }</span>
            <span class="hljs-comment">// struct method operates on a COPY of the struct</span>
            <span class="hljs-comment">// method DOES NOT modify struct state</span>
            <span class="hljs-comment">// modifications made to the struct within the method are LOCAL to the method </span>
        <span class="hljs-comment">// 2. POINTER RECEIVER METHOD =&gt; func (structAlias *structName) methodName() { methodBody } </span>
            <span class="hljs-comment">// struct method operates DIRECTLY ON that original struct</span>
            <span class="hljs-comment">// method MODIFIES struct state</span>
            <span class="hljs-comment">// modifications made to the struct within the method WILL MODIFY original struct state</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Introduce() {
    fmt.Printf(<span class="hljs-string">&quot;Hello, my name is %s and I am %d years old.\n&quot;</span>, p.Name, p.Age)
} <span class="hljs-comment">// this declares the value receiver Introduce method on the Person struct, appropriate since the method DOES NOT need to modify struct state at all (note the syntax to declare the function as a method on the struct Person)</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> DrinkFromFountainOfYouth() {
    p.Age -= <span class="hljs-number">10</span>;
    fmt.Printf(<span class="hljs-string">&quot;You have drank from the fountain of youth and you are now %d years old.\n&quot;</span>, p.Age)
} <span class="hljs-comment">// this declares the pointer receiver DrinkFromFountainOfYouth method on the Person struct, appropriate since the method DOES need to modify struct state (note the syntax to declare the function as a method on the struct Person)</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{

    <span class="hljs-comment">// --- actual execution of code ---</span>

    john := Person{ <span class="hljs-comment">// this declares and assigns an instance of the Person struct to the variable john</span>
        Name: <span class="hljs-string">&quot;John&quot;</span>,
        Age: <span class="hljs-number">30</span>,
    }

    john.Introduce(); <span class="hljs-comment">// calls the Introduce method on the john instance </span>
    john.DrinkFromFountainOfYouth(); <span class="hljs-comment">// calls the DrinkFromFountainOfYouth method on the john instance, deaging john 10 years</span>

}

<span class="hljs-comment">// CHANNEL</span>
    <span class="hljs-comment">// backbone of concurrent programming that affords communication between goroutines to synchronise process execution </span>
    <span class="hljs-comment">// make(chan desiredDatatype) =&gt; creates an unbuffered channel of a specified datatype </span>
    <span class="hljs-comment">// make(chan desiredDatatype, bufferCapacity) =&gt; creates a buffered channel of a specified datatype with a specified buffer capacity</span>
    <span class="hljs-comment">// &lt;- =&gt; sends and receives data through channels, arrow direction indicating flow of data from destination to origin</span>
    <span class="hljs-comment">// close() =&gt; closes a specified channel per the given channel name</span>
    <span class="hljs-comment">// select { case ... } =&gt; equivalent of switch-case statements but select is specifically designed for concurrent programming, to allow waiting on multiple channel simultaneously, where the select clause MATCHES one case when the communication operation (sending or receiving data) is ready to proceed</span>
        <span class="hljs-comment">// default =&gt; similarly specifies the default case if logic falls through every other case statement within the select clause</span>

ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// creates an unbuffered channel of integers and assigns it to the channel variable ch</span>
ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// creates a buffered channel with a buffer capacity of 3 integers and assigns it to the channel variable ch</span>

ch &lt;- <span class="hljs-number">42</span> <span class="hljs-comment">// sends data (integer 42) to the channel variable ch</span>
value := &lt;-ch <span class="hljs-comment">// receives data from a channel variable ch and returns that data to the variable value</span>

<span class="hljs-built_in">close</span>(ch) <span class="hljs-comment">// closes the channel variable ch</span>

<span class="hljs-keyword">select</span> { <span class="hljs-comment">// imagine the channels ch1 and ch2 exist</span>
    <span class="hljs-keyword">case</span> msg1 := &lt;-ch1:
        fmt.Println(<span class="hljs-string">&quot;Received message from ch1:&quot;</span>, msg1)
    <span class="hljs-keyword">case</span> msg2 := &lt;-ch2:
        fmt.Println(<span class="hljs-string">&quot;Received message from ch2:&quot;</span>, msg2)
    <span class="hljs-keyword">default</span>:
        fmt.Println(<span class="hljs-string">&quot;No channel ready&quot;</span>)
} <span class="hljs-comment">// whichever channel&#x27;s communication operation of receiving data is first ready will be matched and have its resulting predicate logic executed</span>
</code></pre>
<h2>Functions</h2>
<pre><code class="language-go"><span class="hljs-comment">// ---------- FUNCTION ----------</span>
    <span class="hljs-comment">// functions are first-class citizens in Go, allowing for implementation of higher-order functions common in functional programming </span>
    <span class="hljs-comment">// func =&gt; declares and creates a function, and function definition specifies the parameter and return type (more than one return value to be specified within brackets)</span>
    <span class="hljs-comment">// return =&gt; specifies the return expression, functions can have multiple return values and named return values</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> { <span class="hljs-comment">// specifies that both parameters a and b are of type int, and the function&#x27;s type signature specifies it returns an int</span>
    <span class="hljs-keyword">return</span> a + b
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">receiveMultiple</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> (sum, prod <span class="hljs-type">int</span>) { <span class="hljs-comment">// specifies that both parameters x and y are of type int, and returns two named values of type int</span>
    <span class="hljs-keyword">return</span> x + y, x * y <span class="hljs-comment">// returns two values, allowing for immediate shorthand assignment via deconstruction when the function is called</span>
}
sum, product := receiveMultiple(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">// this assigns the two results returned by the receiveMultiple function to the sum and product variable respectively</span>

<span class="hljs-comment">// FUNCTION LITERALS</span>
    <span class="hljs-comment">// anonymous functions, another cornerstone of functional programming</span>
    <span class="hljs-comment">// functionDefinition(){ functionBody }(functionArguments) =&gt; defines and calls function literals immediately</span>

isXBig := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> {
    <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">10000</span>
} <span class="hljs-comment">// function literals are effectively closures</span>

fmt.Println(<span class="hljs-string">&quot;Add + double these two numbers: &quot;</span>, 
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {
        <span class="hljs-keyword">return</span> (a + b) * <span class="hljs-number">2</span>
    }(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// immediately calls the function literal inline by providing it with the arguments a = 10 and b = 2</span>
) <span class="hljs-comment">// prints &quot;Add + double these two numbers: 24&quot; to the stdout</span>

<span class="hljs-comment">// DEFER</span>
    <span class="hljs-comment">// defer =&gt; pushes a function call onto a stack, where stacked functions are executed in last in, first out (LIFO) order after the surrounding parent function the defer statement is called within has been returned but before it exits</span>
    <span class="hljs-comment">// normally used to close files, unlock mutexes, release resources and run any cleanup actions after a function has been executed but before it exits</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">usingDefer</span><span class="hljs-params">()</span></span> (ok <span class="hljs-type">bool</span>) {
    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;deferred statements execute in LIFO order only after the parent function usingDefer() has been fully executed.&quot;</span>)
    <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;this line is being printed first because&quot;</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// after this value is returned, the above 2 lines execute in reverse lifo order</span>
}
</code></pre>
<h2>More on</h2>
<ul>
<li>ok</li>
<li>pointer</li>
<li>interface</li>
<li>Goroutines</li>
<li><a href="https://go.dev/play/p/tnWMjr16Mm">go playground</a></li>
<li><a href="https://gobyexample.com/">go by example</a></li>
<li><a href="https://go.dev/doc/">go documentation</a></li>
<li><a href="https://learnxinyminutes.com/docs/go/">learn go in y minutes</a></li>
<li><a href="https://youtube.com/playlist?list=PLEcwzBXTPUE9V1o8mZdC9tNnRZaTgI-1P&amp;si=s8757iY2O_h2H6GM">golang university 101</a></li>
<li><a href="https://youtube.com/playlist?list=PLEcwzBXTPUE_5m_JaMXmGEFgduH8EsuTs&amp;si=G_H7npEdjK5EB-KJ">golang university 201</a></li>
<li><a href="https://youtube.com/playlist?list=PLEcwzBXTPUE8KvXRFmmfPEUmKoy9LfmAf&amp;si=1Y7Bn8Ez_k7lt1Ds">golang university 301</a></li>
</ul>
